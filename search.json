[{"title":"python","path":"/2024/07/29/python/","content":"python1.字面量(1)整数类似数学上面的整数，包括整数和负数 1print(10) # 输出 10 (2)浮点数类似数学上面的小数 1print(13.14) # 输出 13.14 (3)字符串定义： 字符串（string）,又称文本，是由任意数量的字符如中文、英文、各类符号、数字等组成。所以叫做字符的串。 需要用 双引号” “ 或者 单引号’ ’ 或者 三引号”“” “”” 包围起来。 123print(&quot;字符串&quot;) # 输出 字符串print(&#x27;字符串&#x27;) # 输出 字符串print(&quot;&quot;&quot;字符串&quot;&quot;&quot;) # 输出 字符串 2.注释 定义：在程序代码中对程序进行解释的文字 作用：注释不是程序，不能被执行，只是对代码进行解释说明作用，可以让代码的可对性提高 单行注释：以#开头，右边的所有文字为注释文字#号和注释内容一般建议以一个空格隔开.、 多行注释： 以 一对三个双引号 引起来 (“”” “””)来解释说明一段代码的作用使用方法 123456# 我是单行注释&quot;&quot;&quot;我是多行注释&quot;&quot;&quot; 3.变量 在程序运行的时候，能存储计算结果或者能表示值的抽象概念 (1)变量的定义格式12345678&quot;&quot;&quot;变量名 = 变量值变量名 ：每个变量自己的名称，即变量本身 = ：表示将等号右侧的值，赋予左侧的变量变量值 ：每个变量储存的值（内容）&quot;&quot;&quot;name = &quot;断桥圆月&quot; # 示例 (2)变量的赋值123456789&quot;&quot;&quot;- 每个变量可以重复赋值- 每次赋值将覆盖原有值&quot;&quot;&quot;name = &quot;断桥圆月&quot;print(name) # 输出 断桥圆月name = &quot;test&quot;print(name) # 输出 test 4数据类型的查看 变量是没有类型的，但是数据是有类型的 可以使用type(变量名)查看数据的类型 1234567891011# 1.使用print直接输出类型信息print(type(13.14)) # 输出 &lt;class &#x27;float&#x27;&gt;# 2.使用变量存储type()语句的结果(调用type()有返回值)int_type = type(521) print(int_type) # 输出 &lt;class &#x27;int&#x27;&gt;# 3.查看变量中存储的数据类型name = &quot;断桥圆月&quot;print(type(name)) # 输出 &lt;class &#x27;str&#x27;&gt; str为string简写 5.数据类型转换 在一定的条件下，数据的类型可以转换 5.1转为整数12345678910# 字符串转为整数num = &quot;666&quot;print(int(num)) # 输出 666print(&quot;初始值类型：&quot;, type(num), &quot;,转换后类型：&quot;, type(int(num)))# 输出 初始值类型： &lt;class &#x27;str&#x27;&gt; ,转换后类型： &lt;class &#x27;int&#x27;&gt;# 将浮点数转为小数 # 会导致精度丢失，即小数点后面的部分print(int(13.14)) # 输出 13 5.2转为浮点数使用 float(x) ，将x转换为一个浮点数 12345678#字符串转浮点数num = &quot;5.21&quot;print(float(num)) # 输出 5.21print(&quot;初始值类型：&quot;, type(num), &quot;,转换后类型：&quot;,type(float(num)))#输出 初始值类型： &lt;class &#x27;str&#x27;&gt; ,转换后类型： &lt;class &#x27;float&#x27;&gt;#整数转浮点数# 进行补.0print(float(5)) # 输出 5.0 5.3转为字符串123456#使用 str(x) ，将x转换为一个字符串num = 13.14print(str(num)) # 输出 13.14print(&quot;初始值类型：&quot;, type(num), &quot;,转换后类型：&quot;, type(str(num)))# 输出 初始值类型： &lt;class &#x27;float&#x27;&gt; ,转换后类型： &lt;class &#x27;str&#x27;&gt; 6.标识符 用户在编程的时候所使用的一系列用于给变量、类、方法等命名的名字 略 7.运算符略 8.字符串的使用 三种定义方式 1234单引号定义法：name = &#x27;断桥圆月&#x27;双引号定义法：name = &quot;断桥圆月&quot; 三引号定义法：name = &quot;&quot;&quot;断桥圆月&quot;&quot;&quot; 字符串拼接 12345print(&quot;断桥圆月&quot; + &quot;study&quot;) # 输出 观止studyname = &quot;study&quot;print(&quot;断桥圆月&quot; + name) # 输出 观止study 字符串拼接的格式化 123456name = &quot;study&quot;message = &quot;断桥圆月 %s&quot; % nameprint(message) # 输出 断桥圆月 study- % 表示：我要占位- s 表示：将变量变成字符串放入占位的地方 12345hobby = &quot;study&quot;name = &quot;断桥圆月&quot;message = &quot;爱好 %s ,姓名 %s&quot; % (hobby, name)print(message) # 输出 爱好 study ,姓名 断桥圆月 格式符号 意义 %S 将内容转换成字符串，放入占位位置 %d 将内容转换成整数，放入占位位置 %f 将内容转换成浮点型，放入占位位置 123456name = &quot;study&quot;age = 19money = 1.00message = &quot;姓名:%s,年龄:%d,家当：%f&quot; % (name, age, money)print(message) # 输出 姓名:study,年龄:19,家当：1.000000 格式化的精度控制 12345age = 18 # %5d 表示将整数的宽度控制在5位,用三个空格补足宽度money = 1.00 # %.2f 将小数点精度设置为2位message = &quot;断桥圆月%5d,身价：%.2f&quot; % (age, money)print(message) # 输出 断桥圆月 18,身价：1.00 字符串格式化的另外方式 12345age = 18 money = 1.00 message = f&quot;断桥圆月:&#123;age&#125;,身价：&#123;money&#125;&quot;print(message) # 输出 断桥圆月:18,身价：1.0 缺点： 无法做精度控制 不理会数据类型 9.数据输入 使用imput()语句进行输入 123name = input() # 输入 断桥圆月 用name变量来接收输入的数值print(name) # 输出name储存的数值 断桥圆月 可在input()中输入提示信息，将打印在控制台 1234name = input(”tell me your name?“)# 会在控制台打印tell me your name? 然后可输入 断桥圆月 print(name) # 输出name储存的数值 断桥圆月 输入的数值都将转为字符串类型，可通过数据类型转换获取需要的数据类型 1234name = input() # 输入 5print(type(name)) # 输出 &lt;class &#x27;str&#x27;&gt;print(type(int(name))) # 输出 &lt;class &#x27;int&#x27;&gt; 10判断10.1逻辑运算符 and逻辑与运算，等价于数学中的“且”\ta and b\t当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。 or逻辑或运算，等价于数学中的“或”\ta or b\t当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。 not逻辑非运算，等价于数学中的“非”\tnot a\t如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 在python当中，以下变量都会被当成False：任何数值类型的0、””或’’空字符串、空元组()、空列表[]、空字典{}等。 and和or运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果 当遇到一个语句当中有多个逻辑运算符时，按照优先级not&gt;and&gt;or顺序来运算 运算 and运算符当两边都是表达式时：and两边的表达式都为真时才为真，否则为假 123print(15 &gt; 10 and 15 &gt; 6) # 打印 Trueprint(15 &gt; 10 and 15 &lt; 6) # 打印 False 不全是表达式 左边表达式的值为假,左边表达式的值作为最终结果。 左边表达式的值为真，右边表达式的值作为最终结果。 123print(&#123;&#125; and 15) # 打印 &#123;&#125;print(6 and 15) # 打印 15 or运算符 两边都是表达式：or两边的表达式只要有一个真即为真，否则为假 1234print(15 &gt; 10 or 15 &gt; 6) # 打印 Trueprint(15 &gt; 10 or 15 &lt; 6) # 打印 Trueprint(15 &lt; 10 or 15 &lt; 6) # 打印 False 不全是表达式 左边表达式的值为假，右边表达式的值作为最终结果。 左边表达式的值为真，左边表达式的值作为最终结果。 123print(&#123;&#125; or 15) # 打印 15print(6 or 15) # 打印 6 not运算符 当表达式为真时，运算结果就为假；当表达式为假时，运算结果为真。not可以理解为取反的意思 10.2 if 条件为True 执行，条件为False跳过 略 11循环while循环12while 条件：\t条件为True时重复执行 12345i = 0while i &lt; 100: print(&quot;study&quot;) i += 1 # 等效于 i = i + 1 for循环1234for 临时变量 in 待处理数据集(可迭代对象): 循环满足条件时执行的代码# 从待处理数据集中：逐个取出数据赋值给临时变量 12345678910111213# 定义字符串namename = &quot;study&quot;# for循环处理字符串for x in name: print(x)# 将字符串的内容：依次取出# 输出# s# t# u# d# y range语句 语法一: range(num) 12# 获取一个从0开始，到num结束的数字序列（不含num本身）# 如range(5)取得的数据是：[0, 1, 2, 3, 4] 语法二: range(num1，num2) 12# 获得一个从num1开始，到num2结束的数字序列（不含num2本身）# 如，range(5, 10)取得的数据是：[5, 6, 7, 8, 9] 语法三: range(num1, num2, step) 123# 获得一个从num1开始，到num2结束的数字序列（不含num2本身）# 数字之间的步长，以step为准（step默认为1）# 如，range(5, 10, 2)取得的数据是：[5, 7, 9] continue关键字 临时跳过: 暂时跳过本次循环，直接进行下一次 break关键字 直接结束: 提前退出循环，不再继续 12函数123456# 定义def 函数名(传入参数): 函数体 return 返回值# 使用函数名(传入参数) 1234567# 定义def say(): print(&quot;hello world&quot;)# 使用say()# 输出 hello world 123456789101112131415# 定义def add(x, y): res = x + y print(res)# 使用add(10, 6)# 输出 16# 定义def show(x): print(x)# 使用show(10)# 输出 10 12345678910# 定义def add(x, y): return x + y print(&quot;end not print&quot;) # 在return后不再执行输出# 使用res = add(10, 6)print(res)# 只输出 16 1.变量的作用域(1) 局部变量 定义在函数体内部的变量，即只在函数体内部生效 123456def test(): num = 100 print(num)test() # 输出 100print(num) # 报错 name &#x27;num&#x27; is not defined 全局变量 在函数体内、外都能生效的变量 123456num = 100def test(): print(num)test() # 输出 100print(num) # 输出 100 (2) global关键字 一般情况下，在函数内无法修改全局变量的值 12345678num = 100def test(): # 声明一个值为200的局部变量num num = 200 print(num)test() # 输出 200print(num) # 输出 100 使用 global关键字可以在函数内部声明变量为全局变量, 如下所示 123456789num = 100def test(): # 声明num为全局变量 global num num = 200 print(num)test() # 输出 200print(num) # 输出 200 2.函数进阶2.1多返回值123456def test(): return 6, 9, 16x, y, z= test()print(f&quot;第一个值为&#123;x&#125;,第二个值为&#123;y&#125;,第三个值为&#123;z&#125;&quot;)# 输出 第一个值为6,第二个值为9,第三个值为16 支持return不同类型的数据 12345def test(): return &quot;观止&quot;, True, 16x, y, z = test()print(f&quot;第一个值为&#123;x&#125;,第二个值为&#123;y&#125;,第三个值为&#123;z&#125;&quot;)# 输出 第一个值为观止,第二个值为True,第三个值为16 2.2.关键字参数 函数调用时通过“键&#x3D;值”形式传递参数. 1234567def user_info(name, age, gender): print(f&quot;您的名字是&#123;name&#125;,年龄是&#123;age&#125;,性别是&#123;gender&#125;&quot;)user_info(name=&#x27;TOM&#x27;, age=20, gender=&#x27;男&#x27;)# 输出 您的名字是TOM,年龄是20,性别是男user_info(gender=&#x27;男&#x27;, age=20, name=&#x27;TOM&#x27;)# 输出 您的名字是TOM,年龄是20,性别是男 2.3.缺省参数 也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值 所有位置参数必须出现在默认参数前，包括函数定义和调用当调用函数时没有传递参数, 就会使用默认是用缺省参数对应的值.函数调用时，如果为缺省参数传值则修改默认参数值, 否则使用这个默认值 1234567def user_info(name, age, gender=&#x27;男&#x27;): print(f&quot;您的名字是&#123;name&#125;,年龄是&#123;age&#125;,性别是&#123;gender&#125;&quot;)user_info(&#x27;TOM&#x27;, 20)# 输出 您的名字是TOM,年龄是20,性别是男user_info(&#x27;TOM&#x27;, 20, &#x27;女&#x27;)# 输出 您的名字是TOM,年龄是20,性别是女 2.4.不定长参数 也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景. 位置传递 以*号标记一个形式参数，以元组的形式接受参数 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型 1234567def user_info(*args): print(args)user_info(&#x27;TOM&#x27;)# 输出 (&#x27;TOM&#x27;,)user_info(&#x27;TOM&#x27;, 20, &#x27;女&#x27;)# 输出 (&#x27;TOM&#x27;, 20, &#x27;女&#x27;) 关键字传递 关键字不定长传递以**号标记一个形式参数，以字典的形式接受参数 参数是“键&#x3D;值”形式的形式的情况下, 所有的“键&#x3D;值”都会被kwargs接受, 同时会根据“键&#x3D;值”组成字典. 12345def user_info(**kwargs): print(kwargs)user_info(name=&#x27;TOM&#x27;, age=20)# 输出 &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125; lambda匿名函数（未学习）13数据容器 根据特点的不同可分为5类:列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict） 13.1. list123456# 定义列表变量名称 = [元素1, 元素2, 元素3, 元素4, 元素5]# 定义空列表变量名称 = []变量名称 = list() 列表的下标（索引） 我们可以使用下标索引从列表中取出特定位置的数据 正向索引 从前往后的方向，从0开始，依次递增 反向索引 从-1开始，依次递减 使用方式 作用 列表.append(元素) 向列表中追加一个元素 列表.extend(容器) 将数据容器的内容依次取出，追加到列表尾部 列表.insert(下标, 元素) 在指定下标处，插入指定的元素 del 列表[下标] 删除列表指定下标元素 列表.pop(下标) 删除列表指定下标元素 列表.remove(元素) 从前向后，删除此元素第一个匹配项 列表.clear() 清空列表 列表.count(元素) 统计此元素在列表中出现的次数 列表.index(元素) 查找指定元素在列表的下标 找不到报错ValueError len(列表) 统计容器内有多少元素 查询元素查找某元素的下标 查找指定元素在列表的下标，如果找不到，报错ValueError语法：列表.index(元素) 1234my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;, &quot;杜甫&quot;]print(my_list.index(&quot;罗辑&quot;)) # 打印 2print(my_list.index(&quot;断桥圆月&quot;)) # 打印 ValueError: &#x27;观止&#x27; is not in list 插入元素在指定的下标位置，插入指定的元素 语法：列表.insert(下标, 元素) 123my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;]my_list.insert(1, &quot;断桥圆月&quot;)print(my_list) # 打印 [&#x27;李白&#x27;, &#x27;断桥圆月&#x27;, &#x27;章北海&#x27;, &#x27;罗辑&#x27;] 追加元素将指定元素，追加到列表的尾部 语法一：列表.append(元素) 1234my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;]my_list.append(&quot;断桥圆月&quot;)print(my_list) # 打印 [&#x27;李白&#x27;, &#x27;章北海&#x27;, &#x27;罗辑&#x27;, &#x27;断桥圆月&#x27;] 语法二：列表.extend(其它数据容器)将其它数据容器的内容取出，依次追加到列表尾部 1234my_list_1 = [&quot;李白&quot;, &quot;章北海&quot;]my_list_2 = [&quot;罗辑&quot;, &quot;断桥圆月&quot;]my_list_1.extend(my_list_2)print(my_list_1) # 打印 [&#x27;李白&#x27;, &#x27;章北海&#x27;, &#x27;罗辑&#x27;, &#x27;断桥圆月&#x27;] 删除元素语法一:del 列表[下标] 123my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;]del my_list[0]print(my_list) # 打印 [&#x27;章北海&#x27;, &#x27;罗辑&#x27;] 语法二:列表.pop(下标) 123my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;]my_list.pop(0)print(my_list) # 打印 [&#x27;章北海&#x27;, &#x27;罗辑&#x27;] 语法三:列表.remove(元素)删除某元素在列表中的第一个匹配项 123my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;, &quot;李白&quot;]my_list.remove(&quot;李白&quot;)print(my_list) # 打印 [&#x27;章北海&#x27;, &#x27;罗辑&#x27;, &#x27;李白&#x27;] 清空列表内容 语法:列表.clear() 123my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;]my_list.clear()print(my_list) # 打印 [] 统计某元素在列表内的数量 语法:列表.count(元素) 123my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;, &quot;李白&quot;]num = my_list.count(&quot;李白&quot;)print(num) # 打印 2 统计列表内有多少元素 语法:len(列表) 12my_list = [&quot;李白&quot;, &quot;章北海&quot;, &quot;罗辑&quot;, &quot;李白&quot;]print(len(my_list)) # 打印 4 列表的遍历123456789101112my_list = [1,2,3,4]index = 0while index &lt; len(my_list): num = my_list[index] print(num) index += 1 # 输出# 1# 2# 3# 4 123456789my_list = [1, 2, 3, 4]for x in my_list: print(x)# 输出# 1# 2# 3# 4 13.2元组(tuple) 元组同列表一样,但一旦定义完成，就不可修改 (1) 基本格式1234567# 定义元组变量名称 = (元素1, 元素2, 元素3, 元素4, 元素5)# 定义只有一个元素的元组变量名称 = (元素1,)# 定义空元组变量名称 = ()变量名称 = tuple() 元组只有一个数据，这个数据后面要添加逗号，否则不是元组 1234my_tuple = (&quot;观止&quot;)print(type(my_tuple)) # 打印 &lt;class &#x27;str&#x27;&gt;my_tuple = (&quot;观止&quot;,)print(type(my_tuple)) # 打印 &lt;class &#x27;tuple&#x27;&gt; 方法 作用 元组.index(元素) 查找某个数据，如果数据存在返回对应的下标，否则报错 元组.count(元素) 统计某个数据在当前元组出现的次数 len(元组) 统计元组内的元素个数 13.3 字符串（str） 字符串是字符的容器，一个字符串可以存放任意数量的字符。 1234name = &quot;dreamxiaoshen&quot;print(name[0]) # 打印 dprint(name[-1]) # 打印 n 字符串的常用操作 操作 说明 字符串[下标] 根据下标索引取出特定位置字符 字符串.index(字符串） 查找给定字符的第一个匹配项的下标 字符串.replace(字符串1, 字符串2) 将字符串内的全部字符串1，替换为字符串2 不会修改原字符串，而是得到一个新的 字符串.split(字符串) 按照给定字符串，对字符串进行分隔 不会修改原字符串，而是得到一个新的列表 字符串.strip() 字符串.strip(字符串) 移除首尾的空格和换行符或指定字符串 字符串.count(字符串) 统计字符串内某字符串的出现次数 len(字符串) 统计字符串的字符个数 1.查找元素查找特定字符串的下标索引值 语法：字符串.index(字符串) 123name = &quot;dreamxiaoshen&quot;print(name.index(&quot;e&quot;)) # 打印 2 2.替换元素将字符串内的全部：字符串1，替换为字符串2 语法：字符串.replace(字符串1，字符串2） 12345name = &quot;dreamxiaoshen&quot;new_name = name.replace(&quot;dream&quot;, &quot;study&quot;)print(name) # 打印 dreamxiaoshenprint(new_name) # 打印 studyxiaoshen 不是修改字符串本身，而是得到了一个新字符串 3.分割元素按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中 语法：字符串.split(分隔符字符串） 1234567name = &quot;xiaoshen,study,20&quot;new_list = name.split(&quot;,&quot;)print(name) # 打印 xiaoshen,study,20print(new_list) # 打印 [&#x27;xiaoshen&#x27;, &#x27;study&#x27;, &#x27;20&#x27;]print(type(new_list)) # 打印 &lt;class &#x27;list&#x27;&gt;# 字符串按照给定的,进行了分割，变成多个子字符串，并存入一个列表对象中 字符串本身不变，而是得到了一个列表对象 4. 规整操作去前后空格以及换行符语法一：字符串.strip() 1234name = &quot; xiaoshen &quot;new_name = name.strip()print(new_name) # 打印 xiaoshen 去前后指定字符串语法二：字符串.strip(字符串) 12345name = &quot;20xiaoshen20&quot;new_name = name.strip(&quot;20&quot;)print(name) # 打印 20xiaoshen20print(new_name) # 打印 xiaoshen 字符串本身不变，而是得到了一个新字符串 5.统计操作统计字符串中某字符串的出现次数语法一：字符串.count(字符串) 123name = &quot;20xiaoshen20&quot;print(name.count(&quot;20&quot;)) # 打印 2 统计字符串的长度语法二：len(字符串) 123456name = &quot;20xiaoshen 20&quot;print(len(name)) # 打印 13数字（1、2、3…），字母（abcd、ABCD等），符号（空格、!、@、#、$等），中文均算作1个字符(3) 字符串小结同列表、元组一样，字符串也支持while循环和for循环进行遍历 13.4.数据容器（序列）的切片1.基本用法 用法起始下标可以省略，省略从头开始结束下标可以省略，省略到尾结束步长可以省略，省略步长为1（可以为负数，表示倒序执行） 用法一： 1234my_list = [1, 2, 3, 4, 5]new_list = my_list[1:4] # 下标1开始，下标4（不含）结束，步长1print(new_list) # 结果：[2, 3, 4] 用法二： 1234my_tuple = (1, 2, 3, 4, 5)new_tuple = my_tuple[:] # 从头开始，到最后结束，步长1print(new_tuple) # 结果：(1, 2, 3, 4, 5) 用法三： 1234my_list = [1, 2, 3, 4, 5]new_list = my_list[::2] # 从头开始，到最后结束，步长2print(new_list) # 结果：[1, 3, 5] 用法四： 1234my_str = &quot;12345&quot;new_str = my_str[:4:2] # 从头开始，到下标4（不含）结束，步长2print(new_str) # 结果：&quot;13&quot; 用法五： 1234my_list = [1, 2, 3, 4, 5]new_list = my_list[3:1:-1] # 从下标3开始，到下标1（不含）结束，步长-1（倒序）print(new_list) # 打印 [4, 3] 注：这个操作对列表、元组、字符串是通用的此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）起始位置，结束位置，步长（正反序）都是可以自行控制的 13.5.集合(set)不支持元素的重复（自带去重功能）、并且内容无序 (1) 基本格式 1234567# 定义集合变量名称 = &#123;元素1, 元素2, 元素3, 元素4, 元素5&#125;# 定义空集合变量名称 = set() 以大括号 {} 作为标识 集合内每一个元素之间用, 逗号隔开 集合可以一次存储多个数据，且可以为不同的数据类型，支持嵌套 使用示例： 12my_set = &#123;&quot;断桥圆月&quot;, True, &quot;断桥圆月&quot;&#125;print(my_set) # 打印 &#123;True, &#x27;断桥圆月&#x27;&#125; 去重且无序(2) 集合的遍历集合不支持下标索引，所以也就不支持使用while。 因为集合是无序的，所以集合不支持下标索引访问 123456789my_set = &#123;&quot;断桥圆月&quot;, True, &quot;断桥圆月&quot;&#125;for i in my_set: print(i)# 打印# True# 断桥圆月 (3) 集合的常用操作 操作 说明 集合.add(元素) 集合内添加一个元素 集合.remove(元素) 移除集合内指定的元素 集合.pop() 从集合中随机取出一个元素 集合.clear() 将集合清空 集合1.difference(集合2) 得到一个新集合，内含2个集合的差集 原有的2个集合内容不变 集合1.difference_update(集合2) 在集合1中，删除集合2中存在的元素 集合1被修改，集合2不变 集合1.union(集合2) 得到1个新集合，内含2个集合的全部元素 原有的2个集合内容不变 len(集合) 得到一个整数，记录了集合的元素数量 ​ 1. 增加元素集合本身被修改，将指定元素，添加到集合内语法：集合.add(元素) 123my_set = &#123;&quot;断桥圆月&quot;, True, &quot;断桥圆月&quot;&#125;my_set.add(&quot;study&quot;)print(my_set) # 打印 &#123;&#x27;断桥圆月&#x27;, True, &#x27;study&#x27;&#125; 2. 移除元素集合本身被修改，将指定元素，从集合内移除 语法一：集合.remove(元素) 12345my_set = &#123;&quot;断桥圆月&quot;, True, &quot;断桥圆月&quot;&#125;my_set.remove(&quot;断桥圆月&quot;)print(my_set) # 打印 &#123;True&#125; 从集合中随机取出一个元素，同时集合本身被修改，元素被移除 语法二：集合.pop() 1234my_set = &#123;&quot;社区医院&quot;, True&#125;num = my_set.pop()print(my_set) # 打印 &#123;&#x27;断桥圆月&#x27;&#125;print(num) # 打印 True 清空集合,集合本身被清空 语法三：集合.clear() 123my_set = &#123;&quot;断桥圆月&quot;, True&#125;my_set.clear()print(my_set) # 打印 set() 3. 两集合操作取出集合1和集合2的差集（集合1有而集合2没有的)，得到一个新集合，集合1和集合2不变语法一：集合1.difference(集合2) 1234567my_set_1 = &#123;1, 2&#125;my_set_2 = &#123;1, 3&#125;my_set_3 = my_set_1.difference(my_set_2)print(my_set_1) # 打印 &#123;1, 2&#125;print(my_set_2) # 打印 &#123;1, 3&#125;print(my_set_3) # 打印 &#123;2&#125; 对比集合1和集合2，在集合1内，删除和集合2相同的元素,集合1被修改，集合2不变 语法二：集合1.difference_update(集合2) 12345my_set_1 = &#123;1, 2&#125;my_set_2 = &#123;1, 3&#125;my_set_1.difference_update(my_set_2)print(my_set_1) # 打印 &#123;2&#125;print(my_set_2) # 打印 &#123;1, 3&#125; 将集合1和集合2组合成新集合(去重)，集合1和集合2不变语法三：集合1.union(集合2) 1234567my_set_1 = &#123;1, 2&#125;my_set_2 = &#123;1, 3&#125;my_set_3 = my_set_1.union(my_set_2)print(my_set_1) # 打印 &#123;1, 2&#125;print(my_set_2) # 打印 &#123;1, 3&#125;print(my_set_3) # 打印 &#123;1, 2, 3&#125; 4.集合长度查看集合的元素数量，统计集合内有多少元素 语法四：len(集合) 123my_set = &#123;1, 3&#125;print(len(my_set)) # 打印 2 13.6字典、映射(dict)Python中字典和生活中字典十分相像 (1) 基本格式 1234567# 定义字典变量名称 = &#123;key:value, key:value, key:value&#125;# 定义空字典变量名称 = &#123;&#125;变量名称 = dict() 使用{}存储原始，每一个元素是一个键值对每一个键值对包含Key和Value（用冒号分隔）键值对之间使用逗号分隔Key和Value可以是任意类型的数据（key不可为字典）Key不可重复，重复会对原有数据覆盖使用示例: 1234my_dict = &#123;&quot;观止&quot;: 99, &quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;print(my_dict) # 打印 &#123;&#x27;观止&#x27;: 110, &#x27;李白&#x27;: 120&#125;print(type(my_dict)) # 打印 &lt;class &#x27;dict&#x27;&gt; (2) 数据的获取字典同集合一样，不可以使用下标索引取值字典可以通过Key值来取得对应的Value 123my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;print(my_dict[&quot;李白&quot;]) # 打印 120 字典的Key和Value可以是任意数据类型（Key不可为字典）,即字典是可以嵌套的 123456my_dict = &#123; &quot;李白&quot;: &#123;&quot;语文&quot;: 110, &quot;数学&quot;: 100&#125;, &quot;观止&quot;: &#123;&quot;语文&quot;: 90, &quot;数学&quot;: 120&#125;&#125;print(my_dict[&quot;李白&quot;]) # 打印 &#123;&#x27;语文&#x27;: 110, &#x27;数学&#x27;: 100&#125;print(my_dict[&quot;李白&quot;][&quot;语文&quot;]) # 打印 110 字典不支持下标索引，同样不可以用while循环遍历 123456789my_dict = &#123;&quot;李白&quot;: 120, &quot;断桥圆月&quot;: 110&#125;for name in my_dict: print(f&quot;key为：&#123;name&#125;,value为：&#123;my_dict[name]&#125;&quot;)# 打印# key为：李白,value为：120# key为：断桥圆月,value为：110 (3) 字典的常用操作 操作 说明 字典[Key] 获取指定Key对应的Value值 字典[Key] &#x3D; Value 添加或更新键值对 字典.pop(Key) 取出Key对应的Value并在字典内删除此Key的键值对 字典.clear() 清空字典 字典.keys() 获取字典的全部Key，可用于for循环遍历字典 len(字典) 计算字典内的元素数量 ​ 1. 新增元素字典被修改，新增了元素如果key不存在字典中执行上述操作，就是新增元素语法：字典[Key] &#x3D; Value 1234my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;my_dict[&quot;罗辑&quot;] = 115print(my_dict) # 打印 &#123;&#x27;李白&#x27;: 120, &#x27;观止&#x27;: 110, &#x27;罗辑&#x27;: 115&#125; 2. 更新元素字典被修改，元素被更新 字典Key不可以重复，所以对已存在的Key执行上述操作，就是更新Value值 语法：字典[Key] &#x3D; Value 1234my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;my_dict[&quot;李白&quot;] = 115print(my_dict) # 打印 &#123;&#x27;李白&#x27;: 115, &#x27;观止&#x27;: 110&#125; 3. 删除元素获得指定Key的Value，同时字典被修改，指定Key的数据被删除 语法：字典.pop(Key) 1234my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;name = my_dict.pop(&quot;李白&quot;)print(name) # 打印 120print(my_dict) # 打印 &#123;&#x27;观止&#x27;: 110&#125; 4. 清空字典字典被修改，元素被清空 语法：字典.clear() 1234my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;my_dict.clear()print(my_dict) # 打印 &#123;&#125; 5. 获取全部的key得到字典中的全部Key 语法：字典.keys() 1234my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;my_keys = my_dict.keys()print(my_keys) # 打印 dict_keys([&#x27;李白&#x27;, &#x27;观止&#x27;]) 6.计算字典内键值对数量得到一个整数，表示字典内元素（键值对）的数量语法：len(字典) 123my_dict = &#123;&quot;李白&quot;: 120, &quot;观止&quot;: 110&#125;print(len(my_dict)) # 打印 2 简单分类 是否支持下标索引 支持：列表、元组、字符串 - 序列类型 不支持：集合、字典 - 非序列类型 是否支持重复元素： 支持：列表、元组、字符串 - 序列类型 不支持：集合、字典 - 非序列类型 是否可以修改 支持：列表、集合、字典 不支持：元组、字符串 (2) 特点对比 列表 元组 字符串 集合 字典 元素数量 支持多个 支持多个 支持多个 支持多个 支持多个 元素类型 任意 任意 仅字符 任意 Key：Value Key：除字典外任意类型 Value：任意类型 下标索引 支持 支持 支持 不支持 不支持 重复元素 支持 支持 支持 不支持 不支持 可修改性 支持 不支持 不支持 支持 支持 数据有序 是 是 是 否 否 使用场景 可修改、可重复的一批数据记录场景 可修改、可重复的一批数据记录场景 不可修改一串字符的记录场景 不可重复的数据记录场景 以Key检索Value的数据记录场景 14.文件操作未学习15.异常15.1.什么是异常 程序运行的过程中出现了错误 定义：在程序运行中,检测到一个错误，程序中止运行并且出现了一些错误的提示,也称作BUG避免程序中止，提前准备处理可能出现的异常 在真实工作中, 我们肯定不能因为一个小的BUG就让整个程序全部奔溃，而是对BUG进行提醒, 整个程序继续运行三.如何捕获异常在可能出现异常的地方,做好提前准备,当真的出现异常的时候,可以有后续手段。 (1) 捕获常规异常基本语法： 1234567891011try: 可能发生错误的代码except: 如果出现异常执行的代码# 未发生错误try全部代码都会执行# 未发生错误不会执行except中的代码# 发生错误try中只会执行到报错行为止的代码# 发生错误会执行except中的代码 (2) 捕获特定异常如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。基本语法： 1234try: 可能发生错误的代码except 待捕获异常名 as 别名: 如果出现异常执行的代码 例如: 捕获未定义变量产生的错误 1234try: print(name) # 未定义变量，报错except NameError as e: print(&#x27;name变量名称未定义错误&#x27;) 同样的代码却无法捕获处理找不到文件异常 1234try: f = open(&quot;C:/code/study.txt&quot;, &quot;r&quot;) # 文件不存在，报错except NameError as e: print(&#x27;文件不存在&#x27;) (3) 捕获多个异常格式一：当待捕获异常名为Exception可以捕获所有类型异常，作用与(1)一致 例如： 1234try: f = open(&quot;C:/code/study.txt&quot;, &quot;r&quot;)except Exception as e: print(&#x27;文件不存在&#x27;) 格式二:把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。 基本格式： 1234try: 可能发生错误的代码except (异常名1,异常名2) as 别名: 如果出现异常执行的代码 使用示例: 123456# 示例一：try: f = open(&quot;C:/code/study.txt&quot;, &quot;r&quot;)except (FileNotFoundError, NameError) as e: print(&#x27;文件不存在&#x27;) 123456# 示例二： try: print(name)except (FileNotFoundError, NameError) as e: print(&#x27;名称未定义&#x27;) 指定的两种异常都能捕获，未指定的无法捕获到 (4) 其他用法异常描述信息存贮在别名中，可以通过打印别名获取使用示例： 1234try: print(num) # 未定义，报错except (NameError, ZeroDivisionError) as e: print(e) # 打印 name &#x27;num&#x27; is not defined 使用示例： 出现异常，打印结果与(4.2)一致 123456try: print(num) # 未定义，报错except (NameError, ZeroDivisionError) as e: print(e) # 打印 name &#x27;num&#x27; is not definedelse:#else表示的是如果没有异常要执行的代码。 print(&quot;无异常&quot;) # 有异常，不执行 无异常 123456try: print(&quot;正常&quot;) # 不报错except (NameError, ZeroDivisionError) as e: print(e) # 不执行else: print(&quot;无异常&quot;) # 执行 15.2.异常finally finally表示的是无论是否异常都要执行的代码 使用示例： 之前提过，如果open文件却一直未close且程序未中止，将一直占用文件无法操作如果打开文件后发生异常，未close也将导致一直占用，因此可选择在finally中close 1234567global ftry: f = open(&quot;C:/code/aaa.txt&quot;, &quot;r&quot;)except Exception as e: print(e) finally: f.close() # 一定会执行close操作 15.3.异常的传递异常是具有传递性的向上一级抛出 当函数调用链中出现异常，如果所有函数都没有捕获异常的时候, 程序就会报错 利用异常具有传递性的特点, 当我们想要保证程序不会因为异常崩溃的时候, 就可以在主函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到主函数中, 这样就可以确保所有的异常都会被统一捕获 16.包和模块16.1模块(1) 什么是模块一个Python文件,以.py 结尾,能定义函数,类和变量,也能包含可执行的代码 作用：我们可以认为不同的模块就是不同工具包,每一个工具包中都有各种不同的工具(如函数)供我们使用进而实现各种不同的功能. (2) 模块的导入模块在使用之前需要先导入正在开发的文件 导入语法： 123[from 模块名] import [模块|类|变量|函数|*] [as 别名]# *表示导入所有 常用的组合形式如：import 模块名from 模块名 import 类、变量、方法等from 模块名 import *import 模块名 as 别名from 模块名 import 功能名 as 别名 (2.1) 用法一12345678910基本语法：# 导入import 模块名import 模块名1，模块名2# 使用模块名.功能名() 123456789101112# 导入时间模块 import time print(&quot;开始&quot;) # 打印 开始 # 使用time模块中睡眠功能(其中还有众多其他功能) # 可以让程序睡眠10秒后再继续执行time.sleep(10) print(&quot;结束&quot;) #十秒后打印 结束 (2.2) 用法二基本语法 123456# 导入from 模块名 import 功能名# 使用功能名() 使用示例: 123456789101112# 导入时间模块中的sleep方法# 只能使用time模块中导入的sleep的方法from time import sleepprint(&quot;开始&quot;) # 打印 开始 # 让程序睡眠10秒后再继续执行sleep(10) print(&quot;结束&quot;) #十秒后打印 结束 效果图与(2.1)一致 (2.3) 用法三基本语法 123456789101112131415# 导入一：模块定义别名import 模块名 as 别名# 使用一：别名.功能名()# 导入二：功能定义别名from 模块名 import 功能 as 别名# 使用二：别名() 使用示例一: 123456789101112# 本名time将不可用import time as tt print(&quot;开始&quot;) # 打印 开始 # 让程序睡眠10秒后再继续执行# 通过别名调用tt.sleep(10) print(&quot;结束&quot;) #十秒后打印 结束 使用示例二： 12345678910# 本名sleep将不可用from time import sleep as slprint(&quot;开始&quot;) # 打印 开始 # 让程序睡眠10秒后再继续执行sl(10) print(&quot;结束&quot;) # 十秒后打印 结束 效果图与(2.1)一致(2.4) 用法四基本语法 1234567# 导入from 模块名 import *# 使用功能名() 使用示例: 123456789101112# 导入时间模块中的全部功能# 导入效果与(2.1)一致,使用与(2.2)一致from time import *print(&quot;开始&quot;) # 打印 开始 # 让程序睡眠10秒后再继续执行sleep(10) print(&quot;结束&quot;) #十秒后打印 结束 17.面向对象一.什么是面向对象 万物皆对象 现实世界的事物都有属性和行为,可在程序中抽离为类来描述现实世界的事物属性和行为。 使用类充当程序内现实事物的“设计图纸”，基于图纸(类)生产实体（对象），由对象做具体的工作，称之为：面向对象编程 二.类与对象使用类封装属性，基于类创建出一个个的对象来使用 (1) 基本语法12345678910111213141516# 创建类class 类名称: 类的属性(成员变量) 类的行为(成员方法)# 基于类创建对象对象名 = 类名称()# 调用对象名.成员变量对象名.成员方法() class:关键字,表示要定义类了 类的属性:定义在类中的变量(成员变量) -&gt; 事物的属性类的行为:定义在类中的函数(成员方法) -&gt; 事物的行为 (2) 使用示例设计表格即设计类(class)： 123456class Student: name = None # 姓名 sex = None # 性别 country = None # 国籍 native_place = None # 籍贯 age = None # 年龄 打印表格即创建对象： 123stu_1 = Student() # 一张stu_2 = Student() # 两张stu_3 = Student() # 三张 填写表格即使用对象(为属性赋值): 123stu_1.name = &quot;李白&quot;stu_2.name = &quot;观止&quot;stu_3.name = &quot;罗辑&quot; (3) 成员变量和成员方法(3.1) 成员变量 定义在类内部的变量称之为成员变量，用法与正常变量一致。 (3.2) 成员方法 定义在类内部的函数称之为方法，与函数存在细微区别。 1234567891011121314#函数# 形参可以为0-N个def 函数名(形参1,形参2,..,形参N): 函数体# 方法# 形参可以为0-N个# self关键字必须填写def 方法名(self,形参1,形参2,..,形参N): 方法体 self关键字在成员方法定义的时候必须填写，表示类对象自身在方法内部，想要访问类的成员变量，必须使用self 12345678910111213class Student: name = None # 调用say_hi1时正常打印 def say_hi1(self): print(f&quot;大家好，我叫&#123;self.name&#125;&quot;) # 调用say_hi2时报错，&#x27;name&#x27; is not defined def say_hi2(self): print(f&quot;大家好，我叫&#123;name&#125;&quot;) 当我们使用对象调用方法的时，self会自动被python传入,尽管在参数列表中，传参的时候可以忽略它 123456789101112131415161718#定义class Student: name = None def say_hi(self, msg): print(f&quot;大家好，我是&#123;msg&#125;&quot;)# 创建stu_1 = Student()# 通过对象名调用stu_1.say_hi(&quot;练习两年半的偶像实习生&quot;)# 打印 大家好，我是练习两年半的偶像实习生 (4) 构造方法通过传参的形式快速对属性赋值 正常情况下,为对象的属性赋值需要依次进行 12345678910111213141516# 定义类class Student: name = None # 姓名 sex = None # 性别 age = None # 年龄# 创建对象stu_1 = Student()# 为对象赋值stu_1.name = &quot;李白&quot;stu_1.sex = &quot;男&quot;stu_1.age = 1000 在类可以使用：init()方法，即构造方法,快速为对象赋值。 12345678910111213141516171819202122232425262728# 定义类class Student: name = None # 姓名 sex = None # 性别 age = None # 年龄 def __init__(self, name, sex, age): self.name = name self.sex = sex self.age = age# 创建对象并赋值stu_1 = Student(&quot;李白&quot;, &quot;男&quot;, 1000)# 简化形式：可以省略成员属性定义,但仍可调用class Student: def __init__(self, name, sex, age): self.name = name # 姓名 self.sex = sex # 性别 self.age = age # 年龄# 创建对象并赋值stu_1 = Student(&quot;李白&quot;, &quot;男&quot;, 1000) 在创建类对象（构造类）的时候，会自动执行，将传入参数自动传递给__init__方法使用。 构造方法也是成员方法，定义时也需要在参数列表中提供：self 变量定义在构造方法内部，如果要成为成员变量，需要用self来表示，例如self.name 使用了构造方法，创建对象时必须传参否则会报错 (5) 魔术方法Python类内置的类方法，各自有各自特殊的功能 魔术方法非常多，我们学习几个常用的即可。 方法 功能 init 构造方法，可用于创建类对象的时候设置初始化行为 str 字符串方法，用于实现类对象转字符串的行为 lt 用于2个类对象进行小于(&lt;)或大于(&gt;)比较 le 用于2个类对象进行小于等于(&lt;&#x3D;)或大于等于(&gt;&#x3D;)比较 eq 用于2个类对象进行相等(&#x3D;&#x3D;)比较 (5.1)__str__方法当直接打印类对象时，打印的是对象的内存地址，用处不大。 12345678910class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄stu_1 = Student(&quot;李白&quot;, 1000)print(stu_1)# 打印 &lt;__main__.Student object at 0x0000024D8C6195D0&gt; 我们可以通过__str__方法，自定义控制打印类对象时输出的内容。 1234567891011121314class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄 # 自定义打印输出内容 def __str__(self): return f&quot;Student对象,name=&#123;self.name&#125;,age=&#123;self.age&#125;&quot;stu_1 = Student(&quot;李白&quot;, 1000)print(stu_1)# 打印 Student对象,name=李白,age=1000 (5.2)__lt__方法直接对2个对象进行比较是不可以的，会报错。 12345678910class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄stu_1 = Student(&quot;李白&quot;, 1000)stu_2 = Student(&quot;罗辑&quot;, 300)print(stu_1 &gt; stu_2) # 报错 在类中实现__lt__方法即可完成：小于符号 和 大于符号 2种比较 12345678910111213class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄 def __lt__(self, other): return self.age &lt; other.agestu_1 = Student(&quot;李白&quot;, 1000)stu_2 = Student(&quot;罗辑&quot;, 300)print(stu_1 &gt; stu_2) # 打印 True (5.3) __le__方法在类中实现__le__方法即可完成：小于等于符号 和 大于等于符号 2种比较，否则会报错 1234567891011121314class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄 def __le__(self, other): return self.age &lt;= other.agestu_1 = Student(&quot;李白&quot;, 1000)stu_2 = Student(&quot;罗辑&quot;, 1000)print(stu_1 &lt;= stu_2) # Trueprint(stu_1 &gt;= stu_2) # True (5.4) __eq__方法不实现__eq__方法，对象之间可以比较，但是是比较内存地址，但是不同对象&#x3D;&#x3D;比较一定是False结果。 12345678910class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄stu_1 = Student(&quot;李白&quot;, 1000)stu_2 = Student(&quot;李白&quot;, 666)print(stu_1 == stu_2) # False 实现了__eq__方法，就可以按照自己的想法来决定2个对象是否相等了。 12345678910111213class Student: def __init__(self, name, age): self.name = name # 姓名 self.age = age # 年龄 # 自定义比较规则 def __eq__(self, other): return self.name == self.namestu_1 = Student(&quot;李白&quot;, 1000)stu_2 = Student(&quot;李白&quot;, 666)print(stu_1 == stu_2) # True 三.三大特性面向对象包含3大主要特性：封装,继承,多态 (1) 封装将现实世界事物的属性和行为在类中描述为成员变量和成员方法,完成程序对现实世界事物的描述 现实世界中的事物，有属性和行为。但是不代表这些属性和行为都是开放给用户使用的 (1.1) 私有成员在类中提供仅供内部使用的属性和方法，无法被对象调用 基本语法：私有成员变量：变量名以__开头（2个下划线）私有成员方法：方法名以__开头（2个下划线） 1234567891011121314class Student: name = None # 普通成员变量 __age = None # 私有成员变量 # 普通成员方法 def say_hi(self): print(&quot;你好&quot;) # 私有成员方法 def __DNA(self): print(&quot;DNA数量&quot;) 仅在成员内部可以使用 1234567891011121314151617class Student: name = None # 普通成员变量 __age = 16 # 私有成员变量 # 普通成员方法 def show(self): self.__check() # 在类中使用私有成员变量 if self.__age &gt; 18: # 在类中使用私有成员变量 print(&quot;成年人&quot;) else: print(&quot;未成年&quot;) # 私有成员方法 def __check(self): print(&quot;自检&quot;) (2) 继承一个类继承另外一个类的所有成员变量和成员方法(不含私有) (2.1) 单继承基本语法: 12class 类名(父类名): 类内容体 基本使用: 1234567891011121314151617181920212223242526# 待继承的类class Phone: producer = &quot;apple&quot; # 厂商 def call_by_4g(self): print(&quot;4g通话&quot;)# 继承Phoneclass Phone2022(Phone): face_id = True # 面部识别 def call_by_5g(self): print(&quot;2022最新5G通话&quot;)# 创建对象phone = Phone2022()# 使用print(phone.producer) # 可调用 继承自Phone的成员变量print(phone.face_id) # 可调用 自身的成员变量phone.call_by_4g() # 可调用 继承自Phone的成员方法phone.call_by_5g() # 可调用 自身的成员方法 (2.2) 多继承一个类也可以继承多个类多个父类中，如果有同名的成员，默认以继承顺序（从左到右）为优先级。即:后继承的被先继承的覆盖基本语法: 12class 类名(父类1,父类2,...,父类N): 类内容体 使用示例: 123456789101112131415class Phone: producer = &quot;apple&quot; # 厂商class Camera: producer = &quot;suoni&quot; # 厂商class Phone2022(Phone, Camera): face_id = True # 面部识别 def call_by_5g(self): print(&quot;2022最新5G通话&quot;)phone = Phone2022()print(phone.producer) # 打印结果为apple而非suoni (2.3) 复写子类继承父类的成员属性和成员方法后，如果对其“不满意”，那么可以进行复写。即：在子类中重新定义同名的属性或方法。 一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员 1234567891011121314151617class Phone2021: producer = &quot;apple&quot; # 厂商 def call_by_5g(self): print(&quot;2021版5G通话&quot;)class Phone2022(Phone2021): face_id = True # 面部识别 def call_by_5g(self): print(&quot;2022升级版5G通话&quot;)phone = Phone2022()phone.call_by_5g() # 打印 2022升级版5G通话 如果需要使用被复写的父类的成员,只能在子类内通过如下方式调用父类的同名成员: 方式一：使用父类名调用 123使用成员变量：父类名.成员变量使用成员方法：父类名.成员方法(self) 方式二：使用super()调用 12使用成员变量：super().成员变量使用成员方法：super().成员方法() 使用示例： 12345678910111213141516171819class Phone2021: producer = &quot;apple&quot; # 厂商 def call_by_5g(self): print(&quot;2021版5G通话&quot;)class Phone2022(Phone2021): face_id = True # 面部识别 def call_by_5g(self): # 方式一调用 print(Phone2021.producer) # 打印 apple Phone2021.call_by_5g(self)# 打印 2021版5G通话 # 方式二调用 print(super().producer)# 打印 apple super().call_by_5g()# 打印 2021版5G通话 (3) 多态 多种状态，即完成某个行为时，使用不同的对象会得到不同的状态 多态常作用在继承关系上，函数(方法)形参声明接收父类对象，实际传入父类的子类对象进行工作，即 以父类做定义声明 以子类做实际工作 用以获得同一行为, 不同状态 (3.1) 抽象类(接口) 抽象类就好比定义一个标准，包含了一些抽象的方法，要求子类必须实现 抽象类：包含抽象方法的类 抽象方法：没有具体实现的方法（只含pass）称之为抽象方法 pass是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思 多用于做顶层设计（设计标准），以便子类做具体实现。是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法 并配合多态使用，获得不同的工作状态。 18.类型注解一.为什么需要类型注解 在代码中提供数据类型的注解（显式的说明），使用时能获得相关提示 帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示 显示声明时，pycharm确定这个对象是list类型，使用时能有对应提示 没有声明具体类型时，使用不会有任何相关提示 帮助开发者自身对变量进行类型注释（备注），后面调用不易出错 (1) 语法格式 变量名: 数据类型 &#x3D; 数值 Python中类型注解仅仅起到提示作用，没有其他语言那么严格Python解释器不会根据类型注解对数值做验证和判断，无法对应上也不会导致错误 (2) 基础类型整数类型注解 1var_1: int = 1314 浮点数类型注解 1var_2: float = 5.21 布尔类型注解 1var_3: bool = True 字符串类型注解 1var_4: str = &quot;hhybd&quot; (3) 类对象123456# 定义学生类class Student: passstu: Student = Student() # 学生类类型注解 (4) 数据容器列表类型注解 方式一： 1my_list: list = [1, 2, 3] 方式二，list[基础类型]: 1my_list: list[int] = [1, 2, 3] 元组类型注解 方式一： 1my_tuple: tuple = (1, 2, 3) 方式二,元组类型需要将每一个元素都标记出来: 1my_tuple: tuple[str, int, bool] = (&quot;bd&quot;, 521, True) 集合类型注解 方式一: 1my_set: set = &#123;1, 2, 3&#125; 方式二，set[基础类型]： 1my_set: set[int] = &#123;1, 2, 3&#125; 字典类型注解 方式一： 1my_dict: dict = &#123;&quot;hhbdy&quot;: 250&#125; 方式二,dict[键类型,值类型]： 1my_dict: dict[str, int] = &#123;&quot;hhbdy&quot;: 250&#125; 字符串类型注解 1my_str: str = &quot;hhybd&quot; (5) 其他语法格式在注释中进行类型注解语法格式: 1type:类型 使用示例： 1234stu = Student() # type:Studentvar_1 = 123 # type:intmy_list = [1, 2, 3] # type:listmy_set = &#123;1, 2, 3&#125; # type:set[int] 三.函数(方法)的类型注解标注形参和返回值数据类型 类型注解仅仅起到提示作用(1) 形参注解 语法格式： 12def 函数方法名(形参名1:类型，形参名2:类型)：\t函数体 (2) 返回值注解语法格式： 12def 函数方法名(形参名1:类型，形参名2:类型) -&gt; 返回值类型：\t函数体 使用示例： 12def add(x: int, y: int) -&gt; int: return x + y 四.Union类型联合类型注解，在变量注解、函数（方法）形参和返回值注解中均可使用 需要导包使用 当数据类型不唯一时基本格式无法满足要求，此时便可使用Union类型 使用示例，Union[类型,类型]： 在变量中： 123456789from typing import Union# 数据为字符串和整数my_list: list[Union[str, int]] = [2, &quot;hhy&quot;, 5, &quot;bd&quot;, 0]# 键为字符串，值为字符串和整数my_dict: dict[str, Union[str, int]] = &#123;&quot;name&quot;: &quot;hhy&quot;, &quot;QS&quot;: 250&#125; 在函数中： 123456from typing import Union# 接收字符串或整数，返回字符串或整数def func(data: Union[int, str]) -&gt; Union[int, str]: pass 19.高级一.闭包可以保存函数内变量，不会随着函数调用完而销毁 (1) 基本定义在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。 使用示例： 1234567891011121314151617# 1.在函数嵌套(函数中定义函数)的前提下def func_out(num1): def func_inner(num2): # 2.内部函数使用了外部函数的变量 num = num1 + num2 print(f&quot;num的值为：&#123;num&#125;&quot;) # 3.外部函数返回了内部函数 return func_inner# 创建闭包实例f = func_out(10)# 执行闭包f(6) # 打印 num的值为：16 (2) 修改外部函数变量的值在闭包函数（内部函数中）想要修改外部函数的变量值，必须用nonlocal声明这个外部变量 123456789101112131415161718192021# 1.在函数嵌套(函数中定义函数)的前提下def func_out(num1): def func_inner(num2): # 声明外部变量 nonlocal num1 # 2.内部函数使用了外部函数的变量 num1 += num2 print(f&quot;num1的值为：&#123;num1&#125;&quot;) # 3.外部函数返回了内部函数 return func_inner# 创建闭包实例f = func_out(10)# 执行闭包f(8) # 打印 num的值为：18 (3) 小结优点: 无需定义全局变量即可实现通过函数，持续的访问、修改某个值闭包使用的变量于所在的函数内，难以被错误的调用修改，可使变量更安全不易被恶意行为修改缺点: 由于内部函数持续引用外部函数的值，所以会导致这一部分内存空间不被释放，一直占用内存（额外的内存占用）二.装饰器也是一种闭包，可在不破坏目标函数原有的代码和功能的前提下，为目标函数增加新功能 (1) 基本使用装饰器就是把一个函数当做参数传递给闭包中的外部函数，同时在内部函数中使用这个函数，并给他添加新的功能。外部函数只能有一个参数，往往是被装饰的函数内部函数可以根据被装饰的函数提供多个参数以及返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243# 定义一个装饰器def remind(func): # 为目标函数增加新功能 def inner(): print(&quot;我睡觉了&quot;) func() print(&quot;我起床了&quot;) return inner# 需要被装饰的函数def sleep(): import random import time print(&quot;睡眠中...&quot;) time.sleep(random.randint(1, 5)) # 未装饰sleep()# 打印# 睡眠中...# 使用装饰器装饰函数(增加睡前起床提醒)# 返回增强后的inner函数fn = remind(sleep)fn()# 打印# 我睡觉了# 睡眠中...# 我起床了 (2) 语法糖使用可直接在需要被装饰的函数上加@装饰器名字，解释器碰到时会自动执行装饰过程，简化使用流程 123456789101112131415161718192021222324252627282930313233# 定义一个装饰器def remind(func): def inner(): print(&quot;我睡觉了&quot;) func() print(&quot;我起床了&quot;) return inner# 需要被装饰的函数# 解释器遇到@remind 会立即执行 sleep = remind(sleep)@reminddef sleep(): import random import time print(&quot;睡眠中...&quot;) time.sleep(random.randint(1, 5))# 通过语法糖注解，直接调用即可达到效果sleep()# 打印# 我睡觉了# 睡眠中...# 我起床了 (3) 多个装饰器使用将装饰器都写在需要被装饰的函数上面即可谁离被装饰的函数最近，谁就先去装饰函数 12345678910111213141516171819202122232425262728293031323334353637383940414243# 定义装饰器1def remind(func): def inner(): print(&quot;我睡觉了&quot;) func() print(&quot;我起床了&quot;) return inner# 定义装饰器2def study(func): def inner(): func() print(&quot;我要敲代码啦&quot;) return inner# 谁近谁先装饰@study # 2.执行 sleep = study(remind(sleep))@remind # 1.执行 sleep = remind(sleep)def sleep(): import random import time print(&quot;睡眠中...&quot;) time.sleep(random.randint(1, 5))sleep()# 打印# 我睡觉了# 睡眠中...# 我起床了# 我要敲代码啦 (4) 带参数的装饰器需要再增加一层函数嵌套来接收传递的参数 1234567891011121314151617181920212223242526272829303132# 第一层：用于接收装饰器传递的参数def logging(flag): # 第二层：外部函数用于接收待装饰函数 def decorator(fn): # 第三层：内部函数用于装饰接收的函数 def inner(num1, num2): # 使用参数 if flag == &quot;+&quot;: print(&quot;&gt;正在进行加法运算&lt;&quot;) elif flag == &quot;-&quot;: print(&quot;&gt;正在进行减法运算&lt;&quot;) result = fn(num1, num2) return result return inner # 返回装饰器 return decorator# 被带有参数的装饰器装饰的函数@logging(&#x27;+&#x27;)def add(a, b): result = a + b return resultresult = add(1, 3)print(result) (5) 类装饰器(了解即可)一个类里面一旦实现了__call__方法，那么这个类创建的对象就是一个可调用对象，可以像调用函数一样进行调用 12345678910111213# 定义类class Login: def __call__(self, *args, **kwargs): print(&quot;登录中。。。&quot;)# 创建实例login = Login()# 如函数般调用login() # 打印 登录中。。。 类装饰器装饰函数的功能通过call方法实现 123456789101112131415161718192021# 定义类装饰器class Check: # 接收待装饰的函数 def __init__(self, fn): # fn = comment self.__fn = fn def __call__(self, *args: object, **kwargs: object) -&gt; object: print(&quot;登录&quot;) self.__fn() # comment()# 被装饰的函数@Check # comment = Check(comment)def comment(): print(&quot;发表评论&quot;)comment() 三.property属性把类中的一个方法当作属性进行使用，简化开发 例如我们如果想获取和修改私有属性必须通过类方法修改，示例代码： 1234567891011121314151617class Person: def __init__(self): self.__age = 18 def age(self): return self.__age def set_age(self, new_age): self.__age = new_agep = Person()age = p.age()print(f&quot;修改前年龄是：&#123;age&#125;&quot;) # 打印 修改前年龄是：18p.set_age(66)age = p.age()print(f&quot;修改后年龄是：&#123;age&#125;&quot;) # 打印 修改后年龄是：66 通过使用如下两种方式可简化上述代码的使用 (1) 装饰器方式使用@property表示把方法当作属性使用，表示当获取属性时执行下面修饰的方法property修饰的方法名要与属性名一样@方法名.setter表示把方法当作属性使用，表示当设置属性值时会执行下面修饰的方法 1234567891011121314151617181920class Person: def __init__(self): self.__age = 18 @property def age(self): return self.__age @age.setter def age(self, new_age): self.__age = new_agep = Person()# 可直接通过对象.属性使用print(f&quot;修改前年龄是：&#123;p.age&#125;&quot;) # 打印 修改前年龄是：18p.age = 66print(f&quot;修改后年龄是：&#123;p.age&#125;&quot;) # 打印 修改后年龄是：66 (2) 类属性方式使用property的参数说明：属性名 &#x3D; property(获取值方法,设置值方法)第一个参数：获取属性时要执行的方法第二个参数：设置属性时要执行的方法 123456789101112131415161718class Person: def __init__(self): self.__age = 18 def get_age(self): return self.__age def set_age(self, new_age): self.__age = new_age # 类属性方式的property属性 age = property(get_age, set_age)p = Person()print(f&quot;修改前年龄是：&#123;p.age&#125;&quot;) # 打印 修改前年龄是：18p.age = 66print(f&quot;修改后年龄是：&#123;p.age&#125;&quot;) # 打印 修改后年龄是：66 四.上下文管理器由实现了__enter__()和__exit__()方法的类创建的对象 在文件操作篇提到过使用with语句可以自动调用关闭文件操作，即使出现异常也会自动调用关闭文件操作。 12with open(&quot;guanzhi.txt&quot;, &quot;w&quot;) as f: f.write(&quot;hello world&quot;) 使用with语句简化操作是建立在上下文管理器上的，open函数创建的f文件对象就是一个上下文管理器对象 __enter表示上文方法，需要返回一个操作文件对象 __exit__表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法 12345678910111213141516171819202122# 定义一个File类class File: def __init__(self, file_name, file_model): self.file_name = file_name self.file_model = file_model # 实现__enter__()和__exit__()方法 def __enter__(self): print(&quot;这是上文&quot;) self.file = open(self.file_name, self.file_model) return self.file def __exit__(self, exc_type, exc_val, exc_tb): print(&quot;这是下文&quot;) self.file.close()# 使用with语句来完成文件操作with File(&quot;1.txt&quot;, &quot;w&quot;) as f: f.write(&quot;hello world&quot;) 五.深拷贝浅拷贝开辟新的内存空间接收变量 调用id()可获得变量的内存地址(1) 浅拷贝(1.1) 可变类型浅拷贝 使用copy函数进行浅拷贝，只对可变类型的第一层对象进行拷贝对拷贝的对象开辟新的内存空间进行存储不会拷贝对象内部的子对象 12345678910111213141516171819202122232425262728import copya = [1, 2, 3]b = [11, 22, 33]c = [a, b]# 普通赋值，指向同一空间d = cprint(f&quot;c内存地址:&#123;id(c)&#125;&quot;) # 打印 c内存地址:2265505547072print(f&quot;d内存地址:&#123;id(d)&#125;&quot;) # 打印 d内存地址:2265505547072a = [1, 2, 3]b = [11, 22, 33]c = [a, b]# 浅拷贝，指向不同空间d = copy.copy(c)print(f&quot;c内存地址:&#123;id(c)&#125;&quot;) # 打印 c内存地址:2265505547648print(f&quot;d内存地址:&#123;id(d)&#125;&quot;) # 打印 d内存地址:2265505548608# 不会拷贝对象内部的子对象print(id(a)) # 打印 2135734964288print(id(c[0])) # 打印 2135734964288print(id(d[0])) # 打印 2135734964288 (1.2) 不可变类型浅拷贝不可变类型进行浅拷贝不会给拷贝的对象开辟新的内存空间，只是拷贝了这个对象的引用 1234567891011a = (1, 2, 3)b = (11, 22, 33)c = (a, b)# 浅拷贝效果与普通赋值一样d = ce = copy.copy(c)print(f&quot;c内存地址:&#123;id(c)&#125;&quot;) # c内存地址:1536064302016print(f&quot;d内存地址:&#123;id(d)&#125;&quot;) # d内存地址:1536064302016print(f&quot;e内存地址:&#123;id(e)&#125;&quot;) # e内存地址:1536064302016 (2) 深拷贝保障数据的独立性 (2.1) 可变类型深拷贝使用deepcopy函数进行深拷贝，会对可变类型内每一层可变类型对象进行拷贝，开辟新的内存空间进行存储 123456789101112131415import copya = [1, 2, 3]b = [11, 22, 33]c = [a, b]d = copy.deepcopy(c)print(f&quot;c内存地址:&#123;id(c)&#125;&quot;) # 打印 c内存地址:2603978212160print(f&quot;d内存地址:&#123;id(d)&#125;&quot;) # 打印 d内存地址:2603978215488# 内部的可变类型也会拷贝print(id(a)) # 打印 2603978215104print(id(c[0])) # 打印 2603978215104print(id(d[0])) # 打印 2603978212992 (2.2) 不可变类型深拷贝不可变类型进行深拷贝不会给拷贝的对象开辟新的内存空间，只是拷贝了这个对象的引用 1234567a = (1, 2, 3)b = (11, 22, 33)c = (a, b)d = copy.deepcopy(c)print(f&quot;c内存地址:&#123;id(c)&#125;&quot;) # 打印 c内存地址:1312354282432print(f&quot;e内存地址:&#123;id(d)&#125;&quot;) # 打印 e内存地址:1312354282432 六.eval函数eval()函数可将字符串当成有效的表达式来求值并返回计算结果 12345678910111213141516171819202122232425# 基本的数学运算res = eval(&quot;(1+9)*5&quot;)print(res) # 打印 50# 字符串重复res = eval(&quot;&#x27;*&#x27;*10&quot;)print(res) # 打印 **********# 字符串转换成列表print(type(eval(&quot;[1,2,3,4]&quot;)))# 打印 &lt;class &#x27;list&#x27;&gt;# 字符串转成字典 print(type(eval(&quot;&#123;&#x27;name&#x27;:&#x27;guanzhi&#x27;,&#x27;age&#x27;:20&#125;&quot;)))# 打印 &lt;class &#x27;dict&#x27;&gt; 注意事项：开发时千万不要使用eval直接转换input的结果 用户可能恶意输入有危害的终端指令 12345678input_str = input() # 输入 __import__(&#x27;os&#x27;).system(&#x27;rm -rf /*&#x27;)eval(input_str) # 直接运行可能导致主机崩溃# 等价于import osos.system(&quot;终端命令&quot;) ​\t​\t​\t​\t​","tags":["python"],"categories":["python"]},{"title":"elecron","path":"/2024/05/16/elecron/","content":"Electron1.介绍：使用 JavaScript、HTML 和 CSS 构建跨平台桌面应用 2.安装要使用electron，必须安装node.js默认最新版就好 3.创建项目首先利用npm创建一个工程 12mkdir my-electron-app &amp;&amp; cd my-electron-appnpm init 填入信息中，大部分保持默认即可，但以下几项需要修改 entry point应该是main.js author需要填写 现在你的package.json文件内容应该如下 12345678&#123; &quot;name&quot;: &quot;my-electron-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Hello World!&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;author&quot;: &quot;Jane Doe&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 然后，将 electron 包安装到应用的 devDependencies 中。 1npm install --save-dev electron ！！！注意，这个过程大概率会报错 报错信息 1RequestError: connect ECONNREFUSED 127.0.0.1:443 由于默认会从github下载文件，如果你的电脑上不了github会报这个错误 1electon unable to verify the first certificate 由于协议问题，导致下载失败 解决办法在当前项目目录下面新建文件.npmrc 在里面填写以下信息 1ELECTRON_MIRROR=&quot;https://npmmirror.com/mirrors/electron/&quot; 便可以完美解决 4.第一个程序参考官方文档，便可以获得第一个程序开发文档","tags":["桌面程序"],"categories":["桌面程序"]},{"title":"express","path":"/2024/04/14/express/","content":"expressexpress生成器的安装，访问express的中文网，其中有介绍express的安装和入门，现在来安装他吧 对于express而言，其是由nodejs封装api而成，所以需要先装上nodejs，此步省略，打开终端。最好是以管理员身份运行，到达nodejs的安装根目录，对express的安装器进行安装。在cmd窗口输入如下指令 1npm install -g express-generator 再输入 1express 根据提示进行安装，进入项目，安装相关依赖 1npm i 即可生成一个express应用，进入项目可以看到项目的基本结构，找到package.json找到运行脚本 1npm run start 然后就可以在本地3000端口访问express服务了 1.更改端口在app.js中，可以修改端口，只需要在导出前加上代码即可 1process.env.PORT = 80; app.js所有代码 12345678910111213141516171819202122232425262728293031323334353637383940414243var createError = require(&#x27;http-errors&#x27;);var express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);var indexRouter = require(&#x27;./routes/index&#x27;);var usersRouter = require(&#x27;./routes/users&#x27;);var app = express();// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;jade&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.use(&#x27;/&#x27;, indexRouter);app.use(&#x27;/users&#x27;, usersRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);process.env.PORT = 80;module.exports = app; 2.检测代码更改自动重新启动项目安装nodemon 1npm i nodemon 找到启动脚本，在启动脚本前加nodemon --exec 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;nodemon --exec node ./bin/www&quot;&#125;,","tags":["后端"],"categories":["后端"]},{"title":"docker","path":"/2024/04/14/docker/","content":"Docker1.初识Docker基本操作1.拉取镜像1.1去 DockerHub查询镜像1.2通过命令拉取镜像1docker pull nginx 1.3通过命令查看拉取到的镜像1docker images 1.4保存，导入镜像1.4.1保存1docker save -o [保存的目标文件名称] [镜像名称] 1docker save -o nginx.tar nginx:latest 1.4.2删除1docker rmi nginx:latest 1.4.3加载1docker load -i nginx.tar 2.容器操作容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 2.1创建并且运行一个容器创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx，可以加版本，不加默认为最新版 自启动将正在运行的容器设为自启动 1docker update --restart=always 容器名或容器ID 1docker update --restart=always &lt;CONTAINER ID&gt; 例如将tomcat设为自启动1 1docker update --restart=always tomcat 将自启动的容器取消自启动 1docker update --restart=no 容器名或容器ID 1docker update --restart=no &lt;CONTAINER ID&gt; 例如取消tomcat的自启动 1docker update --restart=no tomcat 2.2进入容器，修改文件进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 3数据卷数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 例 创建容器并挂载数据卷到容器内的HTML目录 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 直接挂载到宿主机容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像： 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 2.Docker的安装1.CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。 1.1.卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： 1234567891011yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.2.安装docker首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fast 然后输入命令： 1yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 1.3.启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 12345systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： 1docker -v 如图： 1.4.配置镜像加速docker官方镜像仓库网速较差，我们需要设置国内镜像服务： 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： 12# 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： 12# 修改权限chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：12# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： 1echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： 123456docker run -d \\ --restart=always \\ --name registry\t\\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： 123456789101112131415version: &#x27;3.0&#x27;services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： 12345678# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker 3.Docker的操作3.1.镜像操作3.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 如图： 这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。 3.1.2.镜像命令常见的镜像操作命令如图： 3.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 3.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： 1docker save --help 结果： 命令格式： 1docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： 1docker save -o nginx.tar nginx:latest 结果如图： 3）使用docker load加载镜像 先删除本地的nginx镜像： 1docker rmi nginx:latest 然后运行命令，加载本地文件： 1docker load -i nginx.tar 结果： 3.2.容器操作3.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 3.2.2.案例-创建并运行一个容器创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 3.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： 1cd /usr/share/nginx/html 查看目录下文件： 3）修改index.html的内容 容器内没有vi命令，无法直接修改，我们用下面的命令来修改： 1sed -i -e &#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27; -e &#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27; index.html 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： 3.3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 3.3.1.什么是数据卷数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了 3.3.2.数据集操作命令数据卷操作的基本语法如下： 1docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 3.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 1docker volume create html ② 查看所有数据 1docker volume ls 结果： ③ 查看数据卷详细信息卷 1docker volume inspect html 结果： 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 3.3.4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： 12345docker run \\ --name mn \\ -v html:/root/html \\ -p 8080:80 nginx \\ 这里的-v就是挂载数据卷的命令： -v html:/root/htm ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中 3.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 3.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data 3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf 4）去DockerHub查阅资料，创建并运行MySQL容器，要求： ① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录 ② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件 ③ 设置MySQL密码 4.Dockerfile自定义镜像常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。 而要自定义镜像，就必须先了解镜像的结构才行。 4.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 4.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder 4.3.构建Java项目4.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 其中的内容如下： 12345678910111213141516171819202122# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR=/usr/local# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar /tmp/app.jar 步骤5：进入docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： 1docker build -t javaweb:1.0 . 最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip 4.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将app.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： 1234FROM java:8-alpineCOPY ./app.jar /tmp/app.jarEXPOSE 8090ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 ⑤ 使用docker run创建容器并运行 5.Docker-ComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ 5.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： 1234567891011121314version: &quot;3.8&quot; services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;/tmp/mysql/data:/var/lib/mysql&quot; - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot; web: build: . ports: - &quot;8090:8090&quot; 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 5.2.安装DockerCompose参考课前资料 5.3.部署微服务集群需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署 实现思路： ① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件 ② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名 ③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar ④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中 ⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署 5.3.1.compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录： 内容如下： 123456789101112131415161718192021222324version: &quot;3.2&quot;services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - &quot;8848:8848&quot; mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;$PWD/mysql/data:/var/lib/mysql&quot; - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot; userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - &quot;10010:10010&quot; 可以看到，其中包含5个service服务： nacos：作为注册中心和配置中心 image: nacos/nacos-server： 基于nacos&#x2F;nacos-server镜像构建 environment：环境变量 MODE: standalone：单点模式启动 ports：端口映射，这里暴露了8848端口 mysql：数据库 image: mysql:5.7.25：镜像版本是mysql:5.7.25 environment：环境变量 MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123 volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据 userservice、orderservice、gateway：都是基于Dockerfile临时构建的 查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表： 查看微服务目录，可以看到都包含Dockerfile文件： 内容如下： 123FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar 5.3.2.修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。 如下所示： 1234567891011spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 5.3.3.打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。 可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改： 12345678910&lt;build&gt; &lt;!-- 服务打包的最终名称 --&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打包后： 5.3.4.拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。 user-service： order-service： gateway： 5.3.5.部署最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。 上传到任意目录： 部署： 进入cloud-demo目录，然后运行下面的命令： 1docker-compose up -d 6.Docker镜像仓库6.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 6.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F; 1docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 ② 推送镜像 1docker push 192.168.150.101:8080/nginx:1.0 ③ 拉取镜像 1docker pull 192.168.150.101:8080/nginx:1.0","tags":["后端"],"categories":["后端"]},{"title":"微服务","path":"/2024/04/14/微服务/","content":"","tags":["后端"],"categories":["后端"]},{"title":"前端问题合集","path":"/2024/03/31/前端问题合集/","content":"1.nginx跨域123456789101112131415161718192021server &#123; listen 90; server_name localhost; location / &#123; root html; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; #解决跨域问题，核心代码 location ^~ /api/ &#123; rewrite ^/api/(.*)$ /$1 break; proxy_pass http://localhost:8080; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 2.在vue3项目中控制element-ui左侧菜单的展开和收起12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div :v-model=&#x27;isCollapse&#x27;&gt; &lt;el-icon v-if=&quot;isCollapse&quot; @click=&quot;change&quot;&gt;&lt;DArrowRight /&gt;&lt;/el-icon&gt; &lt;el-icon v-else @click=&quot;change&quot;&gt;&lt;DArrowLeft /&gt;&lt;/el-icon&gt; &lt;/div&gt; &lt;el-menu default-active=&quot;2&quot; class=&quot;el-menu-vertical-demo&quot; :collapse=&quot;isCollapse&quot; &gt; &lt;el-sub-menu index=&quot;1&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;Location /&gt;&lt;/el-icon&gt; &lt;span&gt;Navigator One&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template #title&gt;&lt;span&gt;Group One&lt;/span&gt;&lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;item one&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;item two&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title=&quot;Group Two&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;item three&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-sub-menu index=&quot;1-4&quot;&gt; &lt;template #title&gt;&lt;span&gt;item four&lt;/span&gt;&lt;/template&gt; &lt;el-menu-item index=&quot;1-4-1&quot;&gt;item one&lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;/el-sub-menu&gt; &lt;el-menu-item index=&quot;2&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &lt;template #title&gt;Navigator Two&lt;/template&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt; &lt;el-icon&gt;&lt;Document /&gt;&lt;/el-icon&gt; &lt;template #title&gt;Navigator Three&lt;/template&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;el-icon&gt;&lt;setting /&gt;&lt;/el-icon&gt; &lt;template #title&gt;Navigator Four&lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt;&lt;/template&gt; &lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; DArrowLeft, DArrowRight, Document, Menu as IconMenu, Location, Setting,&#125; from &#x27;@element-plus/icons-vue&#x27; const isCollapse = ref(false)const change=()=&gt;&#123; isCollapse.value=!isCollapse.value&#125;&lt;/script&gt; &lt;style&gt;.el-menu-vertical-demo:not(.el-menu--collapse) &#123; width: 200px; min-height: 400px;&#125;&lt;/style&gt; 3.在vue3中使用elementui中的cell-style控制表格中某行或者某单元格样式12345678910111213141516&lt;el-table :cell-style=&quot;tableRowStyle&quot; :data=&quot;tableData&quot; table-layout:auto style=&quot;width: 100%;margin-top: 2vh&quot; height=&quot;54vh&quot; scrollbar-always-on border &gt; &lt;!-- 当type的值是index的时候表示序号 --&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot; prop=&quot;index&quot; width=&quot;60&quot;/&gt; &lt;el-table-column label=&quot;报修时间&quot; prop=&quot;startDate&quot; sortable/&gt;&lt;!--sortable进行顺序排序 --&gt; &lt;el-table-column label=&quot;报修位置&quot; prop=&quot;location&quot;/&gt; &lt;el-table-column label=&quot;报修内容&quot; prop=&quot;context&quot;/&gt; &lt;el-table-column label=&quot;报修人 &quot; prop=&quot;repairPerson&quot;/&gt; &lt;el-table-column label=&quot;区域&quot; prop=&quot;repairArea&quot;/&gt; &lt;el-table-column label=&quot;受理状态&quot; prop=&quot;flowerState&quot;/&gt; &lt;el-table-column label=&quot;修复状态&quot; prop=&quot;repairState&quot;/&gt; &lt;el-table-column label=&quot;修复时间&quot; prop=&quot;repairTime&quot;/&gt; &lt;el-table-column label=&quot;修复人&quot; prop=&quot;repairHandelPerson&quot;/&gt; &lt;/el-table&gt; 1234567const tableRowStyle = (data) =&gt; &#123; if (data.row.repairState == &quot;正在修复&quot;&amp;&amp;data.column.property==&quot;repairState&quot;) &#123; return &#123; color:&#x27;red&#x27; &#125;; &#125;&#125; 4.让div盒子铺满全屏在操作过程中我们发现，在全屏中使用div盒子的时候，在div盒子的左边和上面有一个8px的空隙，需要将其重置为0 1234*&#123;/* CSS Reset,解决存在的间距问题 */\tmargin : 0;\tpadding : 0;&#125; 5.渐变色12/* 渐变色 */ background: linear-gradient(to bottom right, rgb(255, 2, 124), rgb(0, 255, 200)) no-repeat; 渐变色6.鼠标反应12345678910/* 聚焦时变化 */.button:hover &#123; background-color: rgba(123, 250, 252, 0.4);&#125;/* active点击后改变 *//* :focus 元素被点击后变色，且颜色在点击后不消失 */.button:active &#123; background-color: rgba(193, 192, 192, 0.4);&#125; 7.设置element-ui的某些样式打开开发者模式，找到对应的class名称，进行设置 123456.el-input .el-input__wrapper &#123; margin: 0 auto; border-radius: 40px 40px 40px 40px; background-color: rgb(255, 255, 255, 0.4);&#125; 8.密码框显示小眼睛1234&lt;!-- show-password在密码旁边显示小眼睛 --&gt; &lt;el-form-item&gt; &lt;el-input placeholder=&quot;请输入密码&quot; type=&quot;password&quot; v-model=&quot;formLabelAlign.region&quot; show-password /&gt; &lt;/el-form-item&gt; 9.设置圆角1border-radius: 40px 40px 40px 40px; 10自动换行123display: flex; flex-wrap: wrap; justify-content: start; 11.计算时间1234567891011//sDate1和sDate2是2002-12-18格式 var now = new Date();var sDate2 = &quot;2024-04-18&quot;;var nowData = now.getFullYear() + &quot;-&quot; + (now.getMonth() + 1) + &quot;-&quot; + now.getDate();var aDate, oDate2, iDaysaDate = nowData.split(&quot;-&quot;)nowData = new Date(aDate[1] + &#x27;-&#x27; + aDate[2] + &#x27;-&#x27; + aDate[0]) //转换为12-18-2002格式 aDate = sDate2.split(&quot;-&quot;)oDate2 = new Date(aDate[1] + &#x27;-&#x27; + aDate[2] + &#x27;-&#x27; + aDate[0])iDays = parseInt(Math.abs(nowData - oDate2) / 1000 / 60 / 60 / 24) //把相差的毫秒数转换为天数 12.分隔线1&lt;hr class=&quot;hr-double-arrow&quot;&gt; 123456789101112131415161718192021222324252627282930313233.hr-double-arrow &#123; color: #7171d5; border: double; border-width: 3px 5px; border-color: #5b336b transparent; height: 1px; overflow: visible; margin-left: 20px; margin-right: 20px; position: relative; &#125; .hr-double-arrow:before, .hr-double-arrow:after &#123; content: &#x27;&#x27;; position: absolute; width: 5px; height: 5px; border-width: 0 3px 3px 0; border-style: double; top: -3px; background: radial-gradient(2px at 1px 1px, currentColor 2px, transparent 0) no-repeat; &#125; .hr-double-arrow:before &#123; transform: rotate(-45deg); left: -20px; &#125; .hr-double-arrow:after &#123; transform: rotate(135deg); right: -20px; &#125; 13.md文件渲染1npm i html-loader markdown-loader --save 14安装出现报错1this[kHandle] = new _Hash(algorithm, xofLen); 出现原因：由于更新，导致node版本不匹配，要将该项目的启动选项进行修改 解决办法 1$env:NODE_OPTIONS=&quot;--openssl-legacy-provider&quot; 15.路由缓存问题路由缓存问题解决 缓存问题：当路由path一样，参数不同的时候会选择直接复用路由对应的组件解决方案： 给 routerv-view 添加key属性，破坏缓存 1:key=&quot;$route.fullPath&quot; 使用 onBeforeRouteUpdate钩子函数，做精确更新 12345678910import &#123; onBeforeRouteUpdate &#125; from &#x27;vue-router&#x27; // 目标:路由参数变化的时候 可以把分类数据接口重新发送//to中为将要跳转时的最新路由 onBeforeRouteUpdate((to) =&gt; &#123; // 存在问题：使用最新的路由参数请求最新的分类数据 //通过最新的路由去请求数据 getCategory(to.params.id) &#125;) 16.当切换路由时，在不同页面的滚动深度可能受到影响，需要在重新定义他的滚动高度11234567891011//创建路由器const router = createRouter(&#123; history: createWebHistory(), routes: routes, //滚动条返回顶部 scrollBehavior () &#123; return &#123; top :0, &#125; &#125;&#125;);","tags":["前端"],"categories":["前端"]},{"title":"前端工具类","path":"/2024/03/31/前端工具类/","content":"1.在vue3项目中使用quill-editor在控制台安装quill 1npm install @vueup/vue-quill@latest --save 在项目中进行导入，这里演示局部导入，也可以进行全局导入 12import &#123; QuillEditor &#125; from &#x27;@vueup/vue-quill&#x27;import &#x27;@vueup/vue-quill/dist/vue-quill.snow.css&#x27; 使用数据 123456&lt;quill-editor theme=&quot;snow&quot; v-model:content=&quot;articleModel.content&quot; contentType=&quot;html&quot; &gt;&lt;/quill-editor&gt; 2.在vue3项目中使用Echarts通过npm安装 1npm install echarts --save 引入 1import * as echarts from &#x27;echarts&#x27;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import &#123;ref, onMounted&#125; from &quot;vue&quot;; const sum = ref(&#123; buildingNumber: &#x27;100&#x27;, residentsNumber: &#x27;888&#x27;, intelligentDevices: &#x27;300&#x27;, alarmNumber: &#x27;20&#x27;&#125;)//房屋数量情况const buildingData = ref([ &#123;value: 335, name: &#x27;毛坯房&#x27;&#125;, &#123;value: 310, name: &#x27;精装修&#x27;&#125;, &#123;value: 234, name: &#x27;简装修&#x27;&#125;, &#123;value: 135, name: &#x27;未卖出&#x27;&#125;,])//报修统计const repairData = ref([ &#123;value: 335, name: &#x27;正在处理&#x27;&#125;, &#123;value: 310, name: &#x27;已修复&#x27;&#125;, &#123;value: 234, name: &#x27;未修复&#x27;&#125;,])const paymentData = ref( &#123; hasPay:[50, 80, 90, 400], noPay:[10,20,30,50] &#125;) //导入图表import * as echarts from &#x27;echarts&#x27;//钩子方法onMounted(() =&gt; &#123; renderChart()&#125;)//表名const building = ref()const repairing = ref()const paying = ref() const renderChart = () =&gt; &#123; let buildingChart = echarts.init(building.value) let repairChart = echarts.init(repairing.value) let payChart = echarts.init(paying.value) //图表自适应 window.addEventListener(&quot;resize&quot;, () =&gt; &#123; buildingChart.resize(); &#125;); window.addEventListener(&quot;resize&quot;, () =&gt; &#123; repairChart.resize(); &#125;); window.addEventListener(&quot;resize&quot;, () =&gt; &#123; payChart.resize(); &#125;); buildingChart.setOption(&#123; title: &#123; text: &#x27;房屋分布&#x27;, left: &#x27;left&#x27; &#125; , /*提示的样式*/ tooltip: &#123; trigger: &#x27;item&#x27;, /* formatter: &#x27;&#123;a&#125; &lt;br/&gt; &#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;*/ &#125; , legend: &#123; orient: &#x27;horizontal&#x27;, bottom: &#x27;10px&#x27;, data: [&#x27;毛坯房&#x27;, &#x27;精装修&#x27;, &#x27;简装修&#x27;, &#x27;未卖出&#x27;] &#125; , label: &#123; show: true, formatter: &#x27;&#123;b&#125;:&#123;c&#125;&#x27; &#125;, series: [ &#123; name: &#x27;装修情况&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, center: [&#x27;50%&#x27;, &#x27;50%&#x27;], data: buildingData.value, emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 5, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125; ) repairChart.setOption(&#123; title: &#123; text: &#x27;报修情况&#x27;, left: &#x27;left&#x27; &#125; , tooltip: &#123; trigger: &#x27;item&#x27;, /*formatter: &#x27;&#123;a&#125; &lt;br/&gt; &#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;*/ &#125;, label: &#123; show: true, formatter:&#x27;&#123;b&#125;: &#123;c&#125;&#x27; &#125;, legend: &#123; orient: &#x27;horizontal&#x27;, bottom: &#x27;10px&#x27;, data: [&#x27;正在处理&#x27;, &#x27;已修复&#x27;, &#x27;未修复&#x27;] &#125; , series: [ &#123; name: &#x27;报修情况&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, center: [&#x27;50%&#x27;, &#x27;50%&#x27;], data: repairData.value, emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 5, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125; ) payChart.setOption(&#123; title: &#123; text: &#x27;缴费情况&#x27;, left: &#x27;left&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, legend: &#123; orient: &#x27;horizontal&#x27;, bottom: &#x27;10px&#x27;, data: [&#x27;已缴&#x27;,&#x27;未缴&#x27;] &#125;, label: &#123; show: true, position: &#x27;top&#x27; &#125;, xAxis: &#123; data: [&#x27;水费&#x27;, &#x27;电费&#x27;, &#x27;停车费&#x27;, &#x27;物业费&#x27;] &#125;, yAxis: &#123;&#125;, series: [ &#123; name: &#x27;已缴&#x27;, type: &#x27;bar&#x27;, data: paymentData.value.hasPay &#125;,&#123; name: &#x27;未缴&#x27;, type: &#x27;bar&#x27;, data: paymentData.value.noPay &#125; ] &#125;) &#125; 1234567891011121314&lt;div style=&quot;display: flex;flex-direction: row;justify-content: space-between;margin-top: 4vh&quot;&gt; &lt;div style=&quot;height:50vh;width:50vh ;margin-top: 20px;border-style: solid;border-color: #f5f1f1;&quot;&gt; &lt;div ref=&quot;building&quot; :style=&quot;&#123; float:&#x27;bottom&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height:50vh;width:50vh ;margin-top: 20px;border-style: solid;border-color: #f5f1f1;&quot;&gt; &lt;div ref=&quot;paying&quot; :style=&quot;&#123; float:&#x27;bottom&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height:50vh;width:50vh ;margin-top: 20px;border-style: solid;border-color: #f5f1f1;&quot;&gt; &lt;div ref=&quot;repairing&quot; :style=&quot;&#123; float:&#x27;bottom&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 3.vue项目的config配置文件1234567891011121314151617181920212223242526272829303132const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, //配置文件的查找目录 publicPath:&quot;/&quot;, devServer: &#123; //编译完成后打开 open:true, //配置运行端口 port: 8888, //允许所有请求进入 allowedHosts: &#x27;all&#x27;, //关闭浏览器网页的全屏报错 client: &#123; overlay: false, &#125;, //解决跨域问题 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;,//这里填入你要请求的接口的前缀 ws:true,//代理websocked changeOrigin:true,//虚拟的站点需要更管origin secure: true, //是否https接口 pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27;//重写路径 &#125; &#125; &#125;&#125; &#125;) 4.拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//定制请求的实例//导入token状态import &#123; useTokenStore &#125; from &#x27;@/stores/token.js&#x27;;//添加请求拦截器//导入axios npm install axiosimport axios from &#x27;axios&#x27;;import router from &#x27;@/router&#x27;;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;;//定义一个变量,记录公共的前缀,baseURLconst baseURL = &#x27;/api&#x27;;const instance = axios.create(&#123;baseURL&#125;)//添加请求拦截器instance.interceptors.request.use( (config)=&gt;&#123; //在发送请求之前做什么 let tokenStore = useTokenStore() //如果token中有值，在携带 if(tokenStore.token)&#123; config.headers.Authorization=tokenStore.token &#125; return config &#125;, (err)=&gt;&#123; //如果请求错误做什么 Promise.reject(err) &#125;)//添加响应拦截器instance.interceptors.response.use( result=&gt;&#123; if(result.data.code==0)&#123; return result.data &#125;else&#123; ElMessage.error(result.data.message?result.data.message:&#x27;服务异常&#x27;) &#125; &#125;, err=&gt;&#123; if(err.response.status===401)&#123; ElMessage.error(&#x27;请先登录！&#x27;) router.push(&#x27;/login&#x27;) &#125;else&#123; ElMessage.error(&#x27;服务异常&#x27;); &#125; return Promise.reject(err);//异步的状态转化成失败的状态 &#125;)export default instance; 5.存储token12345678910111213141516171819202122232425262728import &#123;defineStore&#125; from &#x27;pinia&#x27;import &#123;ref&#125; from &#x27;vue&#x27;export const useTokenStore = defineStore(&#x27;token&#x27;,()=&gt;&#123; //1.定义描述token const token =ref(&#x27;&#x27;) //2.定义修改token的方法 const setToken = (newToken)=&gt;&#123; token.value = newToken &#125; //3.定义移除token的方法 const removeToken = ()=&gt;&#123; token.value=&#x27;&#x27; &#125; return &#123; token,setToken,removeToken &#125;&#125;,//参数持久化&#123; persist:true&#125;) 6.安装element-ui1npm install element-plus --save 12import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27; 1app.use(ElementPlus) 7.检测屏幕滚动1234567891011121314151617181920212223242526import &#123; ref, onMounted, watch &#125; from &quot;vue&quot;;//点击箭头，滑动页面const scrollTop = ref(&#x27;&#x27;)const topsrcoll = ref(false)//上移样式成立onMounted(() =&gt; &#123; window.addEventListener(&#x27;scroll&#x27;, handleScroll)&#125;)//监听页面滚动const handleScroll = () =&gt; &#123; scrollTop.value = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop&#125;// 监听top值的变化watch(scrollTop, (newValue, oldValue) =&gt; &#123; // 等新值大于100的时候再做变化（优化一下） console.log(newValue, oldValue) // 等新值大于100的时候再做变化（优化一下） if (newValue &gt; 100) &#123; if (newValue &gt; oldValue) &#123; console.log(&#x27;向下滚动&#x27;) topsrcoll.value = true &#125; else &#123; console.log(&#x27;向上滚动&#x27;) topsrcoll.value = false &#125; &#125;&#125;) 123&lt;h1 v-if=topsrcoll&gt;dfgiusgdefisde&lt;/h1&gt; 8.在项目中使用scss安装sass1npm i sass 安装loader1npm i sass-loader 使用1&lt;style lang=&quot;scss&quot; scoped&gt; 9.安装路由1npm install vue-router@4 1.创建路由器，并导出在src&#x2F;router目录下，定义一个js文件，起名为index.js。这样名字的js文件在导入时，可以不写文件名，只要定位到文件所在的文件夹即可，使用起来很方便 1234567891011121314151617181920//导入vue-router//createWebHistory一般使用history不适用hashhistoryimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;//导入组件import LoginVue from &#x27;@/views/Login.vue&#x27;import LayoutVue from &#x27;@/views/Layout.vue&#x27;//定义路由关系const routes = [ &#123; path: &#x27;/login&#x27;, component: LoginVue &#125;, &#123; path: &#x27;/&#x27;, component: LayoutVue &#125;]//创建路由器const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;);export default router 2.在vue应用实例中使用router在main.js中导入创建应用实力的js文件，并调用实例的use方法使用路由器 123import router from &#x27;@/router&#x27;app.use(router) 3.定义展示路由组件的地方在App.vue文件的template标签中，定义router-view标签 123&lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt; 将来不管根据路由匹配到的组件内容，会在router-view标签内进行展示 4.路由API在登录成功后，需要通过代码的方式将页面切换到首页，此时就需要调用路由器相关的API 获取路由器 12import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter(); 调用API 1router.push(&#x27;/&#x27;) 5.子路由在咱们的主页面中，当用户点击左侧的菜单时，右侧主区域的内容需要发生变化，将来每切换一个菜单，右侧需要加载对应组件的内容进行展示，像这样的场景咱们也需要使用路由来完成 由于这些组件都需要在Layout.vue中展示， 而Layout.vue本身已经参与了路由，因此我们需要在Layout.vue中通过子路由的方式来完成组件的切换 5.1提供菜单对应的组件可以复制资料中的文件，也可以自己创建： ArticleCategory.vue ArticleManage.vue UserInfo.vue UserAvatar.vue UserResetPassword.vue 5.2配置子路由在src&#x2F;router&#x2F;index.js中配置子路由 123456789101112131415161718//定义路由关系const routes = [ &#123; path: &#x27;/login&#x27;, component: LoginVue &#125;, &#123; path: &#x27;/&#x27;, component: LayoutVue, //重定向，默认访问此界面 redirect: &#x27;/article/manage&#x27;, //子路由 children: [ &#123; path: &#x27;/article/category&#x27;, component: ArticleCategoryVue &#125;, &#123; path: &#x27;/article/manage&#x27;, component: ArticleManageVue &#125;, &#123; path: &#x27;/user/info&#x27;, component: UserInfoVue &#125;, &#123; path: &#x27;/user/avatar&#x27;, component: UserAvatarVUe &#125;, &#123; path: &#x27;/user/password&#x27;, component: UserResetPasswordVue &#125;, ] &#125;] 5.3 在Layout.vue组件的右侧中间区域，添加router-view标签123456&lt;!-- 中间区域 --&gt;&lt;el-main&gt; &lt;div style=&quot;width: 1290px; height: 570px;border: 1px solid red;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/el-main&gt; 5.4 菜单项设置点击后跳转的路由路径el-menu-item 标签的index属性可以设置点击后的路由路径 123456&lt;el-menu-item index=&quot;/article/category&quot;&gt; &lt;el-icon&gt; &lt;Management /&gt; &lt;/el-icon&gt; &lt;span&gt;文章分类&lt;/span&gt;&lt;/el-menu-item&gt; 10.设置滚动条1234567891011121314151617181920212223242526.box &#123; height: 100px; overflow: auto; border: 1px solid red;&#125;// 滚动条.box::-webkit-scrollbar &#123; /*滚动条整体样式*/ width: 10px; /*高宽分别对应横竖滚动条的尺寸*/ height: 1px;&#125;.box::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ border-radius: 10px; height: 20px; -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); // background: #E5E5E5; background: red;&#125;.box::-webkit-scrollbar-track &#123; /*滚动条里面轨道*/ -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); border-radius: 10px; background: #ffffff;&#125; 11导航栏吸顶效应1.安装vueuse1npm i @vueuse/core 使用vueuse 监听y轴的变化 1import &#123; useScroll &#125; from &#x27;@vueuse/core&#x27; 1const &#123; y &#125; = useScroll(window) 使用时监听y，当前项目中，当y大于78px时，自动展示 12345&lt;div class=&quot;app-header-sticky&quot; :class=&quot;&#123; show: y &gt; 78 &#125;&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819202122.app-header-sticky &#123; width: 100%; height: 80px; position: fixed; left: 0; top: 0; z-index: 999; background-color: #fff; border-bottom: 1px solid #e4e4e4; // 此处为关键样式!!! // 状态一：往上平移自身高度 + 完全透明 transform: translateY(-100%); opacity: 0; // 状态二：移除平移 + 完全不透明 &amp;.show &#123; transition: all 0.3s linear; transform: none; opacity: 1; &#125;&#125; 12.prop的使用手册 在vue3语法糖的使用中，定义数据 1234567891011// 定义propsdefineProps(&#123; // 主标题 title: &#123; type: String &#125;, // 副标题 subTitle: &#123; type: String &#125;&#125;) 或 1234defineProps(&#123; title: String, subTitle:string,&#125;) 在父组件中定义数据 1&lt;HomePanel title=&quot;新鲜好物&quot; sub-title=&quot;新鲜出炉 品质靠谱&quot;&gt; 或 定义一个object类型的数据 123456defineProps(&#123; goods: &#123; type: Object, default: () =&gt; &#123; &#125; &#125;&#125;) 绑定数据 1&lt;GoodsItem v-for=&quot;goods in goodList&quot; :goods=&quot;goods&quot; :key=&quot;goods.id&quot; /&gt; 13.懒加载在vueuse组件中提供了懒加载指令 可以在main.js中直接使用，但是一般在main.js中不写逻辑语句，因此将其封装在插件文件夹中，将这个插件在main.js中导入，并且注册为全局组件，可读性较高， 12345678910111213141516171819202122232425262728// 定义懒加载插件import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;export const lazyPlugin = &#123; install (app) &#123; // 懒加载指令逻辑 app.directive(&#x27;img-lazy&#x27;, &#123; mounted (el, binding) &#123; // el: 指令绑定的那个元素 img // binding: binding.value 指令等于号后面绑定的表达式的值 图片url console.log(el, binding.value) //从中获得stop指令 const &#123; stop &#125; = useIntersectionObserver( el, ([&#123; isIntersecting &#125;]) =&gt; &#123; console.log(isIntersecting) if (isIntersecting) &#123; // 进入视口区域 el.src = binding.value //当加载完成后，停止监听，减少内存消耗 stop() &#125; &#125;, ) &#125; &#125;) &#125;&#125; 在main.js中注册 123// 引入懒加载指令插件并且注册import &#123; lazyPlugin &#125; from &#x27;@/directives&#x27;app.use(lazyPlugin) 1&lt;img v-img-lazy=&quot;cate.picture&quot; /&gt; 14.路由激活时一直显示样式1&lt;router-link to=&quot;/home&quot; class=&quot;menu-home&quot; active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt; 1234.active &#123; color: $xtxColor; border-bottom: 1px solid $xtxColor; &#125; 15无限滚动123&lt;ul v-infinite-scroll=&quot;load&quot; class=&quot;infinite-list&quot; style=&quot;overflow: auto&quot; :infinite-scroll-disabled=&quot;disabled&quot;&gt; &lt;/ul&gt; 12345678910111213// 加载更多const disabled = ref(false)const load = async () =&gt; &#123; console.log(&#x27;加载更多数据咯&#x27;) // 获取下一页的数据 reqData.value.page++ const res = await getSubCategoryAPI(reqData.value) goodList.value = [...goodList.value, ...res.result.items] // 加载完毕 停止监听 if (res.result.items.length === 0) &#123; disabled.value = true &#125;&#125; 16在切换路由的时候添加动画1234567891011&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;keep-alive&gt; &lt;component :is=&quot;Component&quot; /&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;/router-view&gt; 且在根项目的时候加入div标签进行包裹 123456789.fade-enter-active,.fade-leave-active &#123; transition: opacity 0.3s ease;&#125;.fade-enter-from,.fade-leave-to &#123; opacity: 0;&#125; 17.在浏览器中使用webscoket123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;WebSocket Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt; &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt; &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭连接&lt;/button&gt; &lt;div id=&quot;message&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var websocket = null; var clientId = Math.random().toString(36).substr(2); //判断当前浏览器是否支持WebSocket if(&#x27;WebSocket&#x27; in window)&#123; //连接WebSocket节点 websocket = new WebSocket(&quot;ws://localhost:8080/ws/&quot;+clientId); &#125; else&#123; alert(&#x27;Not support websocket&#x27;) &#125; //连接发生错误的回调方法 websocket.onerror = function()&#123; setMessageInnerHTML(&quot;error&quot;); &#125;; //连接成功建立的回调方法 websocket.onopen = function()&#123; setMessageInnerHTML(&quot;连接成功&quot;); &#125; //接收到消息的回调方法 websocket.onmessage = function(event)&#123; setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 websocket.onclose = function()&#123; setMessageInnerHTML(&quot;close&quot;); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; websocket.close(); &#125; //将消息显示在网页上 function setMessageInnerHTML(innerHTML)&#123; document.getElementById(&#x27;message&#x27;).innerHTML += innerHTML + &#x27;&lt;br/&gt;&#x27;; &#125; //发送消息 function send()&#123; var message = document.getElementById(&#x27;text&#x27;).value; websocket.send(message); &#125;\t//关闭连接 function closeWebSocket() &#123; websocket.close(); &#125;&lt;/script&gt;&lt;/html&gt; 18双token的使用在前端的中，token过期会严重影响用户的体验，所以在常用用户登陆的时候，让token进行无感刷新显得非常重要，因此我们定义了两个token，一个refreshtoken和acesstoken，当accesstoken失效的时候，refreshtoken的有效期还在时代时候，可以获得一个新的ccesstoken。以vue3项目为演示 首先创建一个vue3项目，在项目中安装axios，封装一个request请求 12345678910111213141516171819202122232425262728293031323334353637383940//添加请求拦截器//导入axios npm install axiosimport axios from &#x27;axios&#x27;;sessionStorage.getItem(&quot;refreshToken&quot;);//定义一个变量,记录公共的前缀,baseURLconst baseURL = &#x27;/api&#x27;;const instance = axios.create(&#123; baseURL&#125;)//添加请求拦截器instance.interceptors.request.use( (config) =&gt; &#123; return config &#125;, (err) =&gt; &#123; //如果请求错误做什么 Promise.reject(err) &#125;)//添加响应拦截器instance.interceptors.response.use( (response) =&gt; &#123; //对响应数据做点什么 //console.log(response) if (response.data.code == 0) &#123; return response.data &#125; else &#123; console.log(response.data.msg) &#125; &#125;, (err) =&gt; &#123; return Promise.reject(err); //异步的状态转化成失败的状态 &#125;)export default instance; 这是一个基本的axios请求，并且注册了拦截器，要让请求到达后端，我们还需要设置以下跨域问题，可以在前端设置，也可以在后端设置，这里就直接在前端进行配置 123456789101112131415161718192021 devServer: &#123; //允许所有请求进入 allowedHosts: &#x27;all&#x27;, //关闭浏览器网页的全屏报错 client: &#123; overlay: false, &#125;, //解决跨域问题 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;,//这里填入你要请求的接口的前缀 ws:true,//代理websocked changeOrigin:true,//虚拟的站点需要更管origin secure: true, //是否https接口 pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27;//重写路径 &#125; &#125; &#125;&#125; 这样一个基本的前端项目就搭建完成，现在来创建两个按钮，用来发送请求 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt; 按钮 &lt;/button&gt; &lt;button @click=&quot;handleClick1&quot;&gt; 发送请求 &lt;/button&gt; &lt;div id=&quot;message&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import request from &#x27;./request&#x27;;const accessToken = ref(&quot;&quot;);const refreshToken = ref(&quot;&quot;);const handleClick = async () =&gt; &#123; const message = await request.get(&#x27;/get&#x27;) console.log(&quot;获得token&quot;); accessToken.value = message.data.accessToken; refreshToken.value = message.data.refreshToken; //将数据保存在浏览器缓存中，关闭浏览器后消失，也可以在存储在其他容器中，这里演示，就直接存储在本地 sessionStorage.setItem(&quot;accessToken&quot;, accessToken.value); sessionStorage.setItem(&quot;refreshToken&quot;, refreshToken.value);&#125;const handleClick1 = async () =&gt; &#123; console.log(&quot;发起请求&quot;) const message = await request.get(&#x27;/text&#x27;) console.log(&quot;请求返回结果&quot;) console.log(message);&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 其中按钮1是为了获得token并且将token进行存储按钮2是为了对受保护的请求发起请求，这个请求只有带有有效的token时才会返回数据，为了自动带上token，我们需要对请求拦截器进行一定的修改 123456789101112131415//添加请求拦截器instance.interceptors.request.use( (config) =&gt; &#123; const accessToken = sessionStorage.getItem(&quot;accessToken&quot;); const refreshToken = sessionStorage.getItem(&quot;refreshToken&quot;); //console.log(accessToken, refreshToken); config.headers.accessToken = accessToken config.headers.refreshToken = refreshToken return config &#125;, (err) =&gt; &#123; //如果请求错误做什么 Promise.reject(err) &#125;) 这段代码的意思是，从本地获得存储的token，再将其放入请求头中， 当accesstoken失效的时候，后端会给我们返回一个401未授权，我们需要在响应拦截器中拦截这个请求 1234567891011121314151617181920212223242526272829303132//添加响应拦截器instance.interceptors.response.use( (response) =&gt; &#123; //对响应数据做点什么 //console.log(response) if (response.data.code == 0) &#123; return response.data &#125; else &#123; console.log(response.data.msg) &#125; &#125;, async (err) =&gt; &#123; if (err.response.status === 401 &amp;&amp; err.response.headers.isoverdue == &quot;true&quot;) &#123; console.log(&#x27;token失效&#x27;) &#125; else if (err.response.status === 401 &amp;&amp; !err.response.headers.isoverdue) &#123; console.log(&#x27;重新请求&#x27;) const result = await instance.get(&quot;/refresh&quot;); const accessToken = result.data.accessToken; const refreshToken = result.data.refreshToken; sessionStorage.removeItem(&quot;accessToken&quot;); sessionStorage.removeItem(&quot;refreshToken&quot;); sessionStorage.setItem(&quot;accessToken&quot;, accessToken); sessionStorage.setItem(&quot;refreshToken&quot;, refreshToken); const data = await instance.request(err.config) return data &#125; else &#123; console.log(err.response.data.msg) &#125; return Promise.reject(err); //异步的状态转化成失败的状态 &#125;) 后端请求回来时，如果refreshtoken也过期，会在请求头中添加isoverdue，当其存在时，说明refreshtoken已经过期，这时候，我们便需要重新登陆 不然我们需要重新请求获得新的token，我们拦截未登录的请求，并且向后端的刷新接口来刷新我们的token，将获得的token重新存入本地，通过instance.request(err.config)重新发送请求，这样我们便完成了双token","tags":["前端"],"categories":["前端"]},{"title":"后端工具类","path":"/2024/03/31/后端工具类/","content":"1.md5加密密码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.security.MessageDigest;import java.security.NoSuchAlgorithmException; public class Md5Util &#123; /** * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合 */ protected static char hexDigits[] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;; protected static MessageDigest messagedigest = null; static &#123; try &#123; messagedigest = MessageDigest.getInstance(&quot;MD5&quot;); &#125; catch (NoSuchAlgorithmException nsaex) &#123; System.err.println(Md5Util.class.getName() + &quot;初始化失败，MessageDigest不支持MD5Util。&quot;); nsaex.printStackTrace(); &#125; &#125; /** * 生成字符串的md5校验值 * * @param s * @return */ public static String getMD5String(String s) &#123; return getMD5String(s.getBytes()); &#125; /** * 判断字符串的md5校验码是否与一个已知的md5码相匹配 * * @param password 要校验的字符串 * @param md5PwdStr 已知的md5校验码 * @return */ public static boolean checkPassword(String password, String md5PwdStr) &#123; String s = getMD5String(password); return s.equals(md5PwdStr); &#125; public static String getMD5String(byte[] bytes) &#123; messagedigest.update(bytes); return bufferToHex(messagedigest.digest()); &#125; private static String bufferToHex(byte bytes[]) &#123; return bufferToHex(bytes, 0, bytes.length); &#125; private static String bufferToHex(byte bytes[], int m, int n) &#123; StringBuffer stringbuffer = new StringBuffer(2 * n); int k = m + n; for (int l = m; l &lt; k; l++) &#123; appendHexPair(bytes[l], stringbuffer); &#125; return stringbuffer.toString(); &#125; private static void appendHexPair(byte bt, StringBuffer stringbuffer) &#123; char c0 = hexDigits[(bt &amp; 0xf0) &gt;&gt; 4];// 取字节中高 4 位的数字转换, &gt;&gt;&gt; // 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同 char c1 = hexDigits[bt &amp; 0xf];// 取字节中低 4 位的数字转换 stringbuffer.append(c0); stringbuffer.append(c1); &#125; &#125; 2.JWT令牌使用导入pom坐标123456&lt;!--JWT起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt; &lt;/dependency&gt; 创建工具类123456789101112131415161718192021public class JwtUtil &#123; //进行加密的keyprivate static final String KEY = &quot;forexample&quot;;//接收业务数据,生成token并返回，这里用的是userId和usernamepublic static String genToken(Map&lt;String, Object&gt; claims) &#123; return JWT.create() .withClaim(&quot;claims&quot;, claims) .withExpiresAt(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 12)) .sign(Algorithm.HMAC256(KEY));&#125; //接收token,验证token,并返回业务数据public static Map&lt;String, Object&gt; parseToken(String token) &#123; return JWT.require(Algorithm.HMAC256(KEY)) .build() .verify(token) .getClaim(&quot;claims&quot;) .asMap();&#125; &#125; 在登陆时返回给前端，在进行其他接口调用的时候，将token传会后端，并且对请求进行拦截 在目录中创建拦截器文件interceptors并且定义拦截器1234567891011121314151617181920212223242526@Slf4j@Componentpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //验证令牌 String token =request.getHeader(&quot;Authorization&quot;); try &#123; //验证token Map&lt;String, Object&gt; stringObjectMap = JwtUtil.parseToken(token); ThreadLocalUtil.set(stringObjectMap); //放行 return true; &#125; catch (Exception e) &#123; response.setStatus(401); log.info(&quot;非法请求&quot;); return false; &#125; &#125; //在拦截器执行完后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //清除thread里面的数据，防止内存泄漏 ThreadLocalUtil.remove(); &#125;&#125; 在配置文件中，对该自定义拦截器进行注册，但是对登陆 和注册接口 1234567891011@Slf4j@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; log.info(&quot;开始注册自定义拦截器&quot;); registry.addInterceptor(loginInterceptor).excludePathPatterns(&quot;/user/login&quot;,&quot;/user/register&quot;); &#125;&#125; 3.后端工程中websocket的使用导入webscoked的maven坐标 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 创建webscoked的服务文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.text;import jakarta.websocket.OnClose;import jakarta.websocket.OnMessage;import jakarta.websocket.OnOpen;import jakarta.websocket.Session;import jakarta.websocket.server.PathParam;import jakarta.websocket.server.ServerEndpoint;import org.springframework.stereotype.Component;import java.io.IOException;import java.util.Collection;import java.util.HashMap;import java.util.Map;@Component@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)public class webSocked &#123; private static Map&lt;String, Session&gt; sessionMap =new HashMap(); /** * 链接成功的回调方法 */ @OnOpen public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid)&#123; System.out.println(&quot;与客户端&quot;+sid+&quot;建立链接&quot;); sessionMap.put(sid,session); &#125; /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息 */ @OnMessage public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) &#123; System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message); &#125; /** * 连接关闭调用的方法 * * @param sid */ @OnClose public void onClose(@PathParam(&quot;sid&quot;) String sid) &#123; System.out.println(&quot;连接断开:&quot; + sid); sessionMap.remove(sid); &#125; /** * 群发 * * @param message */ public void sendToAllClient(String message) &#123; Collection&lt;Session&gt; sessions =sessionMap.values(); for (Session session : sessions) &#123; try &#123; session.getBasicRemote().sendText(message); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 将webscoked注入配置类中 123456789101112131415package com.example.text;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configurationpublic class webSockedConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 创建测试类 12345678910111213141516171819package com.example.text;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Componentpublic class webSockedText &#123; @Autowired private webSocked webSocked; @Scheduled(cron = &quot;0/5 * * * * ?&quot;) public void sendMessage() &#123; webSocked.sendToAllClient(&quot;这是来自服务端的消息：&quot; + DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;).format(LocalDateTime.now())); &#125;&#125; 定时任务在程序主入口出添加允许任务的注解 123456789101112131415161718192021package com.example.text;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;//springboot注解@SpringBootApplication//lombok注解@Slf4j//开启事务注解@EnableSchedulingpublic class TextApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TextApplication.class, args); log.info(&quot;服务启动&quot;); &#125;&#125; 4.双token首先导入jwt的pom依赖 12345 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; result结果类 123456789101112131415161718192021222324package com.example.text;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@AllArgsConstructor@NoArgsConstructor@Datapublic class result&lt;T&gt; &#123; private Integer code; private String message; private T data; public static &lt;E&gt; result&lt;E&gt; success(E data)&#123; return new result&lt;E&gt;(0,&quot;操作成功&quot;,data); &#125; public static result success()&#123; return new result(0,&quot;操作成功&quot;,null); &#125; public static result error(String message) &#123; return new result(1, message, null); &#125;&#125; 编写一个jwt工具类 12345678910111213141516171819202122232425262728293031package com.example.text;import com.auth0.jwt.JWT;import com.auth0.jwt.algorithms.Algorithm;import java.util.Date;import java.util.Map;public class jwt &#123; private static final String KEY = &quot;forexample&quot;; //接收业务数据,生成token并返回 public static String genToken(Map&lt;String, Object&gt; claims, int minute) &#123; return JWT.create() .withClaim(&quot;claims&quot;, claims) .withExpiresAt(new Date(System.currentTimeMillis() +1000*minute))//1000 * 60 * 60 * 12 .sign(Algorithm.HMAC256(KEY)); &#125; //接收token,验证token,并返回业务数据 public static Map&lt;String, Object&gt; parseToken(String token) &#123; return JWT.require(Algorithm.HMAC256(KEY)) .build() .verify(token) .getClaim(&quot;claims&quot;) .asMap(); &#125;&#125; 定义一个拦截器，核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.text;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import com.example.text.jwt;import java.awt.*;import java.util.Map;@Slf4j@Componentpublic class login implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; //请求拦截器 //获得请求头中的token String accessToken = request.getHeader(&quot;accessToken&quot;); colorPrint.colorPrint(&quot;accessToken----&quot; + accessToken, colorPrint.BLUE); String refreshToken = request.getHeader(&quot;refreshToken&quot;); colorPrint.colorPrint(&quot;refreshToken----&quot; + refreshToken, colorPrint.BLUE); try &#123; //解析accessToken Map&lt;String, Object&gt; map = jwt.parseToken(accessToken); colorPrint.colorPrint(&quot;请求token通过，允许访问&quot;, colorPrint.BLUE); //成功 return true; &#125; catch (Exception e) &#123; //失败，开始解析refreshtoken，判断是否过期 try &#123; Map&lt;String, Object&gt; map = jwt.parseToken(refreshToken); &#125; catch (Exception exception) &#123; //refreshtoken失效 colorPrint.colorPrint(&quot;七天请求过期&quot;, colorPrint.RED); response.setHeader(&quot;isOverdue&quot;,&quot;true&quot;); response.setStatus(401); return false; &#125; //refreshtoken有效期没过 colorPrint.colorPrint(&quot;非法请求&quot;, colorPrint.RED); response.setStatus(401); return false; &#125; &#125;&#125; 为了打印彩色的语句，自己封装了一个彩色打印 12345678910111213141516package com.example.text;public class colorPrint &#123; public static final Integer RED=31; public static final Integer BLACK=30; public static final Integer GREEN=32; public static final Integer ORIGIN=33; public static final Integer BLUE=34; public static final Integer PURPLE=35; public static final Integer AQUA=36; public static final Integer GRAY=37; public static void colorPrint(String message, Integer color) &#123; System.out.println(&quot;\\033[&quot;+color+&quot;;4m&quot; + message + &quot;\\033[0m&quot;); &#125;&#125; 将自定义拦截器注册 123456789101112131415161718package com.example.text;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class config implements WebMvcConfigurer &#123; @Autowired private login login; @Override public void addInterceptors(InterceptorRegistry registry) &#123; colorPrint.colorPrint(&quot; 自定义拦截器开始生效&quot;,colorPrint.GREEN); //除了获得token和refresh请求，其他的请求都要经过拦截器 registry.addInterceptor(login).excludePathPatterns(&quot;/get&quot;,&quot;/refresh&quot;); &#125;&#125; 定义请求层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.text;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;@Slf4j@RestControllerpublic class controller &#123; @GetMapping(&quot;/text&quot;) public result textService() &#123; colorPrint.colorPrint(&quot;请求进入&quot;, colorPrint.ORIGIN); return result.success(); &#125; @GetMapping(&quot;/get&quot;) public result&lt;Map&gt; get() &#123; Map&lt;String, Object&gt; clains = new HashMap&lt;&gt;(); clains.put(&quot;id&quot;, 1); clains.put(&quot;username&quot;, 666); log.info(&quot;生成jwt令牌&quot;); String accessToken = jwt.genToken(clains, 3); String refreshToken = jwt.genToken(clains, 60); colorPrint.colorPrint(accessToken, colorPrint.RED); colorPrint.colorPrint(refreshToken, colorPrint.BLUE); Map map = new HashMap&lt;&gt;(); map.put(&quot;accessToken&quot;, accessToken); map.put(&quot;refreshToken&quot;, refreshToken); return result.success(map); &#125; @GetMapping(&quot;/refresh&quot;) public result&lt;Map&gt; refresh(@RequestHeader(name = &quot;refreshToken&quot;) String refreshToken) &#123; Map&lt;String, Object&gt; map = jwt.parseToken(refreshToken); String newAccessToken = jwt.genToken(map, 3); String newRefreshToken = jwt.genToken(map, 60); Map hashMap = new HashMap&lt;&gt;(); colorPrint.colorPrint(newAccessToken, colorPrint.PURPLE); colorPrint.colorPrint(newRefreshToken, colorPrint.PURPLE); hashMap.put(&quot;accessToken&quot;, newAccessToken); hashMap.put(&quot;refreshToken&quot;, newRefreshToken); return result.success(hashMap); &#125;&#125; 5.图形验证码使用验证码生成工具 本项目使用开源的验证码生成工具EasyCaptcha，其支持多种类型的验证码，例如gif、中文、算术等，并且简单易用，具体内容可参考其官方文档。 在common模块的pom.xml文件中增加如下内容 1234&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;&lt;/dependency&gt; 在service中使用 12345SpecCaptcha specCaptcha = new SpecCaptcha(130, 48, 4);specCaptcha.setCharType(Captcha.TYPE_DEFAULT);String code = specCaptcha.text().toLowerCase();System.out.println(code);String image = specCaptcha.toBase64(); 启动项目当有请求进入的时候，会生成验证码的code，code是验证吗的值，image由base64编码，到前端进行解码，此处并没有使用redis，正常情况下需要生成一个uuid作为redis存储的key，而code作为redis的value。返回给前端的是验证码图片imag和redis的key，当前端有请求进来时，携带用户名和密码，图片验证码key和code，进入后端查询redis，进行正常的登陆","tags":["java"],"categories":["java"]},{"title":"linux","path":"/2024/03/23/linux/","content":"linux安装linux（略）修改网卡，初始化IP1.输入 1ip addr 若没有IP出现，则需要配置 2.修改 12345cd/cd etccd sysconfigcd netword-scriptsvi ifcfg-ens33 输入i进入编辑，移动光标，修改完成后按下esc，输入wq，回车。保存退出 安装ssh链接工具安装finalshell，快速链接即可 linux目录 Linux文件系统目录结构理解和熟悉Linux系统的文件系统目录结构，对于有效的管理和定位文件十分重要。Linux文件系统的目录结构如下图所示： 其中各目录的作用如下表所示 目录 说明 作用 &#x2F; 根目录 根目录是整个文件系统的起点，所有其他目录和文件都位于根目录之下。 &#x2F;home 家目录 每个用户的个人目录都位于这个目录下，通常以用户名命名。例如，用户john的主目录路径为/home/john。 &#x2F;root root用户的家目录 保存root用户的个人数据 &#x2F;boot 引导文件所在目录 保存系统启动时所需的各种文件 &#x2F;usr User System Resources的简写，说法不唯一 存放用户可用的软件和程序文件，也包括了一些共享的数据和库文件。 &#x2F;bin binary的简写 存放系统的基本命令（如ls、cp等）和其余可执行文件。 &#x2F;sbin system binary的简写 存放系统管理和维护方面的二进制文件。 &#x2F;etc etcetera的简写 存放系统的配置文件，包括各种程序的配置文件和系统的全局配置文件。 &#x2F;var variable的简写 存放系统运行时产生的可变数据，如日志文件、数据库文件等。 &#x2F;opt optional的简写 存放一些可选的软件包，通常由用户自行安装。 &#x2F;tmp temporary的简写 存放临时文件，系统会定期清理该目录 linux常用命令 序号 命令 作用 1 ls 查看当前目录下所有内容 2 pwd 查看当前所在目录 3 cd 切换目录 4 touch 如果文件不存在，新建文件 5 mkdir 创建目录 6 rm 删除指定文件 显示文件内容cat1cat[-n] filename -n:由1开始对所有输出的行数编号 以分页的形式显示内容1more filename 操作： 回车 向下滚动一行 ​\t空格 向下滚动一屏 ​\tb 返回上一屏 ​\tq或者ctrl c 退出more 查看文件末尾内容（默认后十行）1tail [-f] filename 删除空目录1rmdir [-p] dirname -p : 当子目录被删除后使父目录为空目录时，一并删除 删除文件1rm [-rf] name -f 将目录及所有文件删除（递归删除） -r 无需确认，直接删除 删除文件夹1rm -rf 文件夹名字 复制文件夹1cp -r 文件目录/. 文件目录 查看防火墙状态1firewall-cmd --state 打开防火墙1systemctl start firewalld.service 开启端口1firewall-cmd --zone=public --add-port=端口/tcp --permanent 重启防火墙1systemctl restart firewalld.service 查看已开启的端口1firewall-cmd --list-ports 如何关闭端口1firewall-cmd --zone=public --remove-port=端口/tcp --permanent 查看端口占用1netstat -ntlp 安装nginx前景提要：本人小白一个，由于需要将前端的代码部署到服务器上，然后了解到了nginx，便开始了nginx安装配置的信息搜集和实践，经过屡次的失败，最后在b站上一个视频的带领下，成功完成。 一.依赖下载 1yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 二.下载nginx 1.访问官网 ，获取nginx Nginux官网 鼠标放在需要下载的版本上，右击鼠标“复制链接” 2.在Linux系统上进行下载（示例：下载1.25.1版本） 1wget http://nginx.org/download/nginx-1.25.1.tar.gz 3.便于管理，可以创建一个文件夹来保存（若不想的可以跳过步骤3，4） 创建文件夹 1mkdir /usr/java #将包移入文件夹中 1mv nginx-1.25.1.tar.gz /usr/java #转换到该文件夹下 1cd /usr/java #查看文件夹的内容 1ls 4.解压包，并转换到nginx文件夹下 #解压包 1tar -zxf nginx-1.25.1.tar.gz #转换到nginx文件夹下 1cd nginx-1.25.1 出现“nginx-1.25.1”表示解压成功 5.配置nginx 1./configure 6.编译安装nginx #这是编译和安装一块进行（&amp;&amp;），也可以分开 1make&amp;&amp;make install 过程如下： 7.运行nginx8 #转换到sbin文件夹下 1cd /usr/local/nginx/sbin #运行nginx 1./nginx 8.查看结果 ​ （1）通过命令行进行 ​ （2）直接通过ip地址（服务器ip）+端口号（默认80） ​ 注：如用方式（2）进行访问的话，记得要开放端口号 firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent 编辑配置文件1vim /etc/nginx/nginx.conf 利用centos7搭建linux环境1.下载镜像找到中国阿里云镜像网centos-7-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com) 下载镜像，这里选择的是CentOS-7-x86_64-Minimal-2009.iso下载完成后放入磁盘待用， 2.下载vmware虚拟机我们在VMware《主页》界面中点击《创建新的虚拟机》按钮： 然后会弹出一个窗口，我们直接点击下一步： 然后页面中选择你准备好的ISO文件，继续点击下一步： 然后填写虚拟机的名称以及虚拟机将来保存的位置： 再次下一步，填写虚拟机磁盘大小。这里建议给大一点，否则将来不够用调整起来麻烦。而且这里设置大小并不是立刻占用这么多，而是设置一个上限： 继续下一步，然后选择虚拟机硬件设置： 在弹出的窗口中设置虚拟机硬件，建议CPU给到4核，内存给到8G： 配置完成后，点击关闭，回到上一页面，继续点击完成： 虚拟机就创建完毕了： 3.安装Centos7接下来，我们启动刚刚创建的虚拟机，开始安装Centos7系统： 启动后需要选择安装菜单，将鼠标移入黑窗口中后，将无法再使用鼠标，需要按上下键选择菜单。选中Install Centos 7 后按下回车： 然后会提示我们按下enter键继续： 过一会儿后，会进入语言选择菜单，这里可以使用鼠标选择。选择中文-简体中文，然后继续： 接下来，会进入安装配置页面： 鼠标向下滚动后，找到系统-安装位置配置，点击： 选择刚刚添加的磁盘，并点击完成： 然后回到配置页面，这次点击《网络和主机名》： 在网络页面做下面的几件事情： 修改主机名为自己喜欢的主机名，不要出现中文和特殊字符，建议用localhost 点击应用 将网络连接打开 点击配置，设置详细网络信息 最好用一个截图软件，记住上图中的网络详细信息，接下来的配置要参考： 点击配置按钮后，我们需要把网卡地址改为静态IP，这样可以避免每次启动虚拟机IP都变化。所有配置照搬你自己截图的网络信息填写，不要照抄我的： 上图中的四个信息参考之前的以太网**(ens33)**网卡的截图，不要照搬我的来写。 最后，点击完成按钮： 回到配置界面后，点击开始安装： 接下来需要设置root密码： 填写你要使用的root密码，然后点击完成： 接下来，耐心等待安装即可。 4.利用ssh连接工具链接虚拟机，这里使用finalshell，下载好后打开利用ssh链接 主机名为虚拟机的ip地址 名称根据个人喜好进行填写 用户名为当时创建虚拟机时填写的用户名 密码同理 全部填写完成后点击 确定，然后打开这个终端，应该就能连接上虚拟机了 5.使用虚拟机利用yum update命令更新yum 注意，此时可能报错**Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock32 error was 14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; Unknown error**,这是因为网络配置有问题在命令行输入 1curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 便可以解决问题，再次使用yum update发现问题解决 6.安装docker利用yum工具安装docker 首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fast 在命令行输入 1yum install -y docker-ce 安装docker，利用 1docker -v 查看docker安装的版本，若正常显示出docker版本，则docker安装成功 7.利用docker安装mysql1.创建一个网络1docker network create net 2.使用pull命令拉取镜像1docker pull mysql 这里如果显示连接失败第一步：新建或编辑daemon.json 1vi /etc/docker/daemon.json 第二步：daemon.json中编辑如下 123456&quot;registry-mirrors&quot;: [ &quot;https://docker.m.daocloud.io&quot;, &quot;https://dockerproxy.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://docker.nju.edu.cn&quot; ] 第三步：重启docker 1systemctl restart docker.service 第四步：执行docker info查看是否修改成功 1docker info 拉取镜像后使用 1docker images 查看拉取下来的镜像，使用命令运行镜像 1234567docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=1234 \\ --network net\\ mysql 可以启动mysql，最后访问虚拟机ip加端口就可以对数据库进行操作 8.安装nacos安装nacos，首先需要创建一个nacos专用数据库 连接数据库，执行以下命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246-- 导出 nacos 的数据库结构DROP DATABASE IF EXISTS `nacos`;CREATE DATABASE IF NOT EXISTS `nacos` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */;USE `nacos`;-- 导出 表 nacos.config_info 结构DROP TABLE IF EXISTS `config_info`;CREATE TABLE IF NOT EXISTS `config_info` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin DEFAULT NULL, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `c_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL, `c_use` varchar(64) COLLATE utf8_bin DEFAULT NULL, `effect` varchar(64) COLLATE utf8_bin DEFAULT NULL, `type` varchar(64) COLLATE utf8_bin DEFAULT NULL, `c_schema` text COLLATE utf8_bin, `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;-- 正在导出表 nacos.config_info 的数据：~0 rows (大约)DELETE FROM `config_info`;-- 导出 表 nacos.config_info_aggr 结构DROP TABLE IF EXISTS `config_info_aggr`;CREATE TABLE IF NOT EXISTS `config_info_aggr` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `datum_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;datum_id&#x27;, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;内容&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;-- 正在导出表 nacos.config_info_aggr 的数据：~0 rows (大约)DELETE FROM `config_info_aggr`;-- 导出 表 nacos.config_info_beta 结构DROP TABLE IF EXISTS `config_info_beta`;CREATE TABLE IF NOT EXISTS `config_info_beta` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;, `beta_ips` varchar(1024) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;betaIps&#x27;, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;-- 正在导出表 nacos.config_info_beta 的数据：~0 rows (大约)DELETE FROM `config_info_beta`;-- 导出 表 nacos.config_info_tag 结构DROP TABLE IF EXISTS `config_info_tag`;CREATE TABLE IF NOT EXISTS `config_info_tag` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tag_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_id&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;-- 正在导出表 nacos.config_info_tag 的数据：~0 rows (大约)DELETE FROM `config_info_tag`;-- 导出 表 nacos.config_tags_relation 结构DROP TABLE IF EXISTS `config_tags_relation`;CREATE TABLE IF NOT EXISTS `config_tags_relation` ( `id` bigint NOT NULL COMMENT &#x27;id&#x27;, `tag_name` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_name&#x27;, `tag_type` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tag_type&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `nid` bigint NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;-- 正在导出表 nacos.config_tags_relation 的数据：~0 rows (大约)DELETE FROM `config_tags_relation`;-- 导出 表 nacos.group_capacity 结构DROP TABLE IF EXISTS `group_capacity`;CREATE TABLE IF NOT EXISTS `group_capacity` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;, `quota` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;, `max_aggr_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;-- 正在导出表 nacos.group_capacity 的数据：~0 rows (大约)DELETE FROM `group_capacity`;-- 导出 表 nacos.his_config_info 结构DROP TABLE IF EXISTS `his_config_info`;CREATE TABLE IF NOT EXISTS `his_config_info` ( `id` bigint unsigned NOT NULL, `nid` bigint unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) COLLATE utf8_bin NOT NULL, `group_id` varchar(128) COLLATE utf8_bin NOT NULL, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext COLLATE utf8_bin NOT NULL, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text COLLATE utf8_bin, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL, `op_type` char(10) COLLATE utf8_bin DEFAULT NULL, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;, PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;-- 正在导出表 nacos.his_config_info 的数据：~0 rows (大约)DELETE FROM `his_config_info`;-- 导出 表 nacos.permissions 结构DROP TABLE IF EXISTS `permissions`;CREATE TABLE IF NOT EXISTS `permissions` ( `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, `resource` varchar(255) COLLATE utf8mb4_general_ci NOT NULL, `action` varchar(8) COLLATE utf8mb4_general_ci NOT NULL, UNIQUE KEY `uk_role_permission` (`role`,`resource`,`action`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;-- 正在导出表 nacos.permissions 的数据：~0 rows (大约)DELETE FROM `permissions`;-- 导出 表 nacos.roles 结构DROP TABLE IF EXISTS `roles`;CREATE TABLE IF NOT EXISTS `roles` ( `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, UNIQUE KEY `idx_user_role` (`username`,`role`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;-- 正在导出表 nacos.roles 的数据：~1 rows (大约)DELETE FROM `roles`;INSERT INTO `roles` (`username`, `role`) VALUES\t(&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;);-- 导出 表 nacos.tenant_capacity 结构DROP TABLE IF EXISTS `tenant_capacity`;CREATE TABLE IF NOT EXISTS `tenant_capacity` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;, `quota` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;, `max_aggr_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;-- 正在导出表 nacos.tenant_capacity 的数据：~0 rows (大约)DELETE FROM `tenant_capacity`;-- 导出 表 nacos.tenant_info 结构DROP TABLE IF EXISTS `tenant_info`;CREATE TABLE IF NOT EXISTS `tenant_info` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `kp` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;kp&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tenant_name` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;, `tenant_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;, `create_source` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;create_source&#x27;, `gmt_create` bigint NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` bigint NOT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;-- 正在导出表 nacos.tenant_info 的数据：~0 rows (大约)DELETE FROM `tenant_info`;-- 导出 表 nacos.users 结构DROP TABLE IF EXISTS `users`;CREATE TABLE IF NOT EXISTS `users` ( `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, `password` varchar(500) COLLATE utf8mb4_general_ci NOT NULL, `enabled` tinyint(1) NOT NULL, PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;-- 正在导出表 nacos.users 的数据：~1 rows (大约)DELETE FROM `users`;INSERT INTO `users` (`username`, `password`, `enabled`) VALUES\t(&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, 1);/*!40103 SET TIME_ZONE=IFNULL(@OLD_TIME_ZONE, &#x27;system&#x27;) */;/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, &#x27;&#x27;) */;/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */; 并且创建名为nacos的文件夹，在文件夹内部创建文件custom.env在内部填入 123456789PREFER_HOST_MODE=hostnameMODE=standaloneSPRING_DATASOURCE_PLATFORM=mysqlMYSQL_SERVICE_HOST= ****//你自己的虚拟机ip地址MYSQL_SERVICE_DB_NAME=nacosMYSQL_SERVICE_PORT=3306MYSQL_SERVICE_USER=rootMYSQL_SERVICE_PASSWORD=*****//你自己的虚拟机mysql密码MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai 将nacos文件夹放入虚拟机root根目录 使用docker pull nacos拉取nacos的镜像 123456789docker run -d \\--name nacos \\--env-file /root/nacos/custom.env \\-p 8848:8848 \\-p 9848:9848 \\-p 9849:9849 \\--restart=always \\--network net acos 启动完成后，访问下面地址：http://192.168.150.101:8848/nacos/，注意将`192.168.150.101`替换为你自己的虚拟机IP地址。 首次访问会跳转到登录页，账号密码都是nacos","tags":["linux"],"categories":["linux"]},{"title":"数据结构","path":"/2024/03/23/数据结构/","content":"[TOC] 数据结构 顺序表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MaxSize 10 // 定义最大长度typedef struct&#123; int data[MaxSize]; // 使用静态的数组存放数据元素 int length; // 顺序表的当前长度&#125; SqList;// 在顺序表i位置插入ebool ListInsert(SqList *L, int i, int e)&#123; if (i &lt; 1 || i &gt; L-&gt;length + 1) // 判断i的范围是否有效 return false; if (L-&gt;length &gt;= MaxSize) // 判断存储空间是否已满 return false; for (int j = L-&gt;length; j &gt;= i; j--) // 将第i个元素之后的元素后移 L-&gt;data[j] = L-&gt;data[j - 1]; L-&gt;data[i - 1] = e; // 在位置i处放入e L-&gt;length++; // 长度+1 return true;&#125;// 初始化顺序表void InitList(SqList *&amp;L)&#123; L = (SqList *)malloc(sizeof(SqList)); L-&gt;length = 0; // 顺序表初始长度为0&#125;// 添加元素void AddList(SqList *L)&#123; int i = 0; while (i &lt;= 5) &#123; L-&gt;length++; L-&gt;data[i] = i; i++; &#125;&#125;// 打印元素void printList(SqList *L)&#123; for (int i = 0; i &lt; L-&gt;length; i++) &#123; printf(&quot;%d&quot;, L-&gt;data[i]); &#125;&#125;int main()&#123; SqList *L; // 声明一个顺序表 InitList(L); // 初始化顺序表 AddList(L);//添加元素 ListInsert(L, 3, 3); // 在指定位置插入3 printList(L);//打印元素 return 0;&#125; 单链表两种实现方式： 带头结点，写代码更方便。头结点不存储数据，头结点指向的下一个结点才存放实际数据。 不带头结点，麻烦。对第一个数据结点与后续数据结点的处理需要用不同的代码逻辑，对空表和非空表的处理需要用不同的代码逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int// 结构体typedef struct LNode&#123; int data; struct LNode *next;&#125; LNode;// 初始化单链表void InitList(LNode *&amp;L)&#123; L = (LNode *)malloc(sizeof(LNode)); L-&gt;next = NULL; // 创建头结点，并且将next指向null&#125;// 输出单链表void DispList(LNode *L)&#123; LNode *p = L-&gt;next; while (p != NULL) &#123; printf(&quot;%d&quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot; &quot;);&#125;// 判断单链表是否为空bool ListEmpty(LNode *L)&#123; return (L-&gt;next == NULL);&#125;// 求单链表的长度int ListLength(LNode *L)&#123; int n = 0; LNode *p = L; while (p-&gt;next != NULL) &#123; n++; p = p-&gt;next; &#125; return n;&#125;// 向单链表中添加元素void AddList(LNode *&amp;L)&#123; LNode *p,*s; p=L; for (int i = 0; i &lt; 10; i++) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=i; p-&gt;next=s; p=p-&gt;next; &#125; p-&gt;next=NULL; &#125;// 主函数int main()&#123; LNode *L; InitList(L); AddList(L); DispList(L); return 0;&#125; 单链表尾插法12345678910111213141516// 向单链表中添加元素void AddList(LNode *&amp;L)&#123; LNode *p,*s; p=L; for (int i = 0; i &lt; 10; i++) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=i; p-&gt;next=s; p=p-&gt;next; &#125; p-&gt;next=NULL; &#125; 单链表头插法1234567891011121314void AddList(LNode *&amp;L)&#123; LNode *p,*s; p=L; for (int i = 0; i &lt; 10; i++) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=i; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125; &#125; 双链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int// 结构体typedef struct DNode&#123; // 定义双链表结点类型 ElemType data; // 数据域 struct DNode *prior; // 前驱指针 struct DNode *next; // 后继指针&#125; DNode;// 初始化双链表void InitList(DNode *&amp;L)&#123; L = (DNode *)malloc(sizeof(DNode)); L-&gt;next = NULL; // 将next指向null L-&gt;prior = NULL; // 将prior指向null&#125;// 判断双链表是否为空bool Empty(DNode *L)&#123; if (L-&gt;next == NULL) return true; else return false;&#125;// 输出单链表void DispList(DNode *L)&#123; DNode *p = L-&gt;next; while (p != NULL) &#123; printf(&quot;%d&quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot; &quot;);&#125;// 判断单链表是否为空bool ListEmpty(DNode *L)&#123; return (L-&gt;next == NULL);&#125;// 向单链表中添加元素（尾插法）void AddList1(DNode *&amp;L)&#123; DNode *p, *s; p = L; for (int i = 0; i &lt; 10; i++) &#123; s = (DNode *)malloc(sizeof(DNode)); s-&gt;data = i; s-&gt;prior = p; p-&gt;next = s; p = p-&gt;next; &#125; p-&gt;next = NULL;&#125;// 向单链表中添加元素（头插法）void AddList(DNode *&amp;L)&#123; DNode *p, *s; p = L; for (int i = 0; i &lt; 10; i++) &#123; s = (DNode *)malloc(sizeof(DNode)); s-&gt;data = i; s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;// 主函数int main()&#123; DNode *L; InitList(L); AddList(L); DispList(L); return 0;&#125; 栈栈的基本操作 InitStack(&amp;S)：初始化栈。构造一个空栈 S，分配内存空间。 DestroyStack(&amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。 Push(&amp;S, x)：进栈。若栈 S 未满，则将 x 加入使其成为新的栈顶元素。 Pop(&amp;S, &amp;x)：出栈。若栈 S 非空，则弹出（删除）栈顶元素，并用 x 返回。 GetTop(S, &amp;x)：读取栈顶元素。若栈 S 非空，则用 x 返回栈顶元素。 StackEmpty(S)：判空。断一个栈 S 是否为空，若 S 为空，则返回 true，否则返回 false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MaxSize 10// 结构体typedef struct&#123; ElemType data[10]; // 静态数组存放栈中元素 int top; // 栈顶元素&#125; SqStack;// 初始化栈void InitList(SqStack *&amp;L)&#123; L = (SqStack *)malloc(sizeof(SqStack)); L-&gt;top = -1;&#125;// 判断栈是否为空bool StackEmpty(SqStack *S)&#123; if (S-&gt;top == -1) return true; else return false;&#125;// 新元素进栈void push(SqStack *S)&#123; // 判断栈是否已满 if (S-&gt;top == MaxSize - 1) &#123; printf(&quot;栈满&quot;); &#125; else &#123; for (int i = 0; i &lt; MaxSize-1; i++) &#123; S-&gt;top++; S-&gt;data[S-&gt;top] = i; &#125; &#125;&#125;// 出栈bool Pop(SqStack *S,int x)&#123; // 判断栈是否为空 if (S-&gt;top == -1) &#123; printf(&quot;栈空&quot;); &#125;else&#123; printf(&quot;出栈了：&quot;); for (int i = 0; i &lt; x; i++) &#123; printf(&quot;%d &quot;,S-&gt;data[S-&gt;top]); S-&gt;top--; &#125; &#125;&#125;//打印栈内元素// 主函数int main()&#123; SqStack *s; InitList(s); push(s); //出栈2次 Pop(s,2); return 0;&#125; 队列 队列的基本操作 InitQueue(&amp;Q)：初始化队列。构造一个空队列 Q。 DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列 Q 所占用的内存空间。 EnQueue(&amp;Q, x)：入队。若队列 Q 未满，将 x 加入，使之成为新的队尾。 DeQueue(&amp;Q, &amp;x)：出队。若队列 Q 非空，删除队头元素，并用 x 返回。 GetHead(Q,&amp;x)：读队头元素。若队列 Q 非空，则将队头元素赋值给 x。 QueueEmpty(Q)：判空。若队列 Q 为空，则返回 true。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MaxSize 10// 结构体typedef struct&#123; ElemType data[MaxSize]; // 用静态数组存放队列元素 int front, rear; // 队头指针和队尾指针&#125; SqQueue;// 初始化void InitQueue(SqQueue *&amp;q)&#123; q = (SqQueue *)malloc(sizeof(SqQueue)); q-&gt;front = q-&gt;rear = -1;&#125;// 入栈void EnQueue(SqQueue *q)&#123; if (q-&gt;rear == MaxSize - 1) &#123; printf(&quot;栈满&quot;); &#125; else &#123; for (int i = 0; i &lt; MaxSize - 1; i++) &#123; q-&gt;rear++; q-&gt;data[q-&gt;rear] = i; &#125; &#125;&#125;// 出队void DeQueue(SqQueue *q, int x)&#123; if (q-&gt;front == q-&gt;rear) &#123; printf(&quot;队空&quot;); &#125; else &#123; for (int i = 0; i &lt; x; i++) &#123; q-&gt;front++; printf(&quot;%d&quot;,q-&gt;data[i]); &#125; &#125;&#125;// 主函数int main()&#123; SqQueue *q; InitQueue(q); EnQueue(q); // 出队2次 DeQueue(q, 2); return 0;&#125; 串","tags":["数据结构"],"categories":["数据结构"]},{"title":"uniapp","path":"/2024/03/21/uniapp/","content":"UniApp开发1.下载开发者工具1.1打开官网https://www.dcloud.io/hbuilderx.html下载对应版本 1.2.新建项目，选择默认模版，自定义目录 2.将项目运行在微信小程序中2.1打开微信小程序开发的设置界面，开启服务端口，回到，uni编辑器，再次运行，可能需要填写微信小程序开发者工具的安装路径 3.认识目录 配置文件1234567891011121314151617181920212223242526272829303132&#123;\t&quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages &#123; &quot;path&quot;: &quot;pages/index/index&quot;, &quot;style&quot;: &#123; //页面顶部标题 &quot;navigationBarTitleText&quot;: &quot;首页&quot; &#125; &#125;\t],\t&quot;globalStyle&quot;: &#123; &quot;navigationBarTextStyle&quot;: &quot;black&quot;, //导航栏标题文字内容 &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;, //导航栏背景颜色 &quot;navigationBarBackgroundColor&quot;: &quot;#F8F8F8&quot;, //导航栏背景颜色 &quot;backgroundColor&quot;: &quot;#F8F8F8&quot;\t&#125;,\t&quot;uniIdRouter&quot;: &#123;&#125;,\t&quot;condition&quot; : &#123; //模式配置，仅开发期间生效 &quot;current&quot;: 0, //当前激活的模式(list 的索引项) &quot;list&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, //模式名称 &quot;path&quot;: &quot;&quot;, //启动页面，必选 &quot;query&quot;: &quot;&quot; //启动参数，在页面的onLoad函数里面得到 &#125; ]\t&#125;&#125; 添加tabar为底部添加tabar，并在tarbar对页面进行切换 123456789101112&quot;tabBar&quot;: &#123; &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/my/my&quot;, &quot;text&quot;: &quot;我的&quot; &#125; ]\t&#125; 在底部出现底部导航栏，添加图片，将图表放在静态文件夹下通过设置来显示 1234//默认的颜色&quot;iconPath&quot;: &quot;static/...&quot;,//选中的样色&quot;selectedIconPath&quot;: &quot;static/...&quot;, 设置路径 设置选中的颜色 在tabar下设置selectedcolor改为主题色 轮播图12345678&lt;swiper :indicator-dots=&quot;true&quot; :autoplay=&quot;true&quot; :interval=&quot;3000&quot; :duration=&quot;1000&quot;&gt; &lt;swiper-item&gt; &lt;view class=&quot;swiper-item&quot;&gt;&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class=&quot;swiper-item&quot;&gt;&lt;/view&gt; &lt;/swiper-item&gt;\t&lt;/swiper&gt; 默认全屏宽度750rpx， 点击事件@tap&#x3D;“事件” 引入 uni-ui 组件库操作步骤安装 uni-ui 组件库 1pnpm i @dcloudio/uni-ui 配置自动导入组件 1234567891011121314// pages.json&#123; // 组件自动导入 &quot;easycom&quot;: &#123; &quot;autoscan&quot;: true, &quot;custom&quot;: &#123; // uni-ui 规则如下配置 // [!code ++] &quot;^uni-(.*)&quot;: &quot;@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue&quot; // [!code ++] &#125; &#125;, &quot;pages&quot;: [ // …省略 ]&#125; 安装类型声明文件（ts用） 1npm i -D @uni-helper/uni-ui-types 配置类型声明文件（ts用） 12345678910111213141516// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; // ... &quot;types&quot;: [ &quot;@dcloudio/types&quot;, // uni-app API 类型 &quot;miniprogram-api-typings&quot;, // 原生微信小程序类型 &quot;@uni-helper/uni-app-types&quot;, // uni-app 组件类型 &quot;@uni-helper/uni-ui-types&quot; // uni-ui 组件类型 // [!code ++] ] &#125;, // vue 编译器类型，校验标签类型 &quot;vueCompilerOptions&quot;: &#123; &quot;nativeTags&quot;: [&quot;block&quot;, &quot;component&quot;, &quot;template&quot;, &quot;slot&quot;] &#125;&#125; 持久化存储插件安装持久化存储插件： pinia-plugin-persistedstate 1pnpm i pinia-plugin-persistedstate 插件默认使用 localStorage 实现持久化，小程序端不兼容，需要替换持久化 API。 基本用法::: code-group &#123;28-31&#125; [stores/modules/member.ts]12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref &#125; from &#x27;vue&#x27;// 定义 Storeexport const useMemberStore = defineStore( &#x27;member&#x27;, () =&gt; &#123; // 会员信息 const profile = ref&lt;any&gt;() // 保存会员信息，登录时使用 const setProfile = (val: any) =&gt; &#123; profile.value = val &#125; // 清理会员信息，退出时使用 const clearProfile = () =&gt; &#123; profile.value = undefined &#125; // 记得 return return &#123; profile, setProfile, clearProfile, &#125; &#125;, // TODO: 持久化 &#123; //只能在网页端使用 //persist: true, persist:&#123; storage:&#123; getItem(key)&#123; return uni.getStorageSync(key) &#125;, setItem(key,value)&#123; uni.setStorageSync(key,value) &#125; &#125; &#125; &#125;,) &#123;2,7&#125; [stores/index.ts]12345678910111213import &#123; createPinia &#125; from &#x27;pinia&#x27;import persist from &#x27;pinia-plugin-persistedstate&#x27;// 创建 pinia 实例const pinia = createPinia()// 使用持久化存储插件pinia.use(persist)// 默认导出，给 main.ts 使用export default pinia// 模块统一导出export * from &#x27;./modules/member&#x27; &#123;2,8&#125; [main.ts]123456789101112import &#123; createSSRApp &#125; from &#x27;vue&#x27;import pinia from &#x27;./stores&#x27;import App from &#x27;./App.vue&#x27;export function createApp() &#123; const app = createSSRApp(App) app.use(pinia) return &#123; app, &#125;&#125;","tags":["uniApp"],"categories":["uniAPP"]},{"title":"hexo自用手册","path":"/2024/03/18/hexo/","content":"Hexo安装node.js下载进入node.js的官网[https://nodejs.org/下载node.js最新稳定版就行 配置环境变量将node.js根目录放入path变量中 安装git（官网下载，傻瓜式安装）安装hexo打开终端输入 1npm install -g hexo-cli 创建项目1hexo init blog 其中blog为项目名字，可以自行修改 安装主题（以butterfly主题为例）进入博客根目录，打开git bash 1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 安装成功后在themes中会出现butterfly文件夹，其中有配置文件_config.yml这是主题配置文件，而在博客根目录中也有配置文件_config.yml，两个配置文件呢不一样，不要混淆 切换主题在项目的配置文件中通过ctrl+f搜索，找到theme将和面的主题配置改为theme: butterfly 设置语言和时区找到配置文件 12language: zh-CHtimezone: Asia/shanghai 设置网站名称主题配置文件中 12345title: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doe 修改即可 下载渲染器1npm install hexo-renderer-pug hexo-renderer-stylus --save 启动项目在根目录终端中输入（简称三连） 1.清除指令 1hexo clean 2.编译指令 1hexo g 3.运行指令 1hexo s 其中编译和运行可以写为一个，这样就不用输入两次了，清除操作只有出bug的时候可以用用，不用每次都用 1hexo g&amp;hexo s 添加首页菜单打开主题配置文件搜索 menu内容如下 12345678910menu: # Home: / || fas fa-home # Archives: /archives/ || fas fa-archive # Tags: /tags/ || fas fa-tags # Categories: /categories/ || fas fa-folder-open # List||fas fa-list: # Music: /music/ || fas fa-music # Movie: /movies/ || fas fa-video # Link: /link/ || fas fa-link # About: /about/ || fas fa-heart 自行修改 12345678910menu: 首页: / || fas fa-home 时间轴: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 娱乐||fas fa-list: 音乐: /music/ || fas fa-music 电影: /movies/ || fas fa-video 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart 注意缩进 主页菜单居中在themes\\butterfly\\source\\css\\custom.css中添加如下内容（如果没有目录创建目录） 123456789101112131415/* 一级菜单居中 */#nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important; &#125; /* 子菜单横向展示 */ #nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important; &#125; /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */ .menus_items .menus_item:nth-child(2) .menus_item_child &#123; left: -125px; &#125; 找到主题配置文件搜索inject导入该css文件 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; 设置背景（一图流为例）在themes\\butterfly\\source\\css\\custom.css中添加如下内容（如果没有目录创建目录） 1234567891011121314151617181920212223/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125; /* /* 白天模式遮罩透明#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125; *//* 夜间模式遮罩透明 *//* [data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; */ 可以按照自己喜好进行选择取消注释 在主题配置文件中搜索background,更改图片 在线图片1background: url(www.example.com)#修改自己图片的网站 本地文件在themes\\butterfly\\source\\img下放入要使用的背景图 1background: url(/img/3.jpg)#填你自己的图片名称 开启动画（选择）找到主题配置文件 12# 加载动画 Loading Animationpreloader: true markdown文档头部说明 写法 解释 title 【必需】页面标题 date 【必需】页面创建日期 type(仅仅部分文件需要) 【必需】仅仅标籤、分类和友情链接三个页面需要配置 updated 【可选】页面更新日期 description 【可选】页面描述 keywords 【可选】页面关键字 comments 【可选】显示页面评论模块(默认 true) top_img 【可选】页面顶部图片 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) kates 【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false) aside 【可选】显示侧边栏 (默认 true) aplayer 【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置 highlight_shrink 【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置) 新增页面用于存放页面，现在的标签和分类是打不开的，需要自己创建 停止项目 1hexo new page ****(要创建的页面，根据主页菜单来进行选择) 如（这里是菜单） 12345678910menu: 首页: / || fas fa-home 时间轴: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 娱乐||fas fa-list: 音乐: /music/ || fas fa-music 电影: /movies/ || fas fa-video 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart 要创建分类 1hexo new page categories 这样会在source\\下创建了一个md文件 新增 1type: categories 这样，一个分类页面就做好了，以此类推。 开启显示文章描述，有利于页面更加简洁找到theme主题 配置项index_post_content将method改为2（显示描述）或3（显示文章内容），想要更加简洁的话可以使用2 首页打字效果12345678910111213141516171819subtitle: enable: true # Typewriter Effect (打字效果) effect: true # Customize typed.js (配置typed.js) # https://github.com/mattboldt/typed.js/#customization typed_option: # source 調用第三方服務 # source: false 關閉調用 # source: 1 調用一言網的一句話（簡體） https://hitokoto.cn/ # source: 2 調用一句網（簡體） https://yijuzhan.com/ # source: 3 調用今日詩詞（簡體） https://www.jinrishici.com/ # subtitle 會先顯示 source , 再顯示 sub 的內容 source: false # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字 sub: -*********** -*********** 按照格式设置即可 更改头像在线头像 123avatar: img: https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png effect: false 本地头像 123avatar: img: /img/2.jpg effect: false 与背景图同理 文章置顶 你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。 图片懒加载新增hexo-lazyload-image模块 1npm install hexo-lazyload-image --save 在站点配置文件_config.yml增加配置 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost: 是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片.loadingImg - 图片未加载时的代替图不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \\themes ext\\source\\images 目录下, 然后引用时: loadingImg: &#x2F;images&#x2F;图片文件名 增加PDF阅读器1npm install --save hexo-pdf 将PDF放入md文件对应的资源文件夹在md文件中插入 1&#123;% pdf 1.pdf %&#125; 魔改魔改鼠标 新建文件[BlogRoot]\\source\\js\\cursor.js，在里面写上如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var CURSOR;Math.lerp = (a, b, n) =&gt; (1 - n) * a + n * b;const getStyle = (el, attr) =&gt; &#123; try &#123; return window.getComputedStyle ? window.getComputedStyle(el)[attr] : el.currentStyle[attr]; &#125; catch (e) &#123;&#125; return &quot;&quot;;&#125;;class Cursor &#123; constructor() &#123; this.pos = &#123;curr: null, prev: null&#125;; this.pt = []; this.create(); this.init(); this.render(); &#125; move(left, top) &#123; this.cursor.style[&quot;left&quot;] = `$&#123;left&#125;px`; this.cursor.style[&quot;top&quot;] = `$&#123;top&#125;px`; &#125; create() &#123; if (!this.cursor) &#123; this.cursor = document.createElement(&quot;div&quot;); this.cursor.id = &quot;cursor&quot;; this.cursor.classList.add(&quot;hidden&quot;); document.body.append(this.cursor); &#125; var el = document.getElementsByTagName(&#x27;*&#x27;); for (let i = 0; i &lt; el.length; i++) if (getStyle(el[i], &quot;cursor&quot;) == &quot;pointer&quot;) this.pt.push(el[i].outerHTML); document.body.appendChild((this.scr = document.createElement(&quot;style&quot;))); // 这里改变鼠标指针的颜色 由svg生成 this.scr.innerHTML = `* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;.5&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;`; &#125; refresh() &#123; this.scr.remove(); this.cursor.classList.remove(&quot;hover&quot;); this.cursor.classList.remove(&quot;active&quot;); this.pos = &#123;curr: null, prev: null&#125;; this.pt = []; this.create(); this.init(); this.render(); &#125; init() &#123; document.onmouseover = e =&gt; this.pt.includes(e.target.outerHTML) &amp;&amp; this.cursor.classList.add(&quot;hover&quot;); document.onmouseout = e =&gt; this.pt.includes(e.target.outerHTML) &amp;&amp; this.cursor.classList.remove(&quot;hover&quot;); document.onmousemove = e =&gt; &#123;(this.pos.curr == null) &amp;&amp; this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = &#123;x: e.clientX - 8, y: e.clientY - 8&#125;; this.cursor.classList.remove(&quot;hidden&quot;);&#125;; document.onmouseenter = e =&gt; this.cursor.classList.remove(&quot;hidden&quot;); document.onmouseleave = e =&gt; this.cursor.classList.add(&quot;hidden&quot;); document.onmousedown = e =&gt; this.cursor.classList.add(&quot;active&quot;); document.onmouseup = e =&gt; this.cursor.classList.remove(&quot;active&quot;); &#125; render() &#123; if (this.pos.prev) &#123; this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15); this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15); this.move(this.pos.prev.x, this.pos.prev.y); &#125; else &#123; this.pos.prev = this.pos.curr; &#125; requestAnimationFrame(() =&gt; this.render()); &#125;&#125;(() =&gt; &#123; CURSOR = new Cursor(); // 需要重新获取列表时，使用 CURSOR.refresh()&#125;)(); 其中比较重要的参数就是鼠标的尺寸和颜色，已经在上图中标出，目前发现颜色只支持RGB写法和固有名称写法（例如red这种），其他参数也可以自行摸索： 1* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;1.0&#x27; fill=&#x27;rgb(57, 197, 187)&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;` 在[BlogRoot]\\source\\css\\custom.css添加如下代码： 123456789101112131415161718192021222324252627282930313233343536/* 鼠标样式 */#cursor &#123; position: fixed; width: 16px; height: 16px; /* 这里改变跟随的底色 */ background: var(--theme-color); border-radius: 8px; opacity: 0.25; z-index: 10086; pointer-events: none; transition: 0.2s ease-in-out; transition-property: background, opacity, transform;&#125;#cursor.hidden &#123; opacity: 0;&#125;#cursor.hover &#123; opacity: 0.1; transform: scale(2.5); -webkit-transform: scale(2.5); -moz-transform: scale(2.5); -ms-transform: scale(2.5); -o-transform: scale(2.5);&#125;#cursor.active &#123; opacity: 0.5; transform: scale(0.5); -webkit-transform: scale(0.5); -moz-transform: scale(0.5); -ms-transform: scale(0.5); -o-transform: scale(0.5);&#125; 这里比较重要的参数就是鼠标跟随的圆形颜色，可以根据自己的喜好进行更改： 1234#cursor &#123; /* 这里改变跟随的底色 */ background: rgb(57, 197, 187);&#125; 在主题配置文件_config.butterfly.yml文件的inject配置项引入刚刚创建的css文件和js文件： 12345inject: head: + - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; bottom:+ - &lt;script defer src=&quot;/js/cursor.js&quot;&gt;&lt;/script&gt; 重启项目即可看见效果： 12BASHhexo cl; hexo s 友链制作1.通过命令创建友链页面 1hexo new page link 2.在[Blogroot]\\source\\link\\index.md 中添加内容 12345---title: linkdate: 2020-12-01 22:19:45type: &#x27;link&#x27;--- 3.新建文件[Blogroot]\\source\\_data\\link.yml没有_data文件夹的话也请自己新建;输入（以安知鱼为列） 12345678- class_name: 推荐博客 flink_style: flexcard link_list: - name: 安知鱼`Blog link: https://blog.anheyu.com/ avatar: https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg descr: 生活明朗，万物可爱 siteshot: https://npm.elemecdn.com/anzhiyu-theme-static@1.1.6/img/blog.anheyu.com.jpg 页脚 首先要卸载店长的hexo-butterfly-footer-beautify插件，因为我将页脚直接写成一个pug，个人觉得插件很多冗余的地方用不到，因此卸载了，否则会冲突： 1npm un hexo-butterfly-footer-beautify --save 在主题配置文件_config.butterfly.yml或者站点配置文件_config.yml删除插件相关的配置项： 123456789101112131415161718192021222324252627282930313233343536373839404142DIFF-footer_beautify:- enable:- timer: true # 计时器开关- bdage: true # 徽标开关- priority: 5 #过滤器优先权- enable_page: all # 应用页面- exclude: #屏蔽页面- # - /posts/- # - /about/- layout: # 挂载容器类型- type: id- name: footer-wrap- index: 0- runtime_js: https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js- runtime_css: https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css- # 徽标部分配置项- swiperpara: 0 #若非0，则开启轮播功能，每行徽标个数- bdageitem:- - link: https://hexo.io/ #徽标指向网站链接- shields: https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo #徽标API- message: 博客框架为Hexo_v6.2.0 #徽标提示语- - link: https://butterfly.js.org/- shields: https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender- message: 主题版本Butterfly_v4.3.1- - link: https://vercel.com/- shields: https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel- message: 本站采用多线部署，主线路托管于Vercel- - link: https://dashboard.4everland.org/- # https://img.shields.io/badge/Hosted-4EVERLAND-3FE2C1?style=flat&amp;logo=IPFS- shields: https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS- message: 本站采用多线部署，备用线路托管于4EVERLAND- - link: https://github.com/- shields: https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub- message: 本站项目由Github托管- - link: http://creativecommons.org/licenses/by-nc-sa/4.0/- shields: https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris- message: 本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可- swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css- swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js- swiperbdage_init_js: https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js 将[BlogRoot]/themes/butterfly/layout/includes/footer.pug替换成如下代码这块东西分为几个部分，一个是以#ft为块的DOM，其中分为了格言、猜你想看、推荐友链三部分，参考图中的位置结合自己的喜好进行修改即可，图像、文字和链接均替换成你自己的（记住不要用我的链接！！！）；if theme.footer.owner.enable起这一块是主题指定的信息版权信息，我把主题配置项的copyright和custom_text这两项留空了，因此只会显示©2022 By Fomalhaut🥝；再然后就是#workboard这块，这块的信息由js逻辑写入与更新，可以自定义；最后是p#ghbdages这块，是徽标显示，大家可以到shields.io按照自己的信息生成（不要用我的！！！）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109PLAINTEXT复制成功#footer-wrap #ft .ft-item-1 .t-top .t-t-l p.ft-t.t-l-t 格言🧬 .bg-ad div | 再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨ .btn-xz-box a.btn-xz(href=&#x27;https://stellarium.org/&#x27;) 点击开启星辰之旅 .t-t-r p.ft-t.t-l-t 猜你想看💡 ul.ft-links li a(href=&#x27;/posts/eec9786.html&#x27;) 魔改指南 a(href=&#x27;/box/nav/&#x27;) 网址导航 li a(href=&#x27;/social/link/&#x27;) 我的朋友 a(href=&#x27;/comments/&#x27;) 留点什么 li a(href=&#x27;/personal/about/&#x27;) 关于作者 a(href=&#x27;/archives/&#x27;) 文章归档 li a(href=&#x27;/categories/&#x27;) 文章分类 a(href=&#x27;/tags/&#x27;) 文章标签 li a(href=&#x27;/box/Gallery/&#x27;) 我的画廊 a(href=&#x27;/personal/bb/&#x27;) 我的唠叨 li a(href=&#x27;/site/time/&#x27;) 建设进程 a(href=&#x27;/site/census/&#x27;) 网站统计 .ft-item-2 p.ft-t 推荐友链⌛ .ft-img-group .img-group-item a(href=&#x27;https://www.fomal.cc/&#x27; title=&#x27;Fomalhaut🥝&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://tzy1997.com/&#x27; title=&#x27;唐志远の博客&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/4ab83cdce942463b.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://akilar.top/&#x27; title=&#x27;Akilarの糖果屋&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/6bf1ed05796db59c.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://butterfly.js.org/&#x27; title=&#x27;Butterfly&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/64cc6a7d508026e1.png&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://anzhiy.cn/&#x27; title=&#x27;安知鱼&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/1b33fef8f5fb7e63.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://www.acozycotage.net/&#x27; title=&#x27;Acozycotage&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/6a6fe6ebfd19c465.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://cdn.netdun.net/&#x27; title=&#x27;网盾星球&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/70dee3f9d1ca10f3.webp&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;javascript:void(0)&#x27; title=&#x27;广告位招租&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp&#x27; alt=&#x27;&#x27;) if theme.footer.owner.enable - var now = new Date() - var nowYear = now.getFullYear() if theme.footer.owner.since &amp;&amp; theme.footer.owner.since != nowYear .copyright span!= `&lt;b&gt;©$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125;&lt;/b&gt;` span!= `&lt;b&gt; By $&#123;config.author&#125;&lt;/b&gt;` else .copyright span!= `&lt;b&gt;©$&#123;nowYear&#125;&lt;/b&gt;` span!= `&lt;b&gt; By $&#123;config.author&#125;&lt;/b&gt;` if theme.footer.copyright .framework-info span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27; a(href=&#x27;https://hexo.io&#x27;)= &#x27;Hexo&#x27; span.footer-separator | span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27; a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= &#x27;Butterfly&#x27; if theme.footer.custom_text .footer_custom_text!=`$&#123;theme.footer.custom_text&#125;` #workboard p#ghbdages a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://hexo.io/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;博客框架为Hexo_v6.3.0&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://butterfly.js.org/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;主题版本Butterfly_v4.3.1&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://vercel.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站采用多线部署，主线路托管于Vercel&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://user.51.la/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站数据分析得益于51la技术支持&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://icp.gov.moe/?keyword=20226665&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站已加入萌ICP豪华套餐，萌ICP备20226665号&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://bitiful.dogecast.com/buckets&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站经Service Worker分流至缤纷云对象存储&quot;) img(src=&quot; https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://www.netdun.net/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站使用网盾星球提供CDN加速与防护&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://github.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站源码由Github提供存储仓库&quot;) img(src=&quot; https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg&quot; alt=&#x27;&#x27;) 将以下代码复制到自定义的custom.css中，其中颜色、圆角等可以根据你自己的喜好进行修改: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246/* tzy页脚样式 */#ft &#123; max-width: 1200px; margin: 0 auto 12px; display: flex; color: rgb(255 255 255 / 80%) !important; text-align: left; flex-wrap: wrap;&#125;.ft-item-1,.ft-item-2 &#123; display: flex; height: 100%; padding: 2px 14px;&#125;.ft-item-1 &#123; flex-direction: column; flex: 2;&#125;.ft-item-2 &#123; flex: 1; flex-direction: column;&#125;.t-top &#123; display: flex;&#125;.t-top .t-t-l &#123; display: flex; flex-direction: column; flex: 1.4; margin-right: 10px;&#125;.t-top .t-t-l .bg-ad &#123; width: 85%; border-radius: 10px; padding: 0 10px;&#125;.btn-xz-box &#123; margin-top: 10px;&#125;/* 按钮背景颜色等 */.btn-xz &#123; display: block; background-color: var(--btn-bg); color: var(--btn-color); text-align: center; line-height: 2.4; margin: 8px 0;&#125;.btn-xz:hover &#123; text-decoration: none !important;&#125;/* 按钮悬浮颜色 */.btn-xz-box:hover .btn-xz &#123; background-color: var(--text-bg-hover);&#125;.t-top .t-t-r &#123; display: flex; flex-direction: column; flex: 1;&#125;.ft-links &#123; padding: 0 14px; list-style: none; margin-top: 0 !important;&#125;.ft-links li a &#123; display: inline-block !important; width: 50%;&#125;/* 链接悬浮颜色 */.ft-links li a:hover &#123; text-decoration: none !important; color: var(--theme-color) !important;&#125;.ft-item-2 .ft-img-group &#123; width: 100%;&#125;.ft-t &#123; font-size: 1.1rem; margin-bottom: 20px; line-height: 1; font-weight: 600;&#125;.t-l-t &#123; padding-left: 14px;&#125;.ft-item-2 .ft-img-group .img-group-item &#123; display: inline-block; width: 18.4%; margin-right: 14px; margin-bottom: 6px;&#125;.ft-item-2 .ft-img-group .img-group-item a &#123; display: inline-block; width: 100%; height: 100%;&#125;.ft-item-2 .ft-img-group .img-group-item a img &#123; width: 100%; max-height: 80px; border-radius: 10px;&#125;/* 头像悬浮颜色框 */.ft-item-2 .ft-img-group .img-group-item a img:hover &#123; border: 2px solid var(--theme-color);&#125;@media screen and (max-width: 768px) &#123; .ft-item-1 &#123; flex-basis: 100% !important; &#125; .ft-item-2 &#123; flex-basis: 100% !important; &#125; .t-top .t-t-l .bg-ad &#123; width: 100%; &#125;&#125;@media screen and (max-width: 576px) &#123; .t-top &#123; flex-wrap: wrap; &#125; .t-top .t-t-l &#123; flex-basis: 100% !important; &#125; .t-top .t-t-r &#123; margin-top: 16px; flex-basis: 100% !important; &#125;&#125;#footer-wrap a &#123; border-radius: 30px;&#125;#footer-wrap &#123; padding: 20px 20px;&#125;/* 页脚心跳动画 */#heartbeat &#123; color: red; animation: iconAnimate 1s ease-in-out infinite;&#125;@-moz-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@-webkit-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@-o-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125; 然后计时器还要往#footer-wrap这块元素上面写入网站运行时间等信息，新建文件[BlogRoot]\\source\\js\\runtime.js，写入如下代码。这里要修改的几块东西是：网站诞生时间、currentTimeHtml这块东西；其中currentTimeHtml分为了两种模式，对应两个不同的图标，自行研究一下就懂！ 123456789101112131415161718192021222324252627282930313233JS复制成功var now = new Date();function createtime() &#123; // 当前时间 now.setTime(now.getTime() + 1000); var start = new Date(&quot;08/01/2022 00:00:00&quot;); // 旅行者1号开始计算的时间 var dis = Math.trunc(23400000000 + ((now - start) / 1000) * 17); // 距离=秒数*速度 记住转换毫秒 var unit = (dis / 149600000).toFixed(6); // 天文单位 var grt = new Date(&quot;08/09/2022 00:00:00&quot;);\t// 网站诞生时间 var days = (now - grt) / 1e3 / 60 / 60 / 24, dnum = Math.floor(days), hours = (now - grt) / 1e3 / 60 / 60 - 24 * dnum, hnum = Math.floor(hours); 1 == String(hnum).length &amp;&amp; (hnum = &quot;0&quot; + hnum); var minutes = (now - grt) / 1e3 / 60 - 1440 * dnum - 60 * hnum, mnum = Math.floor(minutes); 1 == String(mnum).length &amp;&amp; (mnum = &quot;0&quot; + mnum); var seconds = (now - grt) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum, snum = Math.round(seconds); 1 == String(snum).length &amp;&amp; (snum = &quot;0&quot; + snum); let currentTimeHtml = &quot;&quot;; (currentTimeHtml = hnum &lt; 18 &amp;&amp; hnum &gt;= 9 ? `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://sourcebucket.s3.ladydaily.com/badge/F小屋-科研摸鱼中.svg&#x27; title=&#x27;什么时候能够实现财富自由呀~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt;本站居然运行了 $&#123;dnum&#125; 天 $&#123;hnum&#125; 小时 $&#123;mnum&#125; 分 $&#123;snum&#125; 秒 &lt;i id=&quot;heartbeat&quot; class=&#x27;fas fa-heartbeat&#x27;&gt;&lt;/i&gt; &lt;br&gt; 旅行者 1 号当前距离地球 $&#123;dis&#125; 千米，约为 $&#123;unit&#125; 个天文单位 🚀&lt;/div&gt;` : `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg&#x27; title=&#x27;下班了就该开开心心地玩耍~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt;本站居然运行了 $&#123;dnum&#125; 天 $&#123;hnum&#125; 小时 $&#123;mnum&#125; 分 $&#123;snum&#125; 秒 &lt;i id=&quot;heartbeat&quot; class=&#x27;fas fa-heartbeat&#x27;&gt;&lt;/i&gt; &lt;br&gt; 旅行者 1 号当前距离地球 $&#123;dis&#125; 千米，约为 $&#123;unit&#125; 个天文单位 🚀&lt;/div&gt;`), document.getElementById(&quot;workboard&quot;) &amp;&amp; (document.getElementById(&quot;workboard&quot;).innerHTML = currentTimeHtml);&#125;// 设置重复执行函数，周期1000mssetInterval(() =&gt; &#123; createtime();&#125;, 1000); 在主题配置文件_config.butterfly.yml引入该runtime.js文件： 1234DIFFinject: bottom: + - &lt;script defer src=&quot;/js/runtime.js&quot;&gt;&lt;/script&gt; # 页脚计时器 到这里你已经成功了 99.99%，最后重新编译运行即可看见效果 12BASHhexo cl; hexo s 添加图片1.1.找到Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true 2.在Hexo目录下打开Git Brsh，执行一个下载上传图片插件的命令npm install https://github.com/CodeFalling/hexo-asset-image(bug,插件bug) 3.继续在Git Brsh下利用hexo n “xxxx”来生成md的文件（” “里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。 4.在.md的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。 设置代码默认长度在主题配置文件中修改highlight_height_limit 后面数字为像素px 一图流 在[BlogRoot]\\source文件夹下新建一个文件夹css，该文件夹用于存放自定义的css样式，再新建一个名为custom.css，在里面写入以下代码： 123456789101112131415161718192021222324/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125;/* 白天模式遮罩透明 */#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125;/* 夜间模式遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; 在主题配置文件[BlogRoot]\\_config.butterfly.yml文件中的inject配置项的head子项加入以下代码，代表引入刚刚创建的custom.css文件（这是相对路径的写法） 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 在主题配置文件[BlogRoot]\\_config.butterfly.yml文件中的index_img和footer_bg配置项取消头图与页脚图的加载项避免冗余加载 12345# The banner image of home pageindex_img: # Footer Backgroundfooter_bg: false 部分人反映一图流改完了背景图也没了，那大概率是你之前没设置背景图。在主题配置文件[BlogRoot]\\_config.butterfly.yml文件中的background配置项设置背景图 1background: url(https://source.fomal.cc/img/home_bg.webp) 文章页面侧面菜单只保留目录在主题配置文件中将style_simple改为true 主页导航栏居中123456789101112131415 /* 一级菜单居中 */#nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important; &#125; /* 子菜单横向展示 */ #nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important; &#125; /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */ .menus_items .menus_item:nth-child(2) .menus_item_child &#123; left: -125px; &#125; 设置文章标题居中找到themes\\butterfly\\source\\css\\_layout\\head.styl目录，修改post-info 123456#post-info position: absolute bottom: 120px padding: 0 8% width: 100% text-align: center 修改字体大小在主题配置文件中font设置 将文章栏目改为双栏 在博客根目录[BlogRoot]下打开终端，运行以下指令： 1npm i hexo-butterfly-article-double-row --save 在网站配置文件_config.yml新增以下项 (注意不是主题配置文件)： 12butterfly_article_double_row: enable: true 这时候插件有个bug，就是最后一页文章数目为奇数的时候，会出现这种情况 会显得很不舒服，感谢唐志远大佬修复了这个bug，只需要在custom.css文件添加以下代码即可： 12345/* 翻页按钮居中 */#pagination &#123; width: 100%; margin: auto;&#125; 执行 hexo 三连： 123hexo cleanhexo ghexo s 首页分类（未成功）效果预览 安装插件,在博客根目录[BlogRoot]下打开终端，运行以下指令： 1npm install hexo-butterfly-categories-card --save 添加配置信息，以下为写法示例在站点配置文件_config.yml或者主题配置文件_config.butterfly.yml中添加以下代码，注意要根据他的默认描述排序改为你自己对应的分类名字： 1234567891011121314151617181920212223242526# hexo-butterfly-categories-card# see https://akilar.top/posts/a9131002/categoryBar: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: / # 应用页面 layout: # 挂载容器类型 type: id name: recent-posts index: 0 column: odd # odd：3列 | even：4列 row: 1 #显示行数，默认两行，超过行数切换为滚动显示 message: - descr: Ubuntu指南 cover: https://assets.akilar.top/image/cover1.webp - descr: 玩转Win10 cover: https://assets.akilar.top/image/cover2.webp - descr: 长篇小说连载 cover: https://assets.akilar.top/image/cover3.webp - descr: 个人日记 cover: https://assets.akilar.top/image/cover4.webp - descr: 诗词歌赋 cover: https://assets.akilar.top/image/cover5.webp - descr: 杂谈教程 cover: https://assets.akilar.top/image/cover6.webp custom_css: https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css 参数释义 参数 备选值&#x2F;类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）,如根目录就填’&#x2F;‘,分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为’&#x2F;‘ layout.type id&#x2F;class 【可选】挂载容器类型，填写id或class，不填则默认为id layout.name text 【必选】挂载容器名称 layout.index 0和正整数 【可选】前提是layout.type为class，因为同一页面可能有多个class，此项用来确认究竟排在第几个顺位 column odd&#x2F;even 【可选】显示列数，考虑到比例问题，只提供3列和4列，odd为3列， even为4列 row number 【可选】显示行数，默认两行，超过行数切换为滚动显示 message.descr text 分类描述,需要和你自己的文章分类一一对应。 message.cover url 分类背景,需要和你自己的文章分类一一对应。 custom_css url 【可选】自定义样式，会替换默认的css链接，可以下载文档给出的cdn链接后自主修改 置顶文章并且滚动 安装插件,在博客根目录[BlogRoot]下打开终端，运行以下指令： 1npm install hexo-butterfly-swiper --save 添加配置信息，以下为写法示例在站点配置文件_config.yml或者主题配置文件_config.butterfly.yml中添加 12345678910111213141516# hexo-butterfly-swiper# see https://akilar.top/posts/8e1264d1/swiper: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 timemode: date #date/updated layout: # 挂载容器类型 type: id name: recent-posts index: 0 default_descr: 再怎么看我也不知道怎么描述它的啦！ swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖 swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖 custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁 custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法 参数释义 参数 备选值&#x2F;类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）,如根目录就填’&#x2F;‘,分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为all timemode date&#x2F;updated 【可选】时间显示，date为显示创建日期，updated为显示更新日期,默认为date layout.type id&#x2F;class 【可选】挂载容器类型，填写id或class，不填则默认为id layout.name text 【必选】挂载容器名称 layout.index 0和正整数 【可选】前提是layout.type为class，因为同一页面可能有多个class，此项用来确认究竟排在第几个顺位 default_descr text 默认文章描述 swiper_css url 【可选】自定义的swiper依赖项css链接 swiper_js url 【可选】自定义的swiper依赖项加js链接 custom_css url 【可选】适配主题样式补丁 custom_js url 【可选】swiper初始化方法 使用方法:在文章的front_matter中添加swiper_index配置项即可。 123456789MARKDOWN---title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前--- PDF插件 安装hexo-pdf插件 1npm install hexo-pdf --save 外挂标签的引用格式如下： 标签语法 参数配置 示例源码 1234# 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件&#123;% pdf xxx.pdf %&#125;# 2.在线链接&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125; 重启项目即可看到变更 1hexo cl; hexo s 修改页脚修改页脚内容themes\\butterfly\\layout\\includes\\footer.pug 修改样式themes\\butterfly\\source\\css\\custom.css 修改运行时间themes\\butterfly\\source\\js\\runtime.js CDN直接更换cdn链接即可 更改配置项 链接我这里只列出我在用的cdn，我没有用到的cdn可以在评论中留言，有时间我会补充。 jquery 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js pjax 1https://lib.baomitu.com/pjax/0.2.8/pjax.min.js sharejs 12https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.jshttps://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css gittalk 12gitalk: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.jsgitalk_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css valine 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.16/Valine.min.js disqusjs 123disqusjs: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/disqusjs/1.3.0/disqus.jsdisqusjs_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/disqusjs/1.3.0/disqusjs.css twikoo（这个是定制版） 1https://cdn1.tianli0.top/npm/js-heo@1.0.3/twikoo/twikoo.all.min.js twikoo（官方版） 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js waline 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/waline/1.5.4/Waline.min.js algolia 123algolia_js: https://cdn1.tianli0.top/npm/js-heo@1.0.11/algolia/algolia.jsalgolia_search: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/instantsearch.js/2.10.5/instantsearch.min.jsalgolia_search_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/instantsearch.js/2.10.5/instantsearch.min.css lazyload 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js instantpage 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js typed 1https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js fancybox 12fancybox_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.cssfancybox: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js medium_zoom 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/medium-zoom/1.0.6/medium-zoom.min.js snackbar 12snackbar_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.csssnackbar: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js fontawesome 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css translate 1https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js aplayer 123aplayer_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.cssaplayer_js: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.jsmeting_js: https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js Prism 123prismjs_js: https://cdn1.tianli0.top/npm/prismjs@1.1.0/prism.jsprismjs_lineNumber_js: https://cdn1.tianli0.top/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.jsprismjs_autoloader: https://cdn1.tianli0.top/npm/prismjs/plugins/autoloader/prism-autoloader.min.js justifiedGallery 12justifiedGallery_js: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.jsjustifiedGallery_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/css/justifiedGallery.min.css CDN选择原则优先使用字节跳动的cdn，如果没有则使用elemecdn。 个人社交资料在themes\\butterfly\\_config.yml中修改内容，社交图标https://fontawesome.com/ 网站图表头像修改首页打字机文字subtitle 图床1.基于Github仓库的图床优点： 很稳定不会跑路，用的是自己的仓库和公共托管平台 图片可以增量快速更新和跨设备管理 可以进行版本管理和查看之前的版本 有公共CDN，速度还是不错的 资源格式可以任意都行，包括css、js等 缺点： 每个仓库限制1G，超过要新建另一个仓库 git管理可能偶尔会遇到网络和公钥失效问题 1.1 建立Github仓库 进入Github官网注册并登录自己的账号，到自己的个人主页，点击右上角的+，并选择New Repository创建自己的仓库。 仓库名字随意，描述也可以自由发挥，可见性最好选public，Readme文件可以创建，然后点击Create Repository创建仓库。 让你的计算机与Github建立通信，这部分可以参考Hexo 博客搭建基础教程 (一)的第7点，主要是创建公钥、上传公钥、检查通信这几步，确保计算机有权限访问远程仓库，所述教程是用的RSA公钥，目前更推荐ed25519公钥，该数字签名算法的签名和验证的性能都极⾼，具体教程百度这里不再赘述。 先在本地创建一个文件夹，文件夹位置和名字随意就可以，进入该文件夹后右键打开Git Bash，然后输入以下代码把之前创建的仓库拷贝下来，其中git clone后面的东西要替换成自己的仓库信息，可以通过自己仓库的ssh链接来获取。 12BASHgit clone git@github.com:fomalhaut1998/pic_bed.git 看到上图的信息就代表成功把整个仓库拷贝到当前文件夹了，此时我们可以看见自己的文件夹多了个.git文件夹和Readme.md文件，这就代表成功了。 此时我们最好在这个文件夹里面创建创建一个img文件夹专门存放图片，如果有存放其他类型资源的可以创建别的文件夹，比如现在想往仓库里加两张图，直接就把图片复制到img文件夹里面即可。 然后在带有Readme.md文件的那个文件夹内，右键打开Git Bash（注意看清楚是什么文件夹），然后依次输入以下命令把更改推送到远程仓库，最后一步不成功可能要多试几次。 123456BASH# 将更改提交git add .git commit -m &quot;更新图片&quot;# 推送至github仓库git push 最后看见如下信息就代表推送成功了 仓库此时应该也有了刚刚上传的资源了 下次增删图片或者其他东西，就这样照猫画虎就可以推上来更新仓库！ 1.2 Staticaly CDN加速直接访问Github仓库的资源是非常慢的！因此我们要用一些免费的CDN进行加速，Staticaly CDN是目前免费CDN中比较好用的啦，他的应用规则如下： 123456PLAINTEXT# 格式 其中 user是用户名 repo是仓库名 version代表版本(tag或者分支 默认为main) flie是文件路径 https://cdn.staticaly.com/gh/user/repo@version/file# 比如我的示例仓库就是加速地址就是这个大家可以参考参考https://cdn.staticaly.com/gh/fomalhaut1998/pic_bed@main/img/p2.webp 1.3 Vercel 部署此方法加载速度较快，但是需要域名自定义绑定，其优点也是可以绑定自定义域了，目前Vercel每个月限制流量100GB 进入Vercel控制面板新建项目，并通过Github继续，选择导入刚刚创建的仓库，然后直接部署即可 进入该项目控制台后，选择右上角的View Domains添加新的域名，添加一个自己域名的二级域名，然后在你对应的域名解析控制台添加对应解析，等待生效。 通过自定义域名+资源路径即可访问到对应的资源，例如我这里为https://picbed.fomal.cc/img/p1.webp 要更新图片怎么办？只要将资源复制到对应的文件夹，然后再执行一次下面的命令即可： 123456BASH# 将更改提交git add .git commit -m &quot;更新图片&quot;# 推送至github仓库git push 这个命令默认是更新到仓库的main分支上，Vercel一旦检测到main分支发送变化就会触发新一轮部署，我们稍候片刻即可通过新的路径访问到新的资源。 1.4 Cloudflare 部署此方法速度比Vercel稍慢，但是可以不需要域名，目前我就在用这个，而且CloudFlare对于普通用户来说几乎不限量了 进入Cloudflare官网注册并登录自己的账号，然后进入控制台后选择左边的Pages，再创建一个新项目并通过Git进行连接，所有参数默认直接部署。 通过给出的初始域名+资源路径即可访问到的对应资源，例如我这个就是pic-bed-c6s.pages.dev/img/p1.webp，当然你也可以绑定自定义域名使用。 2.免费图床推荐 这部分免费图床就太多了，我会把我目前发现的可以免费白嫖一定额度的图床做一个总结列在下面 这部分图床的搭建门槛较低，所以速度和稳定性良莠不齐，大家自行选择使用哪个 我这里只给大家演示一种的使用方法，其他图床使用方法也类似 大家可以看看哪个比较好用的或者自己知道的好用的这里没有，可以留言我会进行补充 🍕 🥗 🍤 SMMS 聚合图床 遇见图床 PostImage 路过图床 imgURL imgbox Lsky Pro Upload.cc imagelol imgtp 云图床 载涂图床 Sky Chart Bed 风筝图床 喷子图床 imgkb 使用方法：直接进入官网，上传图片然后粘贴地址即可，地址的样式有多样，自行选择。 选择要点： 速度：大家可以到Ping.cn进行测试 稳定性与安全性：看看图床创建时间，网上评价等 可适用性：支持的格式越多肯定是越好的，有部分支持webp和其他格式的，可以当资源床 3.PicGo结合Markdown实时上传图片 Picgo究竟是什么？这是一个开源软件，开源地址：Molunerfinn&#x2F;PicGo 引用项目的介绍：这是一个用于快速上传图片并获取图片 URL 链接的工具，关键是他可以与Typora配套一起使用，在粘贴图片的同时上传图片，十分方便！ 最新版我这里实测没办法安装一些插件，因此推荐大家安装v2.3.1-beta.5这个版本 下载软件后直接一路安装下去就行，建议装在非C盘的任意一个盘。 3.1 Github图床 进入软件之后，一路到设置里面取消勾选其他图床，只留下Github图床一项，因为我们的现在要弄Github图床。 然后到Github新建一个仓库，创建仓库的教程前面有讲，这里就不赘述了，仓库名字和描述随意，最重要的是权限一定要选public，这样你的图片才可以随时随地访问到。在图床设置的Github配置处，按照下图填入对应的信息： 自定义域名的格式为：https://cdn.staticaly.com/gh/用户名/仓库名@main，比如我的就是https://cdn.staticaly.com/gh/fomalhaut1998/markdown_pic@main，对应的用户名和仓库名记住要换成自己名字，不能有空格！！！ Token的获取方式为：右上角头像-&gt;Setting-&gt;左边栏Developer Settings-&gt;左栏Personal access tokens-&gt;左栏tokens(classic) 创建Token时，Note随意；Exporation选No expiration，Select scopes必须把repo这一项勾上，然后点击生成就行 这个时候必须马上复制出现的token，不然后面就看不到了，复制了填进去刚刚的Token选项，随后点击确定保存 随便拖拽一张图片进来上传区域这里，应该就可以上传成功，随后把生成的链接复制就可以，此时打开仓库可以发现图片上传到了指定的文件夹。注意：每个仓库大小限制是1G！！！ 3.2 Vika图床Vika图床的服务器在国内，速度是比较快的 首先在Picgo里面安装Vikadata的插件 我们要填的信息有下面这几项： 进入维格表官网，注册自己的账号并登录，新建一个空白的维格表 随后点击左下角头像的个人设置，绑定自己的邮箱后，获取API Token 进入刚刚创建的表格后，点击上边的API，进入API界面后，依次点击显示API Token-&gt;Get 获取，然后图中框起来的就是我们需要的维格表ID和API Token 填进去对应位置后，到上传区域，把图床换成维格表，试试拖拽图片能不能上传！ 3.3 Bilibili图床 由于这个图床用在博客里存在跨域问题，因此不再推荐使用了，开源地址：typora-plugin-bilibili 如需了解使用教程，见视频教程第12期：免费图床综合教程（二） 3.4 imgtp图床 开源地址：picgo-plugin-imgtp 在Picg插件商店搜索并安装该插件 进入imgtp注册并登录自己的账号，记住账号密码，待会儿要用到 进入控制台，然后进入设置，就可以看到右边有Token这一项，这些就是我们要的全部信息 随后在imgtp的配置信息里面填上账号、密码、Token这几项即可 填进去对应位置后，到上传区域，把图床换成维格表，试试拖拽图片能不能上传！","tags":["Hexo"],"categories":["Hexo"]},{"title":"关于作者","path":"/about/index.html","content":"要不断的努力，才能成为更好的自己 ​ ​"}]