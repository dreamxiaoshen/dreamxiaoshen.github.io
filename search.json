[{"title":"elecron","path":"/2024/05/16/elecron/","content":"Electron1.介绍：使用 JavaScript、HTML 和 CSS 构建跨平台桌面应用 2.安装要使用electron，必须安装node.js默认最新版就好 3.创建项目首先利用npm创建一个工程 12mkdir my-electron-app &amp;&amp; cd my-electron-appnpm init 填入信息中，大部分保持默认即可，但以下几项需要修改 entry point应该是main.js author需要填写 现在你的package.json文件内容应该如下 12345678&#123; &quot;name&quot;: &quot;my-electron-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Hello World!&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;author&quot;: &quot;Jane Doe&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 然后，将 electron 包安装到应用的 devDependencies 中。 1npm install --save-dev electron ！！！注意，这个过程大概率会报错 报错信息 1RequestError: connect ECONNREFUSED 127.0.0.1:443 由于默认会从github下载文件，如果你的电脑上不了github会报这个错误 1electon unable to verify the first certificate 由于协议问题，导致下载失败 解决办法在当前项目目录下面新建文件.npmrc 在里面填写以下信息 1ELECTRON_MIRROR=&quot;https://npmmirror.com/mirrors/electron/&quot; 便可以完美解决 4.第一个程序参考官方文档，便可以获得第一个程序开发文档","tags":["桌面程序"],"categories":["桌面程序"]},{"title":"express","path":"/2024/04/14/express/","content":"expressexpress生成器的安装，访问express的中文网，其中有介绍express的安装和入门，现在来安装他吧 对于express而言，其是由nodejs封装api而成，所以需要先装上nodejs，此步省略，打开终端。最好是以管理员身份运行，到达nodejs的安装根目录，对express的安装器进行安装。在cmd窗口输入如下指令 1npm install -g express-generator 再输入 1express 根据提示进行安装，进入项目，安装相关依赖 1npm i 即可生成一个express应用，进入项目可以看到项目的基本结构，找到package.json找到运行脚本 1npm run start 然后就可以在本地3000端口访问express服务了 1.更改端口在app.js中，可以修改端口，只需要在导出前加上代码即可 1process.env.PORT = 80; app.js所有代码 12345678910111213141516171819202122232425262728293031323334353637383940414243var createError = require(&#x27;http-errors&#x27;);var express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);var indexRouter = require(&#x27;./routes/index&#x27;);var usersRouter = require(&#x27;./routes/users&#x27;);var app = express();// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;jade&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.use(&#x27;/&#x27;, indexRouter);app.use(&#x27;/users&#x27;, usersRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);process.env.PORT = 80;module.exports = app; 2.检测代码更改自动重新启动项目安装nodemon 1npm i nodemon 找到启动脚本，在启动脚本前加nodemon --exec 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;nodemon --exec node ./bin/www&quot;&#125;,","tags":["后端"],"categories":["后端"]},{"title":"docker","path":"/2024/04/14/docker/","content":"Docker1.初识Docker基本操作1.拉取镜像1.1去 DockerHub查询镜像1.2通过命令拉取镜像1docker pull nginx 1.3通过命令查看拉取到的镜像1docker images 1.4保存，导入镜像1.4.1保存1docker save -o [保存的目标文件名称] [镜像名称] 1docker save -o nginx.tar nginx:latest 1.4.2删除1docker rmi nginx:latest 1.4.3加载1docker load -i nginx.tar 2.容器操作容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 2.1创建并且运行一个容器创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx，可以加版本，不加默认为最新版 自启动将正在运行的容器设为自启动 1docker update --restart=always 容器名或容器ID 1docker update --restart=always &lt;CONTAINER ID&gt; 例如将tomcat设为自启动1 1docker update --restart=always tomcat 将自启动的容器取消自启动 1docker update --restart=no 容器名或容器ID 1docker update --restart=no &lt;CONTAINER ID&gt; 例如取消tomcat的自启动 1docker update --restart=no tomcat 2.2进入容器，修改文件进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 3数据卷数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 例 创建容器并挂载数据卷到容器内的HTML目录 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 直接挂载到宿主机容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像： 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 2.Docker的安装1.CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。 1.1.卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： 1234567891011yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.2.安装docker首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fast 然后输入命令： 1yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 1.3.启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 12345systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： 1docker -v 如图： 1.4.配置镜像加速docker官方镜像仓库网速较差，我们需要设置国内镜像服务： 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： 12# 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： 12# 修改权限chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：12# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： 1echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： 123456docker run -d \\ --restart=always \\ --name registry\t\\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： 123456789101112131415version: &#x27;3.0&#x27;services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： 12345678# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker 3.Docker的操作3.1.镜像操作3.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 如图： 这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。 3.1.2.镜像命令常见的镜像操作命令如图： 3.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 3.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： 1docker save --help 结果： 命令格式： 1docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： 1docker save -o nginx.tar nginx:latest 结果如图： 3）使用docker load加载镜像 先删除本地的nginx镜像： 1docker rmi nginx:latest 然后运行命令，加载本地文件： 1docker load -i nginx.tar 结果： 3.2.容器操作3.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 3.2.2.案例-创建并运行一个容器创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 3.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： 1cd /usr/share/nginx/html 查看目录下文件： 3）修改index.html的内容 容器内没有vi命令，无法直接修改，我们用下面的命令来修改： 1sed -i -e &#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27; -e &#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27; index.html 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： 3.3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 3.3.1.什么是数据卷数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了 3.3.2.数据集操作命令数据卷操作的基本语法如下： 1docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 3.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 1docker volume create html ② 查看所有数据 1docker volume ls 结果： ③ 查看数据卷详细信息卷 1docker volume inspect html 结果： 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 3.3.4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： 12345docker run \\ --name mn \\ -v html:/root/html \\ -p 8080:80 nginx \\ 这里的-v就是挂载数据卷的命令： -v html:/root/htm ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中 3.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 3.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data 3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf 4）去DockerHub查阅资料，创建并运行MySQL容器，要求： ① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录 ② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件 ③ 设置MySQL密码 4.Dockerfile自定义镜像常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。 而要自定义镜像，就必须先了解镜像的结构才行。 4.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 4.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder 4.3.构建Java项目4.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 其中的内容如下： 12345678910111213141516171819202122# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR=/usr/local# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar /tmp/app.jar 步骤5：进入docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： 1docker build -t javaweb:1.0 . 最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip 4.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将app.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： 1234FROM java:8-alpineCOPY ./app.jar /tmp/app.jarEXPOSE 8090ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 ⑤ 使用docker run创建容器并运行 5.Docker-ComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ 5.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： 1234567891011121314version: &quot;3.8&quot; services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;/tmp/mysql/data:/var/lib/mysql&quot; - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot; web: build: . ports: - &quot;8090:8090&quot; 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 5.2.安装DockerCompose参考课前资料 5.3.部署微服务集群需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署 实现思路： ① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件 ② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名 ③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar ④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中 ⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署 5.3.1.compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录： 内容如下： 123456789101112131415161718192021222324version: &quot;3.2&quot;services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - &quot;8848:8848&quot; mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;$PWD/mysql/data:/var/lib/mysql&quot; - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot; userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - &quot;10010:10010&quot; 可以看到，其中包含5个service服务： nacos：作为注册中心和配置中心 image: nacos/nacos-server： 基于nacos&#x2F;nacos-server镜像构建 environment：环境变量 MODE: standalone：单点模式启动 ports：端口映射，这里暴露了8848端口 mysql：数据库 image: mysql:5.7.25：镜像版本是mysql:5.7.25 environment：环境变量 MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123 volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据 userservice、orderservice、gateway：都是基于Dockerfile临时构建的 查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表： 查看微服务目录，可以看到都包含Dockerfile文件： 内容如下： 123FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar 5.3.2.修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。 如下所示： 1234567891011spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 5.3.3.打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。 可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改： 12345678910&lt;build&gt; &lt;!-- 服务打包的最终名称 --&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打包后： 5.3.4.拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。 user-service： order-service： gateway： 5.3.5.部署最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。 上传到任意目录： 部署： 进入cloud-demo目录，然后运行下面的命令： 1docker-compose up -d 6.Docker镜像仓库6.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 6.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F; 1docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 ② 推送镜像 1docker push 192.168.150.101:8080/nginx:1.0 ③ 拉取镜像 1docker pull 192.168.150.101:8080/nginx:1.0","tags":["后端"],"categories":["后端"]},{"title":"微服务","path":"/2024/04/14/微服务/","content":"","tags":["后端"],"categories":["后端"]},{"title":"前端工具类","path":"/2024/03/31/前端工具类/","content":"1.在vue3项目中使用quill-editor在控制台安装quill 1npm install @vueup/vue-quill@latest --save 在项目中进行导入，这里演示局部导入，也可以进行全局导入 12import &#123; QuillEditor &#125; from &#x27;@vueup/vue-quill&#x27;import &#x27;@vueup/vue-quill/dist/vue-quill.snow.css&#x27; 使用数据 123456&lt;quill-editor theme=&quot;snow&quot; v-model:content=&quot;articleModel.content&quot; contentType=&quot;html&quot; &gt;&lt;/quill-editor&gt; 2.在vue3项目中使用Echarts通过npm安装 1npm install echarts --save 引入 1import * as echarts from &#x27;echarts&#x27;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import &#123;ref, onMounted&#125; from &quot;vue&quot;; const sum = ref(&#123; buildingNumber: &#x27;100&#x27;, residentsNumber: &#x27;888&#x27;, intelligentDevices: &#x27;300&#x27;, alarmNumber: &#x27;20&#x27;&#125;)//房屋数量情况const buildingData = ref([ &#123;value: 335, name: &#x27;毛坯房&#x27;&#125;, &#123;value: 310, name: &#x27;精装修&#x27;&#125;, &#123;value: 234, name: &#x27;简装修&#x27;&#125;, &#123;value: 135, name: &#x27;未卖出&#x27;&#125;,])//报修统计const repairData = ref([ &#123;value: 335, name: &#x27;正在处理&#x27;&#125;, &#123;value: 310, name: &#x27;已修复&#x27;&#125;, &#123;value: 234, name: &#x27;未修复&#x27;&#125;,])const paymentData = ref( &#123; hasPay:[50, 80, 90, 400], noPay:[10,20,30,50] &#125;) //导入图表import * as echarts from &#x27;echarts&#x27;//钩子方法onMounted(() =&gt; &#123; renderChart()&#125;)//表名const building = ref()const repairing = ref()const paying = ref() const renderChart = () =&gt; &#123; let buildingChart = echarts.init(building.value) let repairChart = echarts.init(repairing.value) let payChart = echarts.init(paying.value) //图表自适应 window.addEventListener(&quot;resize&quot;, () =&gt; &#123; buildingChart.resize(); &#125;); window.addEventListener(&quot;resize&quot;, () =&gt; &#123; repairChart.resize(); &#125;); window.addEventListener(&quot;resize&quot;, () =&gt; &#123; payChart.resize(); &#125;); buildingChart.setOption(&#123; title: &#123; text: &#x27;房屋分布&#x27;, left: &#x27;left&#x27; &#125; , /*提示的样式*/ tooltip: &#123; trigger: &#x27;item&#x27;, /* formatter: &#x27;&#123;a&#125; &lt;br/&gt; &#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;*/ &#125; , legend: &#123; orient: &#x27;horizontal&#x27;, bottom: &#x27;10px&#x27;, data: [&#x27;毛坯房&#x27;, &#x27;精装修&#x27;, &#x27;简装修&#x27;, &#x27;未卖出&#x27;] &#125; , label: &#123; show: true, formatter: &#x27;&#123;b&#125;:&#123;c&#125;&#x27; &#125;, series: [ &#123; name: &#x27;装修情况&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, center: [&#x27;50%&#x27;, &#x27;50%&#x27;], data: buildingData.value, emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 5, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125; ) repairChart.setOption(&#123; title: &#123; text: &#x27;报修情况&#x27;, left: &#x27;left&#x27; &#125; , tooltip: &#123; trigger: &#x27;item&#x27;, /*formatter: &#x27;&#123;a&#125; &lt;br/&gt; &#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;*/ &#125;, label: &#123; show: true, formatter:&#x27;&#123;b&#125;: &#123;c&#125;&#x27; &#125;, legend: &#123; orient: &#x27;horizontal&#x27;, bottom: &#x27;10px&#x27;, data: [&#x27;正在处理&#x27;, &#x27;已修复&#x27;, &#x27;未修复&#x27;] &#125; , series: [ &#123; name: &#x27;报修情况&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, center: [&#x27;50%&#x27;, &#x27;50%&#x27;], data: repairData.value, emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 5, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125; ) payChart.setOption(&#123; title: &#123; text: &#x27;缴费情况&#x27;, left: &#x27;left&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, legend: &#123; orient: &#x27;horizontal&#x27;, bottom: &#x27;10px&#x27;, data: [&#x27;已缴&#x27;,&#x27;未缴&#x27;] &#125;, label: &#123; show: true, position: &#x27;top&#x27; &#125;, xAxis: &#123; data: [&#x27;水费&#x27;, &#x27;电费&#x27;, &#x27;停车费&#x27;, &#x27;物业费&#x27;] &#125;, yAxis: &#123;&#125;, series: [ &#123; name: &#x27;已缴&#x27;, type: &#x27;bar&#x27;, data: paymentData.value.hasPay &#125;,&#123; name: &#x27;未缴&#x27;, type: &#x27;bar&#x27;, data: paymentData.value.noPay &#125; ] &#125;) &#125; 1234567891011121314&lt;div style=&quot;display: flex;flex-direction: row;justify-content: space-between;margin-top: 4vh&quot;&gt; &lt;div style=&quot;height:50vh;width:50vh ;margin-top: 20px;border-style: solid;border-color: #f5f1f1;&quot;&gt; &lt;div ref=&quot;building&quot; :style=&quot;&#123; float:&#x27;bottom&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height:50vh;width:50vh ;margin-top: 20px;border-style: solid;border-color: #f5f1f1;&quot;&gt; &lt;div ref=&quot;paying&quot; :style=&quot;&#123; float:&#x27;bottom&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height:50vh;width:50vh ;margin-top: 20px;border-style: solid;border-color: #f5f1f1;&quot;&gt; &lt;div ref=&quot;repairing&quot; :style=&quot;&#123; float:&#x27;bottom&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 3.vue项目的config配置文件1234567891011121314151617181920212223242526272829303132const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, //配置文件的查找目录 publicPath:&quot;/&quot;, devServer: &#123; //编译完成后打开 open:true, //配置运行端口 port: 8888, //允许所有请求进入 allowedHosts: &#x27;all&#x27;, //关闭浏览器网页的全屏报错 client: &#123; overlay: false, &#125;, //解决跨域问题 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;,//这里填入你要请求的接口的前缀 ws:true,//代理websocked changeOrigin:true,//虚拟的站点需要更管origin secure: true, //是否https接口 pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27;//重写路径 &#125; &#125; &#125;&#125; &#125;) 4.拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//定制请求的实例//导入token状态import &#123; useTokenStore &#125; from &#x27;@/stores/token.js&#x27;;//添加请求拦截器//导入axios npm install axiosimport axios from &#x27;axios&#x27;;import router from &#x27;@/router&#x27;;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;;//定义一个变量,记录公共的前缀,baseURLconst baseURL = &#x27;/api&#x27;;const instance = axios.create(&#123;baseURL&#125;)//添加请求拦截器instance.interceptors.request.use( (config)=&gt;&#123; //在发送请求之前做什么 let tokenStore = useTokenStore() //如果token中有值，在携带 if(tokenStore.token)&#123; config.headers.Authorization=tokenStore.token &#125; return config &#125;, (err)=&gt;&#123; //如果请求错误做什么 Promise.reject(err) &#125;)//添加响应拦截器instance.interceptors.response.use( result=&gt;&#123; if(result.data.code==0)&#123; return result.data &#125;else&#123; ElMessage.error(result.data.message?result.data.message:&#x27;服务异常&#x27;) &#125; &#125;, err=&gt;&#123; if(err.response.status===401)&#123; ElMessage.error(&#x27;请先登录！&#x27;) router.push(&#x27;/login&#x27;) &#125;else&#123; ElMessage.error(&#x27;服务异常&#x27;); &#125; return Promise.reject(err);//异步的状态转化成失败的状态 &#125;)export default instance; 5.存储token12345678910111213141516171819202122232425262728import &#123;defineStore&#125; from &#x27;pinia&#x27;import &#123;ref&#125; from &#x27;vue&#x27;export const useTokenStore = defineStore(&#x27;token&#x27;,()=&gt;&#123; //1.定义描述token const token =ref(&#x27;&#x27;) //2.定义修改token的方法 const setToken = (newToken)=&gt;&#123; token.value = newToken &#125; //3.定义移除token的方法 const removeToken = ()=&gt;&#123; token.value=&#x27;&#x27; &#125; return &#123; token,setToken,removeToken &#125;&#125;,//参数持久化&#123; persist:true&#125;) 6.安装element-ui1npm install element-plus --save 12import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27; 1app.use(ElementPlus) 7.检测屏幕滚动1234567891011121314151617181920212223242526import &#123; ref, onMounted, watch &#125; from &quot;vue&quot;;//点击箭头，滑动页面const scrollTop = ref(&#x27;&#x27;)const topsrcoll = ref(false)//上移样式成立onMounted(() =&gt; &#123; window.addEventListener(&#x27;scroll&#x27;, handleScroll)&#125;)//监听页面滚动const handleScroll = () =&gt; &#123; scrollTop.value = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop&#125;// 监听top值的变化watch(scrollTop, (newValue, oldValue) =&gt; &#123; // 等新值大于100的时候再做变化（优化一下） console.log(newValue, oldValue) // 等新值大于100的时候再做变化（优化一下） if (newValue &gt; 100) &#123; if (newValue &gt; oldValue) &#123; console.log(&#x27;向下滚动&#x27;) topsrcoll.value = true &#125; else &#123; console.log(&#x27;向上滚动&#x27;) topsrcoll.value = false &#125; &#125;&#125;) 123&lt;h1 v-if=topsrcoll&gt;dfgiusgdefisde&lt;/h1&gt; 8.在项目中使用scss安装sass1npm i sass 安装loader1npm i sass-loader 使用1&lt;style lang=&quot;scss&quot; scoped&gt; 9.安装路由1npm install vue-router@4 1.创建路由器，并导出在src&#x2F;router目录下，定义一个js文件，起名为index.js。这样名字的js文件在导入时，可以不写文件名，只要定位到文件所在的文件夹即可，使用起来很方便 1234567891011121314151617181920//导入vue-router//createWebHistory一般使用history不适用hashhistoryimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;//导入组件import LoginVue from &#x27;@/views/Login.vue&#x27;import LayoutVue from &#x27;@/views/Layout.vue&#x27;//定义路由关系const routes = [ &#123; path: &#x27;/login&#x27;, component: LoginVue &#125;, &#123; path: &#x27;/&#x27;, component: LayoutVue &#125;]//创建路由器const router = createRouter(&#123; history: createWebHistory(), routes: routes&#125;);export default router 2.在vue应用实例中使用router在main.js中导入创建应用实力的js文件，并调用实例的use方法使用路由器 123import router from &#x27;@/router&#x27;app.use(router) 3.定义展示路由组件的地方在App.vue文件的template标签中，定义router-view标签 123&lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt; 将来不管根据路由匹配到的组件内容，会在router-view标签内进行展示 4.路由API在登录成功后，需要通过代码的方式将页面切换到首页，此时就需要调用路由器相关的API 获取路由器 12import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter(); 调用API 1router.push(&#x27;/&#x27;) 5.子路由在咱们的主页面中，当用户点击左侧的菜单时，右侧主区域的内容需要发生变化，将来每切换一个菜单，右侧需要加载对应组件的内容进行展示，像这样的场景咱们也需要使用路由来完成 由于这些组件都需要在Layout.vue中展示， 而Layout.vue本身已经参与了路由，因此我们需要在Layout.vue中通过子路由的方式来完成组件的切换 5.1提供菜单对应的组件可以复制资料中的文件，也可以自己创建： ArticleCategory.vue ArticleManage.vue UserInfo.vue UserAvatar.vue UserResetPassword.vue 5.2配置子路由在src&#x2F;router&#x2F;index.js中配置子路由 123456789101112131415161718//定义路由关系const routes = [ &#123; path: &#x27;/login&#x27;, component: LoginVue &#125;, &#123; path: &#x27;/&#x27;, component: LayoutVue, //重定向，默认访问此界面 redirect: &#x27;/article/manage&#x27;, //子路由 children: [ &#123; path: &#x27;/article/category&#x27;, component: ArticleCategoryVue &#125;, &#123; path: &#x27;/article/manage&#x27;, component: ArticleManageVue &#125;, &#123; path: &#x27;/user/info&#x27;, component: UserInfoVue &#125;, &#123; path: &#x27;/user/avatar&#x27;, component: UserAvatarVUe &#125;, &#123; path: &#x27;/user/password&#x27;, component: UserResetPasswordVue &#125;, ] &#125;] 5.3 在Layout.vue组件的右侧中间区域，添加router-view标签123456&lt;!-- 中间区域 --&gt;&lt;el-main&gt; &lt;div style=&quot;width: 1290px; height: 570px;border: 1px solid red;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/el-main&gt; 5.4 菜单项设置点击后跳转的路由路径el-menu-item 标签的index属性可以设置点击后的路由路径 123456&lt;el-menu-item index=&quot;/article/category&quot;&gt; &lt;el-icon&gt; &lt;Management /&gt; &lt;/el-icon&gt; &lt;span&gt;文章分类&lt;/span&gt;&lt;/el-menu-item&gt; 10.设置滚动条1234567891011121314151617181920212223242526.box &#123; height: 100px; overflow: auto; border: 1px solid red;&#125;// 滚动条.box::-webkit-scrollbar &#123; /*滚动条整体样式*/ width: 10px; /*高宽分别对应横竖滚动条的尺寸*/ height: 1px;&#125;.box::-webkit-scrollbar-thumb &#123; /*滚动条里面小方块*/ border-radius: 10px; height: 20px; -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); // background: #E5E5E5; background: red;&#125;.box::-webkit-scrollbar-track &#123; /*滚动条里面轨道*/ -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); border-radius: 10px; background: #ffffff;&#125; 11导航栏吸顶效应1.安装vueuse1npm i @vueuse/core 使用vueuse 监听y轴的变化 1import &#123; useScroll &#125; from &#x27;@vueuse/core&#x27; 1const &#123; y &#125; = useScroll(window) 使用时监听y，当前项目中，当y大于78px时，自动展示 12345&lt;div class=&quot;app-header-sticky&quot; :class=&quot;&#123; show: y &gt; 78 &#125;&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819202122.app-header-sticky &#123; width: 100%; height: 80px; position: fixed; left: 0; top: 0; z-index: 999; background-color: #fff; border-bottom: 1px solid #e4e4e4; // 此处为关键样式!!! // 状态一：往上平移自身高度 + 完全透明 transform: translateY(-100%); opacity: 0; // 状态二：移除平移 + 完全不透明 &amp;.show &#123; transition: all 0.3s linear; transform: none; opacity: 1; &#125;&#125; 12.prop的使用手册 在vue3语法糖的使用中，定义数据 1234567891011// 定义propsdefineProps(&#123; // 主标题 title: &#123; type: String &#125;, // 副标题 subTitle: &#123; type: String &#125;&#125;) 或 1234defineProps(&#123; title: String, subTitle:string,&#125;) 在父组件中定义数据 1&lt;HomePanel title=&quot;新鲜好物&quot; sub-title=&quot;新鲜出炉 品质靠谱&quot;&gt; 或 定义一个object类型的数据 123456defineProps(&#123; goods: &#123; type: Object, default: () =&gt; &#123; &#125; &#125;&#125;) 绑定数据 1&lt;GoodsItem v-for=&quot;goods in goodList&quot; :goods=&quot;goods&quot; :key=&quot;goods.id&quot; /&gt; 13.懒加载在vueuse组件中提供了懒加载指令 可以在main.js中直接使用，但是一般在main.js中不写逻辑语句，因此将其封装在插件文件夹中，将这个插件在main.js中导入，并且注册为全局组件，可读性较高， 12345678910111213141516171819202122232425262728// 定义懒加载插件import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;export const lazyPlugin = &#123; install (app) &#123; // 懒加载指令逻辑 app.directive(&#x27;img-lazy&#x27;, &#123; mounted (el, binding) &#123; // el: 指令绑定的那个元素 img // binding: binding.value 指令等于号后面绑定的表达式的值 图片url console.log(el, binding.value) //从中获得stop指令 const &#123; stop &#125; = useIntersectionObserver( el, ([&#123; isIntersecting &#125;]) =&gt; &#123; console.log(isIntersecting) if (isIntersecting) &#123; // 进入视口区域 el.src = binding.value //当加载完成后，停止监听，减少内存消耗 stop() &#125; &#125;, ) &#125; &#125;) &#125;&#125; 在main.js中注册 123// 引入懒加载指令插件并且注册import &#123; lazyPlugin &#125; from &#x27;@/directives&#x27;app.use(lazyPlugin) 1&lt;img v-img-lazy=&quot;cate.picture&quot; /&gt; 14.路由激活时一直显示样式1&lt;router-link to=&quot;/home&quot; class=&quot;menu-home&quot; active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt; 1234.active &#123; color: $xtxColor; border-bottom: 1px solid $xtxColor; &#125; 15无限滚动123&lt;ul v-infinite-scroll=&quot;load&quot; class=&quot;infinite-list&quot; style=&quot;overflow: auto&quot; :infinite-scroll-disabled=&quot;disabled&quot;&gt; &lt;/ul&gt; 12345678910111213// 加载更多const disabled = ref(false)const load = async () =&gt; &#123; console.log(&#x27;加载更多数据咯&#x27;) // 获取下一页的数据 reqData.value.page++ const res = await getSubCategoryAPI(reqData.value) goodList.value = [...goodList.value, ...res.result.items] // 加载完毕 停止监听 if (res.result.items.length === 0) &#123; disabled.value = true &#125;&#125; 16在切换路由的时候添加动画1234567891011&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;keep-alive&gt; &lt;component :is=&quot;Component&quot; /&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;/router-view&gt; 且在根项目的时候加入div标签进行包裹 123456789.fade-enter-active,.fade-leave-active &#123; transition: opacity 0.3s ease;&#125;.fade-enter-from,.fade-leave-to &#123; opacity: 0;&#125; 17.在浏览器中使用webscoket123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;WebSocket Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt; &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt; &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭连接&lt;/button&gt; &lt;div id=&quot;message&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var websocket = null; var clientId = Math.random().toString(36).substr(2); //判断当前浏览器是否支持WebSocket if(&#x27;WebSocket&#x27; in window)&#123; //连接WebSocket节点 websocket = new WebSocket(&quot;ws://localhost:8080/ws/&quot;+clientId); &#125; else&#123; alert(&#x27;Not support websocket&#x27;) &#125; //连接发生错误的回调方法 websocket.onerror = function()&#123; setMessageInnerHTML(&quot;error&quot;); &#125;; //连接成功建立的回调方法 websocket.onopen = function()&#123; setMessageInnerHTML(&quot;连接成功&quot;); &#125; //接收到消息的回调方法 websocket.onmessage = function(event)&#123; setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 websocket.onclose = function()&#123; setMessageInnerHTML(&quot;close&quot;); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; websocket.close(); &#125; //将消息显示在网页上 function setMessageInnerHTML(innerHTML)&#123; document.getElementById(&#x27;message&#x27;).innerHTML += innerHTML + &#x27;&lt;br/&gt;&#x27;; &#125; //发送消息 function send()&#123; var message = document.getElementById(&#x27;text&#x27;).value; websocket.send(message); &#125;\t//关闭连接 function closeWebSocket() &#123; websocket.close(); &#125;&lt;/script&gt;&lt;/html&gt; 18双token的使用在前端的中，token过期会严重影响用户的体验，所以在常用用户登陆的时候，让token进行无感刷新显得非常重要，因此我们定义了两个token，一个refreshtoken和acesstoken，当accesstoken失效的时候，refreshtoken的有效期还在时代时候，可以获得一个新的ccesstoken。以vue3项目为演示 首先创建一个vue3项目，在项目中安装axios，封装一个request请求 12345678910111213141516171819202122232425262728293031323334353637383940//添加请求拦截器//导入axios npm install axiosimport axios from &#x27;axios&#x27;;sessionStorage.getItem(&quot;refreshToken&quot;);//定义一个变量,记录公共的前缀,baseURLconst baseURL = &#x27;/api&#x27;;const instance = axios.create(&#123; baseURL&#125;)//添加请求拦截器instance.interceptors.request.use( (config) =&gt; &#123; return config &#125;, (err) =&gt; &#123; //如果请求错误做什么 Promise.reject(err) &#125;)//添加响应拦截器instance.interceptors.response.use( (response) =&gt; &#123; //对响应数据做点什么 //console.log(response) if (response.data.code == 0) &#123; return response.data &#125; else &#123; console.log(response.data.msg) &#125; &#125;, (err) =&gt; &#123; return Promise.reject(err); //异步的状态转化成失败的状态 &#125;)export default instance; 这是一个基本的axios请求，并且注册了拦截器，要让请求到达后端，我们还需要设置以下跨域问题，可以在前端设置，也可以在后端设置，这里就直接在前端进行配置 123456789101112131415161718192021 devServer: &#123; //允许所有请求进入 allowedHosts: &#x27;all&#x27;, //关闭浏览器网页的全屏报错 client: &#123; overlay: false, &#125;, //解决跨域问题 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;,//这里填入你要请求的接口的前缀 ws:true,//代理websocked changeOrigin:true,//虚拟的站点需要更管origin secure: true, //是否https接口 pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27;//重写路径 &#125; &#125; &#125;&#125; 这样一个基本的前端项目就搭建完成，现在来创建两个按钮，用来发送请求 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt; 按钮 &lt;/button&gt; &lt;button @click=&quot;handleClick1&quot;&gt; 发送请求 &lt;/button&gt; &lt;div id=&quot;message&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import request from &#x27;./request&#x27;;const accessToken = ref(&quot;&quot;);const refreshToken = ref(&quot;&quot;);const handleClick = async () =&gt; &#123; const message = await request.get(&#x27;/get&#x27;) console.log(&quot;获得token&quot;); accessToken.value = message.data.accessToken; refreshToken.value = message.data.refreshToken; //将数据保存在浏览器缓存中，关闭浏览器后消失，也可以在存储在其他容器中，这里演示，就直接存储在本地 sessionStorage.setItem(&quot;accessToken&quot;, accessToken.value); sessionStorage.setItem(&quot;refreshToken&quot;, refreshToken.value);&#125;const handleClick1 = async () =&gt; &#123; console.log(&quot;发起请求&quot;) const message = await request.get(&#x27;/text&#x27;) console.log(&quot;请求返回结果&quot;) console.log(message);&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 其中按钮1是为了获得token并且将token进行存储按钮2是为了对受保护的请求发起请求，这个请求只有带有有效的token时才会返回数据，为了自动带上token，我们需要对请求拦截器进行一定的修改 123456789101112131415//添加请求拦截器instance.interceptors.request.use( (config) =&gt; &#123; const accessToken = sessionStorage.getItem(&quot;accessToken&quot;); const refreshToken = sessionStorage.getItem(&quot;refreshToken&quot;); //console.log(accessToken, refreshToken); config.headers.accessToken = accessToken config.headers.refreshToken = refreshToken return config &#125;, (err) =&gt; &#123; //如果请求错误做什么 Promise.reject(err) &#125;) 这段代码的意思是，从本地获得存储的token，再将其放入请求头中， 当accesstoken失效的时候，后端会给我们返回一个401未授权，我们需要在响应拦截器中拦截这个请求 1234567891011121314151617181920212223242526272829303132//添加响应拦截器instance.interceptors.response.use( (response) =&gt; &#123; //对响应数据做点什么 //console.log(response) if (response.data.code == 0) &#123; return response.data &#125; else &#123; console.log(response.data.msg) &#125; &#125;, async (err) =&gt; &#123; if (err.response.status === 401 &amp;&amp; err.response.headers.isoverdue == &quot;true&quot;) &#123; console.log(&#x27;token失效&#x27;) &#125; else if (err.response.status === 401 &amp;&amp; !err.response.headers.isoverdue) &#123; console.log(&#x27;重新请求&#x27;) const result = await instance.get(&quot;/refresh&quot;); const accessToken = result.data.accessToken; const refreshToken = result.data.refreshToken; sessionStorage.removeItem(&quot;accessToken&quot;); sessionStorage.removeItem(&quot;refreshToken&quot;); sessionStorage.setItem(&quot;accessToken&quot;, accessToken); sessionStorage.setItem(&quot;refreshToken&quot;, refreshToken); const data = await instance.request(err.config) return data &#125; else &#123; console.log(err.response.data.msg) &#125; return Promise.reject(err); //异步的状态转化成失败的状态 &#125;) 后端请求回来时，如果refreshtoken也过期，会在请求头中添加isoverdue，当其存在时，说明refreshtoken已经过期，这时候，我们便需要重新登陆 不然我们需要重新请求获得新的token，我们拦截未登录的请求，并且向后端的刷新接口来刷新我们的token，将获得的token重新存入本地，通过instance.request(err.config)重新发送请求，这样我们便完成了双token","tags":["前端"],"categories":["前端"]},{"title":"前端问题合集","path":"/2024/03/31/前端问题合集/","content":"1.nginx跨域123456789101112131415161718192021server &#123; listen 90; server_name localhost; location / &#123; root html; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; #解决跨域问题，核心代码 location ^~ /api/ &#123; rewrite ^/api/(.*)$ /$1 break; proxy_pass http://localhost:8080; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 2.在vue3项目中控制element-ui左侧菜单的展开和收起12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div :v-model=&#x27;isCollapse&#x27;&gt; &lt;el-icon v-if=&quot;isCollapse&quot; @click=&quot;change&quot;&gt;&lt;DArrowRight /&gt;&lt;/el-icon&gt; &lt;el-icon v-else @click=&quot;change&quot;&gt;&lt;DArrowLeft /&gt;&lt;/el-icon&gt; &lt;/div&gt; &lt;el-menu default-active=&quot;2&quot; class=&quot;el-menu-vertical-demo&quot; :collapse=&quot;isCollapse&quot; &gt; &lt;el-sub-menu index=&quot;1&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;Location /&gt;&lt;/el-icon&gt; &lt;span&gt;Navigator One&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template #title&gt;&lt;span&gt;Group One&lt;/span&gt;&lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;item one&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;item two&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title=&quot;Group Two&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;item three&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-sub-menu index=&quot;1-4&quot;&gt; &lt;template #title&gt;&lt;span&gt;item four&lt;/span&gt;&lt;/template&gt; &lt;el-menu-item index=&quot;1-4-1&quot;&gt;item one&lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;/el-sub-menu&gt; &lt;el-menu-item index=&quot;2&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &lt;template #title&gt;Navigator Two&lt;/template&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt; &lt;el-icon&gt;&lt;Document /&gt;&lt;/el-icon&gt; &lt;template #title&gt;Navigator Three&lt;/template&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;el-icon&gt;&lt;setting /&gt;&lt;/el-icon&gt; &lt;template #title&gt;Navigator Four&lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt;&lt;/template&gt; &lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; DArrowLeft, DArrowRight, Document, Menu as IconMenu, Location, Setting,&#125; from &#x27;@element-plus/icons-vue&#x27; const isCollapse = ref(false)const change=()=&gt;&#123; isCollapse.value=!isCollapse.value&#125;&lt;/script&gt; &lt;style&gt;.el-menu-vertical-demo:not(.el-menu--collapse) &#123; width: 200px; min-height: 400px;&#125;&lt;/style&gt; 3.在vue3中使用elementui中的cell-style控制表格中某行或者某单元格样式12345678910111213141516&lt;el-table :cell-style=&quot;tableRowStyle&quot; :data=&quot;tableData&quot; table-layout:auto style=&quot;width: 100%;margin-top: 2vh&quot; height=&quot;54vh&quot; scrollbar-always-on border &gt; &lt;!-- 当type的值是index的时候表示序号 --&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot; prop=&quot;index&quot; width=&quot;60&quot;/&gt; &lt;el-table-column label=&quot;报修时间&quot; prop=&quot;startDate&quot; sortable/&gt;&lt;!--sortable进行顺序排序 --&gt; &lt;el-table-column label=&quot;报修位置&quot; prop=&quot;location&quot;/&gt; &lt;el-table-column label=&quot;报修内容&quot; prop=&quot;context&quot;/&gt; &lt;el-table-column label=&quot;报修人 &quot; prop=&quot;repairPerson&quot;/&gt; &lt;el-table-column label=&quot;区域&quot; prop=&quot;repairArea&quot;/&gt; &lt;el-table-column label=&quot;受理状态&quot; prop=&quot;flowerState&quot;/&gt; &lt;el-table-column label=&quot;修复状态&quot; prop=&quot;repairState&quot;/&gt; &lt;el-table-column label=&quot;修复时间&quot; prop=&quot;repairTime&quot;/&gt; &lt;el-table-column label=&quot;修复人&quot; prop=&quot;repairHandelPerson&quot;/&gt; &lt;/el-table&gt; 1234567const tableRowStyle = (data) =&gt; &#123; if (data.row.repairState == &quot;正在修复&quot;&amp;&amp;data.column.property==&quot;repairState&quot;) &#123; return &#123; color:&#x27;red&#x27; &#125;; &#125;&#125; 4.让div盒子铺满全屏在操作过程中我们发现，在全屏中使用div盒子的时候，在div盒子的左边和上面有一个8px的空隙，需要将其重置为0 1234*&#123;/* CSS Reset,解决存在的间距问题 */\tmargin : 0;\tpadding : 0;&#125; 5.渐变色12/* 渐变色 */ background: linear-gradient(to bottom right, rgb(255, 2, 124), rgb(0, 255, 200)) no-repeat; 渐变色6.鼠标反应12345678910/* 聚焦时变化 */.button:hover &#123; background-color: rgba(123, 250, 252, 0.4);&#125;/* active点击后改变 *//* :focus 元素被点击后变色，且颜色在点击后不消失 */.button:active &#123; background-color: rgba(193, 192, 192, 0.4);&#125; 7.设置element-ui的某些样式打开开发者模式，找到对应的class名称，进行设置 123456.el-input .el-input__wrapper &#123; margin: 0 auto; border-radius: 40px 40px 40px 40px; background-color: rgb(255, 255, 255, 0.4);&#125; 8.密码框显示小眼睛1234&lt;!-- show-password在密码旁边显示小眼睛 --&gt; &lt;el-form-item&gt; &lt;el-input placeholder=&quot;请输入密码&quot; type=&quot;password&quot; v-model=&quot;formLabelAlign.region&quot; show-password /&gt; &lt;/el-form-item&gt; 9.设置圆角1border-radius: 40px 40px 40px 40px; 10自动换行123display: flex; flex-wrap: wrap; justify-content: start; 11.计算时间1234567891011//sDate1和sDate2是2002-12-18格式 var now = new Date();var sDate2 = &quot;2024-04-18&quot;;var nowData = now.getFullYear() + &quot;-&quot; + (now.getMonth() + 1) + &quot;-&quot; + now.getDate();var aDate, oDate2, iDaysaDate = nowData.split(&quot;-&quot;)nowData = new Date(aDate[1] + &#x27;-&#x27; + aDate[2] + &#x27;-&#x27; + aDate[0]) //转换为12-18-2002格式 aDate = sDate2.split(&quot;-&quot;)oDate2 = new Date(aDate[1] + &#x27;-&#x27; + aDate[2] + &#x27;-&#x27; + aDate[0])iDays = parseInt(Math.abs(nowData - oDate2) / 1000 / 60 / 60 / 24) //把相差的毫秒数转换为天数 12.分隔线1&lt;hr class=&quot;hr-double-arrow&quot;&gt; 123456789101112131415161718192021222324252627282930313233.hr-double-arrow &#123; color: #7171d5; border: double; border-width: 3px 5px; border-color: #5b336b transparent; height: 1px; overflow: visible; margin-left: 20px; margin-right: 20px; position: relative; &#125; .hr-double-arrow:before, .hr-double-arrow:after &#123; content: &#x27;&#x27;; position: absolute; width: 5px; height: 5px; border-width: 0 3px 3px 0; border-style: double; top: -3px; background: radial-gradient(2px at 1px 1px, currentColor 2px, transparent 0) no-repeat; &#125; .hr-double-arrow:before &#123; transform: rotate(-45deg); left: -20px; &#125; .hr-double-arrow:after &#123; transform: rotate(135deg); right: -20px; &#125; 13.md文件渲染1npm i html-loader markdown-loader --save 14安装出现报错1this[kHandle] = new _Hash(algorithm, xofLen); 出现原因：由于更新，导致node版本不匹配，要将该项目的启动选项进行修改 解决办法 1$env:NODE_OPTIONS=&quot;--openssl-legacy-provider&quot; 15.路由缓存问题路由缓存问题解决 缓存问题：当路由path一样，参数不同的时候会选择直接复用路由对应的组件解决方案： 给 routerv-view 添加key属性，破坏缓存 1:key=&quot;$route.fullPath&quot; 使用 onBeforeRouteUpdate钩子函数，做精确更新 12345678910import &#123; onBeforeRouteUpdate &#125; from &#x27;vue-router&#x27; // 目标:路由参数变化的时候 可以把分类数据接口重新发送//to中为将要跳转时的最新路由 onBeforeRouteUpdate((to) =&gt; &#123; // 存在问题：使用最新的路由参数请求最新的分类数据 //通过最新的路由去请求数据 getCategory(to.params.id) &#125;) 16.当切换路由时，在不同页面的滚动深度可能受到影响，需要在重新定义他的滚动高度11234567891011//创建路由器const router = createRouter(&#123; history: createWebHistory(), routes: routes, //滚动条返回顶部 scrollBehavior () &#123; return &#123; top :0, &#125; &#125;&#125;);","tags":["前端"],"categories":["前端"]},{"title":"后端工具类","path":"/2024/03/31/后端工具类/","content":"1.md5加密密码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.security.MessageDigest;import java.security.NoSuchAlgorithmException; public class Md5Util &#123; /** * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合 */ protected static char hexDigits[] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;; protected static MessageDigest messagedigest = null; static &#123; try &#123; messagedigest = MessageDigest.getInstance(&quot;MD5&quot;); &#125; catch (NoSuchAlgorithmException nsaex) &#123; System.err.println(Md5Util.class.getName() + &quot;初始化失败，MessageDigest不支持MD5Util。&quot;); nsaex.printStackTrace(); &#125; &#125; /** * 生成字符串的md5校验值 * * @param s * @return */ public static String getMD5String(String s) &#123; return getMD5String(s.getBytes()); &#125; /** * 判断字符串的md5校验码是否与一个已知的md5码相匹配 * * @param password 要校验的字符串 * @param md5PwdStr 已知的md5校验码 * @return */ public static boolean checkPassword(String password, String md5PwdStr) &#123; String s = getMD5String(password); return s.equals(md5PwdStr); &#125; public static String getMD5String(byte[] bytes) &#123; messagedigest.update(bytes); return bufferToHex(messagedigest.digest()); &#125; private static String bufferToHex(byte bytes[]) &#123; return bufferToHex(bytes, 0, bytes.length); &#125; private static String bufferToHex(byte bytes[], int m, int n) &#123; StringBuffer stringbuffer = new StringBuffer(2 * n); int k = m + n; for (int l = m; l &lt; k; l++) &#123; appendHexPair(bytes[l], stringbuffer); &#125; return stringbuffer.toString(); &#125; private static void appendHexPair(byte bt, StringBuffer stringbuffer) &#123; char c0 = hexDigits[(bt &amp; 0xf0) &gt;&gt; 4];// 取字节中高 4 位的数字转换, &gt;&gt;&gt; // 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同 char c1 = hexDigits[bt &amp; 0xf];// 取字节中低 4 位的数字转换 stringbuffer.append(c0); stringbuffer.append(c1); &#125; &#125; 2.JWT令牌使用导入pom坐标123456&lt;!--JWT起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt; &lt;/dependency&gt; 创建工具类123456789101112131415161718192021public class JwtUtil &#123; //进行加密的keyprivate static final String KEY = &quot;forexample&quot;;//接收业务数据,生成token并返回，这里用的是userId和usernamepublic static String genToken(Map&lt;String, Object&gt; claims) &#123; return JWT.create() .withClaim(&quot;claims&quot;, claims) .withExpiresAt(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 12)) .sign(Algorithm.HMAC256(KEY));&#125; //接收token,验证token,并返回业务数据public static Map&lt;String, Object&gt; parseToken(String token) &#123; return JWT.require(Algorithm.HMAC256(KEY)) .build() .verify(token) .getClaim(&quot;claims&quot;) .asMap();&#125; &#125; 在登陆时返回给前端，在进行其他接口调用的时候，将token传会后端，并且对请求进行拦截 在目录中创建拦截器文件interceptors并且定义拦截器1234567891011121314151617181920212223242526@Slf4j@Componentpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //验证令牌 String token =request.getHeader(&quot;Authorization&quot;); try &#123; //验证token Map&lt;String, Object&gt; stringObjectMap = JwtUtil.parseToken(token); ThreadLocalUtil.set(stringObjectMap); //放行 return true; &#125; catch (Exception e) &#123; response.setStatus(401); log.info(&quot;非法请求&quot;); return false; &#125; &#125; //在拦截器执行完后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //清除thread里面的数据，防止内存泄漏 ThreadLocalUtil.remove(); &#125;&#125; 在配置文件中，对该自定义拦截器进行注册，但是对登陆 和注册接口 1234567891011@Slf4j@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; log.info(&quot;开始注册自定义拦截器&quot;); registry.addInterceptor(loginInterceptor).excludePathPatterns(&quot;/user/login&quot;,&quot;/user/register&quot;); &#125;&#125; 3.后端工程中websocket的使用导入webscoked的maven坐标 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 创建webscoked的服务文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.text;import jakarta.websocket.OnClose;import jakarta.websocket.OnMessage;import jakarta.websocket.OnOpen;import jakarta.websocket.Session;import jakarta.websocket.server.PathParam;import jakarta.websocket.server.ServerEndpoint;import org.springframework.stereotype.Component;import java.io.IOException;import java.util.Collection;import java.util.HashMap;import java.util.Map;@Component@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)public class webSocked &#123; private static Map&lt;String, Session&gt; sessionMap =new HashMap(); /** * 链接成功的回调方法 */ @OnOpen public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid)&#123; System.out.println(&quot;与客户端&quot;+sid+&quot;建立链接&quot;); sessionMap.put(sid,session); &#125; /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息 */ @OnMessage public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) &#123; System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message); &#125; /** * 连接关闭调用的方法 * * @param sid */ @OnClose public void onClose(@PathParam(&quot;sid&quot;) String sid) &#123; System.out.println(&quot;连接断开:&quot; + sid); sessionMap.remove(sid); &#125; /** * 群发 * * @param message */ public void sendToAllClient(String message) &#123; Collection&lt;Session&gt; sessions =sessionMap.values(); for (Session session : sessions) &#123; try &#123; session.getBasicRemote().sendText(message); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 将webscoked注入配置类中 123456789101112131415package com.example.text;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configurationpublic class webSockedConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 创建测试类 12345678910111213141516171819package com.example.text;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Componentpublic class webSockedText &#123; @Autowired private webSocked webSocked; @Scheduled(cron = &quot;0/5 * * * * ?&quot;) public void sendMessage() &#123; webSocked.sendToAllClient(&quot;这是来自服务端的消息：&quot; + DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;).format(LocalDateTime.now())); &#125;&#125; 定时任务在程序主入口出添加允许任务的注解 123456789101112131415161718192021package com.example.text;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;//springboot注解@SpringBootApplication//lombok注解@Slf4j//开启事务注解@EnableSchedulingpublic class TextApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TextApplication.class, args); log.info(&quot;服务启动&quot;); &#125;&#125; 4.双token首先导入jwt的pom依赖 12345 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; result结果类 123456789101112131415161718192021222324package com.example.text;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@AllArgsConstructor@NoArgsConstructor@Datapublic class result&lt;T&gt; &#123; private Integer code; private String message; private T data; public static &lt;E&gt; result&lt;E&gt; success(E data)&#123; return new result&lt;E&gt;(0,&quot;操作成功&quot;,data); &#125; public static result success()&#123; return new result(0,&quot;操作成功&quot;,null); &#125; public static result error(String message) &#123; return new result(1, message, null); &#125;&#125; 编写一个jwt工具类 12345678910111213141516171819202122232425262728293031package com.example.text;import com.auth0.jwt.JWT;import com.auth0.jwt.algorithms.Algorithm;import java.util.Date;import java.util.Map;public class jwt &#123; private static final String KEY = &quot;forexample&quot;; //接收业务数据,生成token并返回 public static String genToken(Map&lt;String, Object&gt; claims, int minute) &#123; return JWT.create() .withClaim(&quot;claims&quot;, claims) .withExpiresAt(new Date(System.currentTimeMillis() +1000*minute))//1000 * 60 * 60 * 12 .sign(Algorithm.HMAC256(KEY)); &#125; //接收token,验证token,并返回业务数据 public static Map&lt;String, Object&gt; parseToken(String token) &#123; return JWT.require(Algorithm.HMAC256(KEY)) .build() .verify(token) .getClaim(&quot;claims&quot;) .asMap(); &#125;&#125; 定义一个拦截器，核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.text;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import com.example.text.jwt;import java.awt.*;import java.util.Map;@Slf4j@Componentpublic class login implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; //请求拦截器 //获得请求头中的token String accessToken = request.getHeader(&quot;accessToken&quot;); colorPrint.colorPrint(&quot;accessToken----&quot; + accessToken, colorPrint.BLUE); String refreshToken = request.getHeader(&quot;refreshToken&quot;); colorPrint.colorPrint(&quot;refreshToken----&quot; + refreshToken, colorPrint.BLUE); try &#123; //解析accessToken Map&lt;String, Object&gt; map = jwt.parseToken(accessToken); colorPrint.colorPrint(&quot;请求token通过，允许访问&quot;, colorPrint.BLUE); //成功 return true; &#125; catch (Exception e) &#123; //失败，开始解析refreshtoken，判断是否过期 try &#123; Map&lt;String, Object&gt; map = jwt.parseToken(refreshToken); &#125; catch (Exception exception) &#123; //refreshtoken失效 colorPrint.colorPrint(&quot;七天请求过期&quot;, colorPrint.RED); response.setHeader(&quot;isOverdue&quot;,&quot;true&quot;); response.setStatus(401); return false; &#125; //refreshtoken有效期没过 colorPrint.colorPrint(&quot;非法请求&quot;, colorPrint.RED); response.setStatus(401); return false; &#125; &#125;&#125; 为了打印彩色的语句，自己封装了一个彩色打印 12345678910111213141516package com.example.text;public class colorPrint &#123; public static final Integer RED=31; public static final Integer BLACK=30; public static final Integer GREEN=32; public static final Integer ORIGIN=33; public static final Integer BLUE=34; public static final Integer PURPLE=35; public static final Integer AQUA=36; public static final Integer GRAY=37; public static void colorPrint(String message, Integer color) &#123; System.out.println(&quot;\\033[&quot;+color+&quot;;4m&quot; + message + &quot;\\033[0m&quot;); &#125;&#125; 将自定义拦截器注册 123456789101112131415161718package com.example.text;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class config implements WebMvcConfigurer &#123; @Autowired private login login; @Override public void addInterceptors(InterceptorRegistry registry) &#123; colorPrint.colorPrint(&quot; 自定义拦截器开始生效&quot;,colorPrint.GREEN); //除了获得token和refresh请求，其他的请求都要经过拦截器 registry.addInterceptor(login).excludePathPatterns(&quot;/get&quot;,&quot;/refresh&quot;); &#125;&#125; 定义请求层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.text;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;@Slf4j@RestControllerpublic class controller &#123; @GetMapping(&quot;/text&quot;) public result textService() &#123; colorPrint.colorPrint(&quot;请求进入&quot;, colorPrint.ORIGIN); return result.success(); &#125; @GetMapping(&quot;/get&quot;) public result&lt;Map&gt; get() &#123; Map&lt;String, Object&gt; clains = new HashMap&lt;&gt;(); clains.put(&quot;id&quot;, 1); clains.put(&quot;username&quot;, 666); log.info(&quot;生成jwt令牌&quot;); String accessToken = jwt.genToken(clains, 3); String refreshToken = jwt.genToken(clains, 60); colorPrint.colorPrint(accessToken, colorPrint.RED); colorPrint.colorPrint(refreshToken, colorPrint.BLUE); Map map = new HashMap&lt;&gt;(); map.put(&quot;accessToken&quot;, accessToken); map.put(&quot;refreshToken&quot;, refreshToken); return result.success(map); &#125; @GetMapping(&quot;/refresh&quot;) public result&lt;Map&gt; refresh(@RequestHeader(name = &quot;refreshToken&quot;) String refreshToken) &#123; Map&lt;String, Object&gt; map = jwt.parseToken(refreshToken); String newAccessToken = jwt.genToken(map, 3); String newRefreshToken = jwt.genToken(map, 60); Map hashMap = new HashMap&lt;&gt;(); colorPrint.colorPrint(newAccessToken, colorPrint.PURPLE); colorPrint.colorPrint(newRefreshToken, colorPrint.PURPLE); hashMap.put(&quot;accessToken&quot;, newAccessToken); hashMap.put(&quot;refreshToken&quot;, newRefreshToken); return result.success(hashMap); &#125;&#125; 5.图形验证码使用验证码生成工具 本项目使用开源的验证码生成工具EasyCaptcha，其支持多种类型的验证码，例如gif、中文、算术等，并且简单易用，具体内容可参考其官方文档。 在common模块的pom.xml文件中增加如下内容 1234&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;&lt;/dependency&gt; 在service中使用 12345SpecCaptcha specCaptcha = new SpecCaptcha(130, 48, 4);specCaptcha.setCharType(Captcha.TYPE_DEFAULT);String code = specCaptcha.text().toLowerCase();System.out.println(code);String image = specCaptcha.toBase64(); 启动项目当有请求进入的时候，会生成验证码的code，code是验证吗的值，image由base64编码，到前端进行解码，此处并没有使用redis，正常情况下需要生成一个uuid作为redis存储的key，而code作为redis的value。返回给前端的是验证码图片imag和redis的key，当前端有请求进来时，携带用户名和密码，图片验证码key和code，进入后端查询redis，进行正常的登陆","tags":["java"],"categories":["java"]},{"title":"linux","path":"/2024/03/23/linux/","content":"linux安装linux（略）修改网卡，初始化IP1.输入 1ip addr 若没有IP出现，则需要配置 2.修改 12345cd/cd etccd sysconfigcd netword-scriptsvi ifcfg-ens33 输入i进入编辑，移动光标，修改完成后按下esc，输入wq，回车。保存退出 安装ssh链接工具安装finalshell，快速链接即可 linux目录 Linux文件系统目录结构理解和熟悉Linux系统的文件系统目录结构，对于有效的管理和定位文件十分重要。Linux文件系统的目录结构如下图所示： 其中各目录的作用如下表所示 目录 说明 作用 &#x2F; 根目录 根目录是整个文件系统的起点，所有其他目录和文件都位于根目录之下。 &#x2F;home 家目录 每个用户的个人目录都位于这个目录下，通常以用户名命名。例如，用户john的主目录路径为/home/john。 &#x2F;root root用户的家目录 保存root用户的个人数据 &#x2F;boot 引导文件所在目录 保存系统启动时所需的各种文件 &#x2F;usr User System Resources的简写，说法不唯一 存放用户可用的软件和程序文件，也包括了一些共享的数据和库文件。 &#x2F;bin binary的简写 存放系统的基本命令（如ls、cp等）和其余可执行文件。 &#x2F;sbin system binary的简写 存放系统管理和维护方面的二进制文件。 &#x2F;etc etcetera的简写 存放系统的配置文件，包括各种程序的配置文件和系统的全局配置文件。 &#x2F;var variable的简写 存放系统运行时产生的可变数据，如日志文件、数据库文件等。 &#x2F;opt optional的简写 存放一些可选的软件包，通常由用户自行安装。 &#x2F;tmp temporary的简写 存放临时文件，系统会定期清理该目录 linux常用命令 序号 命令 作用 1 ls 查看当前目录下所有内容 2 pwd 查看当前所在目录 3 cd 切换目录 4 touch 如果文件不存在，新建文件 5 mkdir 创建目录 6 rm 删除指定文件 显示文件内容cat1cat[-n] filename -n:由1开始对所有输出的行数编号 以分页的形式显示内容1more filename 操作： 回车 向下滚动一行 ​\t空格 向下滚动一屏 ​\tb 返回上一屏 ​\tq或者ctrl c 退出more 查看文件末尾内容（默认后十行）1tail [-f] filename 删除空目录1rmdir [-p] dirname -p : 当子目录被删除后使父目录为空目录时，一并删除 删除文件1rm [-rf] name -f 将目录及所有文件删除（递归删除） -r 无需确认，直接删除 删除文件夹1rm -rf 文件夹名字 复制文件夹1cp -r 文件目录/. 文件目录 查看防火墙状态1firewall-cmd --state 打开防火墙1systemctl start firewalld.service 开启端口1firewall-cmd --zone=public --add-port=端口/tcp --permanent 重启防火墙1systemctl restart firewalld.service 查看已开启的端口1firewall-cmd --list-ports 如何关闭端口1firewall-cmd --zone=public --remove-port=端口/tcp --permanent 查看端口占用1netstat -ntlp 安装nginx前景提要：本人小白一个，由于需要将前端的代码部署到服务器上，然后了解到了nginx，便开始了nginx安装配置的信息搜集和实践，经过屡次的失败，最后在b站上一个视频的带领下，成功完成。 一.依赖下载 1yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 二.下载nginx 1.访问官网 ，获取nginx Nginux官网 鼠标放在需要下载的版本上，右击鼠标“复制链接” 2.在Linux系统上进行下载（示例：下载1.25.1版本） 1wget http://nginx.org/download/nginx-1.25.1.tar.gz 3.便于管理，可以创建一个文件夹来保存（若不想的可以跳过步骤3，4） 创建文件夹 1mkdir /usr/java #将包移入文件夹中 1mv nginx-1.25.1.tar.gz /usr/java #转换到该文件夹下 1cd /usr/java #查看文件夹的内容 1ls 4.解压包，并转换到nginx文件夹下 #解压包 1tar -zxf nginx-1.25.1.tar.gz #转换到nginx文件夹下 1cd nginx-1.25.1 出现“nginx-1.25.1”表示解压成功 5.配置nginx 1./configure 6.编译安装nginx #这是编译和安装一块进行（&amp;&amp;），也可以分开 1make&amp;&amp;make install 过程如下： 7.运行nginx8 #转换到sbin文件夹下 1cd /usr/local/nginx/sbin #运行nginx 1./nginx 8.查看结果 ​ （1）通过命令行进行 ​ （2）直接通过ip地址（服务器ip）+端口号（默认80） ​ 注：如用方式（2）进行访问的话，记得要开放端口号 firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent 编辑配置文件1vim /etc/nginx/nginx.conf 利用centos7搭建linux环境1.下载镜像找到中国阿里云镜像网centos-7-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com) 下载镜像，这里选择的是CentOS-7-x86_64-Minimal-2009.iso下载完成后放入磁盘待用， 2.下载vmware虚拟机我们在VMware《主页》界面中点击《创建新的虚拟机》按钮： 然后会弹出一个窗口，我们直接点击下一步： 然后页面中选择你准备好的ISO文件，继续点击下一步： 然后填写虚拟机的名称以及虚拟机将来保存的位置： 再次下一步，填写虚拟机磁盘大小。这里建议给大一点，否则将来不够用调整起来麻烦。而且这里设置大小并不是立刻占用这么多，而是设置一个上限： 继续下一步，然后选择虚拟机硬件设置： 在弹出的窗口中设置虚拟机硬件，建议CPU给到4核，内存给到8G： 配置完成后，点击关闭，回到上一页面，继续点击完成： 虚拟机就创建完毕了： 3.安装Centos7接下来，我们启动刚刚创建的虚拟机，开始安装Centos7系统： 启动后需要选择安装菜单，将鼠标移入黑窗口中后，将无法再使用鼠标，需要按上下键选择菜单。选中Install Centos 7 后按下回车： 然后会提示我们按下enter键继续： 过一会儿后，会进入语言选择菜单，这里可以使用鼠标选择。选择中文-简体中文，然后继续： 接下来，会进入安装配置页面： 鼠标向下滚动后，找到系统-安装位置配置，点击： 选择刚刚添加的磁盘，并点击完成： 然后回到配置页面，这次点击《网络和主机名》： 在网络页面做下面的几件事情： 修改主机名为自己喜欢的主机名，不要出现中文和特殊字符，建议用localhost 点击应用 将网络连接打开 点击配置，设置详细网络信息 最好用一个截图软件，记住上图中的网络详细信息，接下来的配置要参考： 点击配置按钮后，我们需要把网卡地址改为静态IP，这样可以避免每次启动虚拟机IP都变化。所有配置照搬你自己截图的网络信息填写，不要照抄我的： 上图中的四个信息参考之前的以太网**(ens33)**网卡的截图，不要照搬我的来写。 最后，点击完成按钮： 回到配置界面后，点击开始安装： 接下来需要设置root密码： 填写你要使用的root密码，然后点击完成： 接下来，耐心等待安装即可。 4.利用ssh连接工具链接虚拟机，这里使用finalshell，下载好后打开利用ssh链接 主机名为虚拟机的ip地址 名称根据个人喜好进行填写 用户名为当时创建虚拟机时填写的用户名 密码同理 全部填写完成后点击 确定，然后打开这个终端，应该就能连接上虚拟机了 5.使用虚拟机利用yum update命令更新yum 注意，此时可能报错**Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock32 error was 14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; Unknown error**,这是因为网络配置有问题在命令行输入 1curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 便可以解决问题，再次使用yum update发现问题解决 6.安装docker利用yum工具安装docker 首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fast 在命令行输入 1yum install -y docker-ce 安装docker，利用 1docker -v 查看docker安装的版本，若正常显示出docker版本，则docker安装成功 7.利用docker安装mysql1.创建一个网络1docker network create net 2.使用pull命令拉取镜像1docker pull mysql 这里如果显示连接失败第一步：新建或编辑daemon.json 1vi /etc/docker/daemon.json 第二步：daemon.json中编辑如下 123456&quot;registry-mirrors&quot;: [ &quot;https://docker.m.daocloud.io&quot;, &quot;https://dockerproxy.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://docker.nju.edu.cn&quot; ] 第三步：重启docker 1systemctl restart docker.service 第四步：执行docker info查看是否修改成功 1docker info 拉取镜像后使用 1docker images 查看拉取下来的镜像，使用命令运行镜像 1234567docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=1234 \\ --network net\\ mysql 可以启动mysql，最后访问虚拟机ip加端口就可以对数据库进行操作 8.安装nacos安装nacos，首先需要创建一个nacos专用数据库 连接数据库，执行以下命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246-- 导出 nacos 的数据库结构DROP DATABASE IF EXISTS `nacos`;CREATE DATABASE IF NOT EXISTS `nacos` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */;USE `nacos`;-- 导出 表 nacos.config_info 结构DROP TABLE IF EXISTS `config_info`;CREATE TABLE IF NOT EXISTS `config_info` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin DEFAULT NULL, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `c_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL, `c_use` varchar(64) COLLATE utf8_bin DEFAULT NULL, `effect` varchar(64) COLLATE utf8_bin DEFAULT NULL, `type` varchar(64) COLLATE utf8_bin DEFAULT NULL, `c_schema` text COLLATE utf8_bin, `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;-- 正在导出表 nacos.config_info 的数据：~0 rows (大约)DELETE FROM `config_info`;-- 导出 表 nacos.config_info_aggr 结构DROP TABLE IF EXISTS `config_info_aggr`;CREATE TABLE IF NOT EXISTS `config_info_aggr` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `datum_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;datum_id&#x27;, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;内容&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;-- 正在导出表 nacos.config_info_aggr 的数据：~0 rows (大约)DELETE FROM `config_info_aggr`;-- 导出 表 nacos.config_info_beta 结构DROP TABLE IF EXISTS `config_info_beta`;CREATE TABLE IF NOT EXISTS `config_info_beta` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;, `beta_ips` varchar(1024) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;betaIps&#x27;, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;-- 正在导出表 nacos.config_info_beta 的数据：~0 rows (大约)DELETE FROM `config_info_beta`;-- 导出 表 nacos.config_info_tag 结构DROP TABLE IF EXISTS `config_info_tag`;CREATE TABLE IF NOT EXISTS `config_info_tag` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tag_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_id&#x27;, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;-- 正在导出表 nacos.config_info_tag 的数据：~0 rows (大约)DELETE FROM `config_info_tag`;-- 导出 表 nacos.config_tags_relation 结构DROP TABLE IF EXISTS `config_tags_relation`;CREATE TABLE IF NOT EXISTS `config_tags_relation` ( `id` bigint NOT NULL COMMENT &#x27;id&#x27;, `tag_name` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_name&#x27;, `tag_type` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tag_type&#x27;, `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `nid` bigint NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;-- 正在导出表 nacos.config_tags_relation 的数据：~0 rows (大约)DELETE FROM `config_tags_relation`;-- 导出 表 nacos.group_capacity 结构DROP TABLE IF EXISTS `group_capacity`;CREATE TABLE IF NOT EXISTS `group_capacity` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `group_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;, `quota` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;, `max_aggr_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;-- 正在导出表 nacos.group_capacity 的数据：~0 rows (大约)DELETE FROM `group_capacity`;-- 导出 表 nacos.his_config_info 结构DROP TABLE IF EXISTS `his_config_info`;CREATE TABLE IF NOT EXISTS `his_config_info` ( `id` bigint unsigned NOT NULL, `nid` bigint unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) COLLATE utf8_bin NOT NULL, `group_id` varchar(128) COLLATE utf8_bin NOT NULL, `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext COLLATE utf8_bin NOT NULL, `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text COLLATE utf8_bin, `src_ip` varchar(50) COLLATE utf8_bin DEFAULT NULL, `op_type` char(10) COLLATE utf8_bin DEFAULT NULL, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `encrypted_data_key` text COLLATE utf8_bin NOT NULL COMMENT &#x27;秘钥&#x27;, PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;-- 正在导出表 nacos.his_config_info 的数据：~0 rows (大约)DELETE FROM `his_config_info`;-- 导出 表 nacos.permissions 结构DROP TABLE IF EXISTS `permissions`;CREATE TABLE IF NOT EXISTS `permissions` ( `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, `resource` varchar(255) COLLATE utf8mb4_general_ci NOT NULL, `action` varchar(8) COLLATE utf8mb4_general_ci NOT NULL, UNIQUE KEY `uk_role_permission` (`role`,`resource`,`action`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;-- 正在导出表 nacos.permissions 的数据：~0 rows (大约)DELETE FROM `permissions`;-- 导出 表 nacos.roles 结构DROP TABLE IF EXISTS `roles`;CREATE TABLE IF NOT EXISTS `roles` ( `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, UNIQUE KEY `idx_user_role` (`username`,`role`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;-- 正在导出表 nacos.roles 的数据：~1 rows (大约)DELETE FROM `roles`;INSERT INTO `roles` (`username`, `role`) VALUES\t(&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;);-- 导出 表 nacos.tenant_capacity 结构DROP TABLE IF EXISTS `tenant_capacity`;CREATE TABLE IF NOT EXISTS `tenant_capacity` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;, `quota` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;, `max_aggr_size` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;-- 正在导出表 nacos.tenant_capacity 的数据：~0 rows (大约)DELETE FROM `tenant_capacity`;-- 导出 表 nacos.tenant_info 结构DROP TABLE IF EXISTS `tenant_info`;CREATE TABLE IF NOT EXISTS `tenant_info` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `kp` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;kp&#x27;, `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tenant_name` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;, `tenant_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;, `create_source` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;create_source&#x27;, `gmt_create` bigint NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` bigint NOT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;-- 正在导出表 nacos.tenant_info 的数据：~0 rows (大约)DELETE FROM `tenant_info`;-- 导出 表 nacos.users 结构DROP TABLE IF EXISTS `users`;CREATE TABLE IF NOT EXISTS `users` ( `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL, `password` varchar(500) COLLATE utf8mb4_general_ci NOT NULL, `enabled` tinyint(1) NOT NULL, PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;-- 正在导出表 nacos.users 的数据：~1 rows (大约)DELETE FROM `users`;INSERT INTO `users` (`username`, `password`, `enabled`) VALUES\t(&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, 1);/*!40103 SET TIME_ZONE=IFNULL(@OLD_TIME_ZONE, &#x27;system&#x27;) */;/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, &#x27;&#x27;) */;/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */; 并且创建名为nacos的文件夹，在文件夹内部创建文件custom.env在内部填入 123456789PREFER_HOST_MODE=hostnameMODE=standaloneSPRING_DATASOURCE_PLATFORM=mysqlMYSQL_SERVICE_HOST= ****//你自己的虚拟机ip地址MYSQL_SERVICE_DB_NAME=nacosMYSQL_SERVICE_PORT=3306MYSQL_SERVICE_USER=rootMYSQL_SERVICE_PASSWORD=*****//你自己的虚拟机mysql密码MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai 将nacos文件夹放入虚拟机root根目录 使用docker pull nacos拉取nacos的镜像 123456789docker run -d \\--name nacos \\--env-file /root/nacos/custom.env \\-p 8848:8848 \\-p 9848:9848 \\-p 9849:9849 \\--restart=always \\--network net acos 启动完成后，访问下面地址：http://192.168.150.101:8848/nacos/，注意将`192.168.150.101`替换为你自己的虚拟机IP地址。 首次访问会跳转到登录页，账号密码都是nacos","tags":["linux"],"categories":["linux"]},{"title":"数据结构","path":"/2024/03/23/数据结构/","content":"[TOC] 数据结构 顺序表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MaxSize 10 // 定义最大长度typedef struct&#123; int data[MaxSize]; // 使用静态的数组存放数据元素 int length; // 顺序表的当前长度&#125; SqList;// 在顺序表i位置插入ebool ListInsert(SqList *L, int i, int e)&#123; if (i &lt; 1 || i &gt; L-&gt;length + 1) // 判断i的范围是否有效 return false; if (L-&gt;length &gt;= MaxSize) // 判断存储空间是否已满 return false; for (int j = L-&gt;length; j &gt;= i; j--) // 将第i个元素之后的元素后移 L-&gt;data[j] = L-&gt;data[j - 1]; L-&gt;data[i - 1] = e; // 在位置i处放入e L-&gt;length++; // 长度+1 return true;&#125;// 初始化顺序表void InitList(SqList *&amp;L)&#123; L = (SqList *)malloc(sizeof(SqList)); L-&gt;length = 0; // 顺序表初始长度为0&#125;// 添加元素void AddList(SqList *L)&#123; int i = 0; while (i &lt;= 5) &#123; L-&gt;length++; L-&gt;data[i] = i; i++; &#125;&#125;// 打印元素void printList(SqList *L)&#123; for (int i = 0; i &lt; L-&gt;length; i++) &#123; printf(&quot;%d&quot;, L-&gt;data[i]); &#125;&#125;int main()&#123; SqList *L; // 声明一个顺序表 InitList(L); // 初始化顺序表 AddList(L);//添加元素 ListInsert(L, 3, 3); // 在指定位置插入3 printList(L);//打印元素 return 0;&#125; 单链表两种实现方式： 带头结点，写代码更方便。头结点不存储数据，头结点指向的下一个结点才存放实际数据。 不带头结点，麻烦。对第一个数据结点与后续数据结点的处理需要用不同的代码逻辑，对空表和非空表的处理需要用不同的代码逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int// 结构体typedef struct LNode&#123; int data; struct LNode *next;&#125; LNode;// 初始化单链表void InitList(LNode *&amp;L)&#123; L = (LNode *)malloc(sizeof(LNode)); L-&gt;next = NULL; // 创建头结点，并且将next指向null&#125;// 输出单链表void DispList(LNode *L)&#123; LNode *p = L-&gt;next; while (p != NULL) &#123; printf(&quot;%d&quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot; &quot;);&#125;// 判断单链表是否为空bool ListEmpty(LNode *L)&#123; return (L-&gt;next == NULL);&#125;// 求单链表的长度int ListLength(LNode *L)&#123; int n = 0; LNode *p = L; while (p-&gt;next != NULL) &#123; n++; p = p-&gt;next; &#125; return n;&#125;// 向单链表中添加元素void AddList(LNode *&amp;L)&#123; LNode *p,*s; p=L; for (int i = 0; i &lt; 10; i++) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=i; p-&gt;next=s; p=p-&gt;next; &#125; p-&gt;next=NULL; &#125;// 主函数int main()&#123; LNode *L; InitList(L); AddList(L); DispList(L); return 0;&#125; 单链表尾插法12345678910111213141516// 向单链表中添加元素void AddList(LNode *&amp;L)&#123; LNode *p,*s; p=L; for (int i = 0; i &lt; 10; i++) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=i; p-&gt;next=s; p=p-&gt;next; &#125; p-&gt;next=NULL; &#125; 单链表头插法1234567891011121314void AddList(LNode *&amp;L)&#123; LNode *p,*s; p=L; for (int i = 0; i &lt; 10; i++) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=i; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125; &#125; 双链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int// 结构体typedef struct DNode&#123; // 定义双链表结点类型 ElemType data; // 数据域 struct DNode *prior; // 前驱指针 struct DNode *next; // 后继指针&#125; DNode;// 初始化双链表void InitList(DNode *&amp;L)&#123; L = (DNode *)malloc(sizeof(DNode)); L-&gt;next = NULL; // 将next指向null L-&gt;prior = NULL; // 将prior指向null&#125;// 判断双链表是否为空bool Empty(DNode *L)&#123; if (L-&gt;next == NULL) return true; else return false;&#125;// 输出单链表void DispList(DNode *L)&#123; DNode *p = L-&gt;next; while (p != NULL) &#123; printf(&quot;%d&quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot; &quot;);&#125;// 判断单链表是否为空bool ListEmpty(DNode *L)&#123; return (L-&gt;next == NULL);&#125;// 向单链表中添加元素（尾插法）void AddList1(DNode *&amp;L)&#123; DNode *p, *s; p = L; for (int i = 0; i &lt; 10; i++) &#123; s = (DNode *)malloc(sizeof(DNode)); s-&gt;data = i; s-&gt;prior = p; p-&gt;next = s; p = p-&gt;next; &#125; p-&gt;next = NULL;&#125;// 向单链表中添加元素（头插法）void AddList(DNode *&amp;L)&#123; DNode *p, *s; p = L; for (int i = 0; i &lt; 10; i++) &#123; s = (DNode *)malloc(sizeof(DNode)); s-&gt;data = i; s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125;&#125;// 主函数int main()&#123; DNode *L; InitList(L); AddList(L); DispList(L); return 0;&#125; 栈栈的基本操作 InitStack(&amp;S)：初始化栈。构造一个空栈 S，分配内存空间。 DestroyStack(&amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。 Push(&amp;S, x)：进栈。若栈 S 未满，则将 x 加入使其成为新的栈顶元素。 Pop(&amp;S, &amp;x)：出栈。若栈 S 非空，则弹出（删除）栈顶元素，并用 x 返回。 GetTop(S, &amp;x)：读取栈顶元素。若栈 S 非空，则用 x 返回栈顶元素。 StackEmpty(S)：判空。断一个栈 S 是否为空，若 S 为空，则返回 true，否则返回 false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MaxSize 10// 结构体typedef struct&#123; ElemType data[10]; // 静态数组存放栈中元素 int top; // 栈顶元素&#125; SqStack;// 初始化栈void InitList(SqStack *&amp;L)&#123; L = (SqStack *)malloc(sizeof(SqStack)); L-&gt;top = -1;&#125;// 判断栈是否为空bool StackEmpty(SqStack *S)&#123; if (S-&gt;top == -1) return true; else return false;&#125;// 新元素进栈void push(SqStack *S)&#123; // 判断栈是否已满 if (S-&gt;top == MaxSize - 1) &#123; printf(&quot;栈满&quot;); &#125; else &#123; for (int i = 0; i &lt; MaxSize-1; i++) &#123; S-&gt;top++; S-&gt;data[S-&gt;top] = i; &#125; &#125;&#125;// 出栈bool Pop(SqStack *S,int x)&#123; // 判断栈是否为空 if (S-&gt;top == -1) &#123; printf(&quot;栈空&quot;); &#125;else&#123; printf(&quot;出栈了：&quot;); for (int i = 0; i &lt; x; i++) &#123; printf(&quot;%d &quot;,S-&gt;data[S-&gt;top]); S-&gt;top--; &#125; &#125;&#125;//打印栈内元素// 主函数int main()&#123; SqStack *s; InitList(s); push(s); //出栈2次 Pop(s,2); return 0;&#125; 队列 队列的基本操作 InitQueue(&amp;Q)：初始化队列。构造一个空队列 Q。 DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列 Q 所占用的内存空间。 EnQueue(&amp;Q, x)：入队。若队列 Q 未满，将 x 加入，使之成为新的队尾。 DeQueue(&amp;Q, &amp;x)：出队。若队列 Q 非空，删除队头元素，并用 x 返回。 GetHead(Q,&amp;x)：读队头元素。若队列 Q 非空，则将队头元素赋值给 x。 QueueEmpty(Q)：判空。若队列 Q 为空，则返回 true。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MaxSize 10// 结构体typedef struct&#123; ElemType data[MaxSize]; // 用静态数组存放队列元素 int front, rear; // 队头指针和队尾指针&#125; SqQueue;// 初始化void InitQueue(SqQueue *&amp;q)&#123; q = (SqQueue *)malloc(sizeof(SqQueue)); q-&gt;front = q-&gt;rear = -1;&#125;// 入栈void EnQueue(SqQueue *q)&#123; if (q-&gt;rear == MaxSize - 1) &#123; printf(&quot;栈满&quot;); &#125; else &#123; for (int i = 0; i &lt; MaxSize - 1; i++) &#123; q-&gt;rear++; q-&gt;data[q-&gt;rear] = i; &#125; &#125;&#125;// 出队void DeQueue(SqQueue *q, int x)&#123; if (q-&gt;front == q-&gt;rear) &#123; printf(&quot;队空&quot;); &#125; else &#123; for (int i = 0; i &lt; x; i++) &#123; q-&gt;front++; printf(&quot;%d&quot;,q-&gt;data[i]); &#125; &#125;&#125;// 主函数int main()&#123; SqQueue *q; InitQueue(q); EnQueue(q); // 出队2次 DeQueue(q, 2); return 0;&#125; 串","tags":["数据结构"],"categories":["数据结构"]},{"title":"uniapp","path":"/2024/03/21/uniapp/","content":"UniApp开发1.下载开发者工具1.1打开官网https://www.dcloud.io/hbuilderx.html下载对应版本 1.2.新建项目，选择默认模版，自定义目录 2.将项目运行在微信小程序中2.1打开微信小程序开发的设置界面，开启服务端口，回到，uni编辑器，再次运行，可能需要填写微信小程序开发者工具的安装路径 3.认识目录 配置文件1234567891011121314151617181920212223242526272829303132&#123;\t&quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages &#123; &quot;path&quot;: &quot;pages/index/index&quot;, &quot;style&quot;: &#123; //页面顶部标题 &quot;navigationBarTitleText&quot;: &quot;首页&quot; &#125; &#125;\t],\t&quot;globalStyle&quot;: &#123; &quot;navigationBarTextStyle&quot;: &quot;black&quot;, //导航栏标题文字内容 &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;, //导航栏背景颜色 &quot;navigationBarBackgroundColor&quot;: &quot;#F8F8F8&quot;, //导航栏背景颜色 &quot;backgroundColor&quot;: &quot;#F8F8F8&quot;\t&#125;,\t&quot;uniIdRouter&quot;: &#123;&#125;,\t&quot;condition&quot; : &#123; //模式配置，仅开发期间生效 &quot;current&quot;: 0, //当前激活的模式(list 的索引项) &quot;list&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, //模式名称 &quot;path&quot;: &quot;&quot;, //启动页面，必选 &quot;query&quot;: &quot;&quot; //启动参数，在页面的onLoad函数里面得到 &#125; ]\t&#125;&#125; 添加tabar为底部添加tabar，并在tarbar对页面进行切换 123456789101112&quot;tabBar&quot;: &#123; &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/my/my&quot;, &quot;text&quot;: &quot;我的&quot; &#125; ]\t&#125; 在底部出现底部导航栏，添加图片，将图表放在静态文件夹下通过设置来显示 1234//默认的颜色&quot;iconPath&quot;: &quot;static/...&quot;,//选中的样色&quot;selectedIconPath&quot;: &quot;static/...&quot;, 设置路径 设置选中的颜色 在tabar下设置selectedcolor改为主题色 轮播图12345678&lt;swiper :indicator-dots=&quot;true&quot; :autoplay=&quot;true&quot; :interval=&quot;3000&quot; :duration=&quot;1000&quot;&gt; &lt;swiper-item&gt; &lt;view class=&quot;swiper-item&quot;&gt;&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class=&quot;swiper-item&quot;&gt;&lt;/view&gt; &lt;/swiper-item&gt;\t&lt;/swiper&gt; 默认全屏宽度750rpx， 点击事件@tap&#x3D;“事件” 引入 uni-ui 组件库操作步骤安装 uni-ui 组件库 1pnpm i @dcloudio/uni-ui 配置自动导入组件 1234567891011121314// pages.json&#123; // 组件自动导入 &quot;easycom&quot;: &#123; &quot;autoscan&quot;: true, &quot;custom&quot;: &#123; // uni-ui 规则如下配置 // [!code ++] &quot;^uni-(.*)&quot;: &quot;@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue&quot; // [!code ++] &#125; &#125;, &quot;pages&quot;: [ // …省略 ]&#125; 安装类型声明文件（ts用） 1npm i -D @uni-helper/uni-ui-types 配置类型声明文件（ts用） 12345678910111213141516// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; // ... &quot;types&quot;: [ &quot;@dcloudio/types&quot;, // uni-app API 类型 &quot;miniprogram-api-typings&quot;, // 原生微信小程序类型 &quot;@uni-helper/uni-app-types&quot;, // uni-app 组件类型 &quot;@uni-helper/uni-ui-types&quot; // uni-ui 组件类型 // [!code ++] ] &#125;, // vue 编译器类型，校验标签类型 &quot;vueCompilerOptions&quot;: &#123; &quot;nativeTags&quot;: [&quot;block&quot;, &quot;component&quot;, &quot;template&quot;, &quot;slot&quot;] &#125;&#125; 持久化存储插件安装持久化存储插件： pinia-plugin-persistedstate 1pnpm i pinia-plugin-persistedstate 插件默认使用 localStorage 实现持久化，小程序端不兼容，需要替换持久化 API。 基本用法::: code-group &#123;28-31&#125; [stores/modules/member.ts]12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref &#125; from &#x27;vue&#x27;// 定义 Storeexport const useMemberStore = defineStore( &#x27;member&#x27;, () =&gt; &#123; // 会员信息 const profile = ref&lt;any&gt;() // 保存会员信息，登录时使用 const setProfile = (val: any) =&gt; &#123; profile.value = val &#125; // 清理会员信息，退出时使用 const clearProfile = () =&gt; &#123; profile.value = undefined &#125; // 记得 return return &#123; profile, setProfile, clearProfile, &#125; &#125;, // TODO: 持久化 &#123; //只能在网页端使用 //persist: true, persist:&#123; storage:&#123; getItem(key)&#123; return uni.getStorageSync(key) &#125;, setItem(key,value)&#123; uni.setStorageSync(key,value) &#125; &#125; &#125; &#125;,) &#123;2,7&#125; [stores/index.ts]12345678910111213import &#123; createPinia &#125; from &#x27;pinia&#x27;import persist from &#x27;pinia-plugin-persistedstate&#x27;// 创建 pinia 实例const pinia = createPinia()// 使用持久化存储插件pinia.use(persist)// 默认导出，给 main.ts 使用export default pinia// 模块统一导出export * from &#x27;./modules/member&#x27; &#123;2,8&#125; [main.ts]123456789101112import &#123; createSSRApp &#125; from &#x27;vue&#x27;import pinia from &#x27;./stores&#x27;import App from &#x27;./App.vue&#x27;export function createApp() &#123; const app = createSSRApp(App) app.use(pinia) return &#123; app, &#125;&#125;","tags":["uniApp"],"categories":["uniAPP"]},{"title":"hexo自用手册","path":"/2024/03/18/hexo/","content":"Hexo安装node.js下载进入node.js的官网[https://nodejs.org/下载node.js最新稳定版就行 配置环境变量将node.js根目录放入path变量中 安装git（官网下载，傻瓜式安装）安装hexo打开终端输入 1npm install -g hexo-cli 创建项目1hexo init blog 其中blog为项目名字，可以自行修改 安装主题（以butterfly主题为例）进入博客根目录，打开git bash 1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 安装成功后在themes中会出现butterfly文件夹，其中有配置文件_config.yml这是主题配置文件，而在博客根目录中也有配置文件_config.yml，两个配置文件呢不一样，不要混淆 切换主题在项目的配置文件中通过ctrl+f搜索，找到theme将和面的主题配置改为theme: butterfly 设置语言和时区找到配置文件 12language: zh-CHtimezone: Asia/shanghai 设置网站名称主题配置文件中 12345title: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doe 修改即可 下载渲染器1npm install hexo-renderer-pug hexo-renderer-stylus --save 启动项目在根目录终端中输入（简称三连） 1.清除指令 1hexo clean 2.编译指令 1hexo g 3.运行指令 1hexo s 其中编译和运行可以写为一个，这样就不用输入两次了，清除操作只有出bug的时候可以用用，不用每次都用 1hexo g&amp;hexo s 添加首页菜单打开主题配置文件搜索 menu内容如下 12345678910menu: # Home: / || fas fa-home # Archives: /archives/ || fas fa-archive # Tags: /tags/ || fas fa-tags # Categories: /categories/ || fas fa-folder-open # List||fas fa-list: # Music: /music/ || fas fa-music # Movie: /movies/ || fas fa-video # Link: /link/ || fas fa-link # About: /about/ || fas fa-heart 自行修改 12345678910menu: 首页: / || fas fa-home 时间轴: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 娱乐||fas fa-list: 音乐: /music/ || fas fa-music 电影: /movies/ || fas fa-video 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart 注意缩进 主页菜单居中在themes\\butterfly\\source\\css\\custom.css中添加如下内容（如果没有目录创建目录） 123456789101112131415/* 一级菜单居中 */#nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important; &#125; /* 子菜单横向展示 */ #nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important; &#125; /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */ .menus_items .menus_item:nth-child(2) .menus_item_child &#123; left: -125px; &#125; 找到主题配置文件搜索inject导入该css文件 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; 设置背景（一图流为例）在themes\\butterfly\\source\\css\\custom.css中添加如下内容（如果没有目录创建目录） 1234567891011121314151617181920212223/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125; /* /* 白天模式遮罩透明#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125; *//* 夜间模式遮罩透明 *//* [data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; */ 可以按照自己喜好进行选择取消注释 在主题配置文件中搜索background,更改图片 在线图片1background: url(www.example.com)#修改自己图片的网站 本地文件在themes\\butterfly\\source\\img下放入要使用的背景图 1background: url(/img/3.jpg)#填你自己的图片名称 开启动画（选择）找到主题配置文件 12# 加载动画 Loading Animationpreloader: true markdown文档头部说明 写法 解释 title 【必需】页面标题 date 【必需】页面创建日期 type(仅仅部分文件需要) 【必需】仅仅标籤、分类和友情链接三个页面需要配置 updated 【可选】页面更新日期 description 【可选】页面描述 keywords 【可选】页面关键字 comments 【可选】显示页面评论模块(默认 true) top_img 【可选】页面顶部图片 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) kates 【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false) aside 【可选】显示侧边栏 (默认 true) aplayer 【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置 highlight_shrink 【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置) 新增页面用于存放页面，现在的标签和分类是打不开的，需要自己创建 停止项目 1hexo new page ****(要创建的页面，根据主页菜单来进行选择) 如（这里是菜单） 12345678910menu: 首页: / || fas fa-home 时间轴: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 娱乐||fas fa-list: 音乐: /music/ || fas fa-music 电影: /movies/ || fas fa-video 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart 要创建分类 1hexo new page categories 这样会在source\\下创建了一个md文件 新增 1type: categories 这样，一个分类页面就做好了，以此类推。 开启显示文章描述，有利于页面更加简洁找到theme主题 配置项index_post_content将method改为2（显示描述）或3（显示文章内容），想要更加简洁的话可以使用2 首页打字效果12345678910111213141516171819subtitle: enable: true # Typewriter Effect (打字效果) effect: true # Customize typed.js (配置typed.js) # https://github.com/mattboldt/typed.js/#customization typed_option: # source 調用第三方服務 # source: false 關閉調用 # source: 1 調用一言網的一句話（簡體） https://hitokoto.cn/ # source: 2 調用一句網（簡體） https://yijuzhan.com/ # source: 3 調用今日詩詞（簡體） https://www.jinrishici.com/ # subtitle 會先顯示 source , 再顯示 sub 的內容 source: false # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字 sub: -*********** -*********** 按照格式设置即可 更改头像在线头像 123avatar: img: https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png effect: false 本地头像 123avatar: img: /img/2.jpg effect: false 与背景图同理 文章置顶 你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。 图片懒加载新增hexo-lazyload-image模块 1npm install hexo-lazyload-image --save 在站点配置文件_config.yml增加配置 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost: 是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片.loadingImg - 图片未加载时的代替图不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \\themes ext\\source\\images 目录下, 然后引用时: loadingImg: &#x2F;images&#x2F;图片文件名 增加PDF阅读器1npm install --save hexo-pdf 将PDF放入md文件对应的资源文件夹在md文件中插入 1&#123;% pdf 1.pdf %&#125; 魔改魔改鼠标 新建文件[BlogRoot]\\source\\js\\cursor.js，在里面写上如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var CURSOR;Math.lerp = (a, b, n) =&gt; (1 - n) * a + n * b;const getStyle = (el, attr) =&gt; &#123; try &#123; return window.getComputedStyle ? window.getComputedStyle(el)[attr] : el.currentStyle[attr]; &#125; catch (e) &#123;&#125; return &quot;&quot;;&#125;;class Cursor &#123; constructor() &#123; this.pos = &#123;curr: null, prev: null&#125;; this.pt = []; this.create(); this.init(); this.render(); &#125; move(left, top) &#123; this.cursor.style[&quot;left&quot;] = `$&#123;left&#125;px`; this.cursor.style[&quot;top&quot;] = `$&#123;top&#125;px`; &#125; create() &#123; if (!this.cursor) &#123; this.cursor = document.createElement(&quot;div&quot;); this.cursor.id = &quot;cursor&quot;; this.cursor.classList.add(&quot;hidden&quot;); document.body.append(this.cursor); &#125; var el = document.getElementsByTagName(&#x27;*&#x27;); for (let i = 0; i &lt; el.length; i++) if (getStyle(el[i], &quot;cursor&quot;) == &quot;pointer&quot;) this.pt.push(el[i].outerHTML); document.body.appendChild((this.scr = document.createElement(&quot;style&quot;))); // 这里改变鼠标指针的颜色 由svg生成 this.scr.innerHTML = `* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;.5&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;`; &#125; refresh() &#123; this.scr.remove(); this.cursor.classList.remove(&quot;hover&quot;); this.cursor.classList.remove(&quot;active&quot;); this.pos = &#123;curr: null, prev: null&#125;; this.pt = []; this.create(); this.init(); this.render(); &#125; init() &#123; document.onmouseover = e =&gt; this.pt.includes(e.target.outerHTML) &amp;&amp; this.cursor.classList.add(&quot;hover&quot;); document.onmouseout = e =&gt; this.pt.includes(e.target.outerHTML) &amp;&amp; this.cursor.classList.remove(&quot;hover&quot;); document.onmousemove = e =&gt; &#123;(this.pos.curr == null) &amp;&amp; this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = &#123;x: e.clientX - 8, y: e.clientY - 8&#125;; this.cursor.classList.remove(&quot;hidden&quot;);&#125;; document.onmouseenter = e =&gt; this.cursor.classList.remove(&quot;hidden&quot;); document.onmouseleave = e =&gt; this.cursor.classList.add(&quot;hidden&quot;); document.onmousedown = e =&gt; this.cursor.classList.add(&quot;active&quot;); document.onmouseup = e =&gt; this.cursor.classList.remove(&quot;active&quot;); &#125; render() &#123; if (this.pos.prev) &#123; this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15); this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15); this.move(this.pos.prev.x, this.pos.prev.y); &#125; else &#123; this.pos.prev = this.pos.curr; &#125; requestAnimationFrame(() =&gt; this.render()); &#125;&#125;(() =&gt; &#123; CURSOR = new Cursor(); // 需要重新获取列表时，使用 CURSOR.refresh()&#125;)(); 其中比较重要的参数就是鼠标的尺寸和颜色，已经在上图中标出，目前发现颜色只支持RGB写法和固有名称写法（例如red这种），其他参数也可以自行摸索： 1* &#123;cursor: url(&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;1.0&#x27; fill=&#x27;rgb(57, 197, 187)&#x27;/&gt;&lt;/svg&gt;&quot;) 4 4, auto&#125;` 在[BlogRoot]\\source\\css\\custom.css添加如下代码： 123456789101112131415161718192021222324252627282930313233343536/* 鼠标样式 */#cursor &#123; position: fixed; width: 16px; height: 16px; /* 这里改变跟随的底色 */ background: var(--theme-color); border-radius: 8px; opacity: 0.25; z-index: 10086; pointer-events: none; transition: 0.2s ease-in-out; transition-property: background, opacity, transform;&#125;#cursor.hidden &#123; opacity: 0;&#125;#cursor.hover &#123; opacity: 0.1; transform: scale(2.5); -webkit-transform: scale(2.5); -moz-transform: scale(2.5); -ms-transform: scale(2.5); -o-transform: scale(2.5);&#125;#cursor.active &#123; opacity: 0.5; transform: scale(0.5); -webkit-transform: scale(0.5); -moz-transform: scale(0.5); -ms-transform: scale(0.5); -o-transform: scale(0.5);&#125; 这里比较重要的参数就是鼠标跟随的圆形颜色，可以根据自己的喜好进行更改： 1234#cursor &#123; /* 这里改变跟随的底色 */ background: rgb(57, 197, 187);&#125; 在主题配置文件_config.butterfly.yml文件的inject配置项引入刚刚创建的css文件和js文件： 12345inject: head: + - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; bottom:+ - &lt;script defer src=&quot;/js/cursor.js&quot;&gt;&lt;/script&gt; 重启项目即可看见效果： 12BASHhexo cl; hexo s 友链制作1.通过命令创建友链页面 1hexo new page link 2.在[Blogroot]\\source\\link\\index.md 中添加内容 12345---title: linkdate: 2020-12-01 22:19:45type: &#x27;link&#x27;--- 3.新建文件[Blogroot]\\source\\_data\\link.yml没有_data文件夹的话也请自己新建;输入（以安知鱼为列） 12345678- class_name: 推荐博客 flink_style: flexcard link_list: - name: 安知鱼`Blog link: https://blog.anheyu.com/ avatar: https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg descr: 生活明朗，万物可爱 siteshot: https://npm.elemecdn.com/anzhiyu-theme-static@1.1.6/img/blog.anheyu.com.jpg 页脚 首先要卸载店长的hexo-butterfly-footer-beautify插件，因为我将页脚直接写成一个pug，个人觉得插件很多冗余的地方用不到，因此卸载了，否则会冲突： 1npm un hexo-butterfly-footer-beautify --save 在主题配置文件_config.butterfly.yml或者站点配置文件_config.yml删除插件相关的配置项： 123456789101112131415161718192021222324252627282930313233343536373839404142DIFF-footer_beautify:- enable:- timer: true # 计时器开关- bdage: true # 徽标开关- priority: 5 #过滤器优先权- enable_page: all # 应用页面- exclude: #屏蔽页面- # - /posts/- # - /about/- layout: # 挂载容器类型- type: id- name: footer-wrap- index: 0- runtime_js: https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js- runtime_css: https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css- # 徽标部分配置项- swiperpara: 0 #若非0，则开启轮播功能，每行徽标个数- bdageitem:- - link: https://hexo.io/ #徽标指向网站链接- shields: https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo #徽标API- message: 博客框架为Hexo_v6.2.0 #徽标提示语- - link: https://butterfly.js.org/- shields: https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender- message: 主题版本Butterfly_v4.3.1- - link: https://vercel.com/- shields: https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel- message: 本站采用多线部署，主线路托管于Vercel- - link: https://dashboard.4everland.org/- # https://img.shields.io/badge/Hosted-4EVERLAND-3FE2C1?style=flat&amp;logo=IPFS- shields: https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS- message: 本站采用多线部署，备用线路托管于4EVERLAND- - link: https://github.com/- shields: https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub- message: 本站项目由Github托管- - link: http://creativecommons.org/licenses/by-nc-sa/4.0/- shields: https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris- message: 本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可- swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css- swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js- swiperbdage_init_js: https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js 将[BlogRoot]/themes/butterfly/layout/includes/footer.pug替换成如下代码这块东西分为几个部分，一个是以#ft为块的DOM，其中分为了格言、猜你想看、推荐友链三部分，参考图中的位置结合自己的喜好进行修改即可，图像、文字和链接均替换成你自己的（记住不要用我的链接！！！）；if theme.footer.owner.enable起这一块是主题指定的信息版权信息，我把主题配置项的copyright和custom_text这两项留空了，因此只会显示©2022 By Fomalhaut🥝；再然后就是#workboard这块，这块的信息由js逻辑写入与更新，可以自定义；最后是p#ghbdages这块，是徽标显示，大家可以到shields.io按照自己的信息生成（不要用我的！！！）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109PLAINTEXT复制成功#footer-wrap #ft .ft-item-1 .t-top .t-t-l p.ft-t.t-l-t 格言🧬 .bg-ad div | 再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨ .btn-xz-box a.btn-xz(href=&#x27;https://stellarium.org/&#x27;) 点击开启星辰之旅 .t-t-r p.ft-t.t-l-t 猜你想看💡 ul.ft-links li a(href=&#x27;/posts/eec9786.html&#x27;) 魔改指南 a(href=&#x27;/box/nav/&#x27;) 网址导航 li a(href=&#x27;/social/link/&#x27;) 我的朋友 a(href=&#x27;/comments/&#x27;) 留点什么 li a(href=&#x27;/personal/about/&#x27;) 关于作者 a(href=&#x27;/archives/&#x27;) 文章归档 li a(href=&#x27;/categories/&#x27;) 文章分类 a(href=&#x27;/tags/&#x27;) 文章标签 li a(href=&#x27;/box/Gallery/&#x27;) 我的画廊 a(href=&#x27;/personal/bb/&#x27;) 我的唠叨 li a(href=&#x27;/site/time/&#x27;) 建设进程 a(href=&#x27;/site/census/&#x27;) 网站统计 .ft-item-2 p.ft-t 推荐友链⌛ .ft-img-group .img-group-item a(href=&#x27;https://www.fomal.cc/&#x27; title=&#x27;Fomalhaut🥝&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://tzy1997.com/&#x27; title=&#x27;唐志远の博客&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/4ab83cdce942463b.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://akilar.top/&#x27; title=&#x27;Akilarの糖果屋&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/6bf1ed05796db59c.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://butterfly.js.org/&#x27; title=&#x27;Butterfly&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/64cc6a7d508026e1.png&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://anzhiy.cn/&#x27; title=&#x27;安知鱼&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/1b33fef8f5fb7e63.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://www.acozycotage.net/&#x27; title=&#x27;Acozycotage&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/6a6fe6ebfd19c465.jpg&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;https://cdn.netdun.net/&#x27; title=&#x27;网盾星球&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/70dee3f9d1ca10f3.webp&#x27; alt=&#x27;&#x27;) .img-group-item a(href=&#x27;javascript:void(0)&#x27; title=&#x27;广告位招租&#x27;) img(src=&#x27;https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp&#x27; alt=&#x27;&#x27;) if theme.footer.owner.enable - var now = new Date() - var nowYear = now.getFullYear() if theme.footer.owner.since &amp;&amp; theme.footer.owner.since != nowYear .copyright span!= `&lt;b&gt;©$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125;&lt;/b&gt;` span!= `&lt;b&gt; By $&#123;config.author&#125;&lt;/b&gt;` else .copyright span!= `&lt;b&gt;©$&#123;nowYear&#125;&lt;/b&gt;` span!= `&lt;b&gt; By $&#123;config.author&#125;&lt;/b&gt;` if theme.footer.copyright .framework-info span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27; a(href=&#x27;https://hexo.io&#x27;)= &#x27;Hexo&#x27; span.footer-separator | span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27; a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= &#x27;Butterfly&#x27; if theme.footer.custom_text .footer_custom_text!=`$&#123;theme.footer.custom_text&#125;` #workboard p#ghbdages a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://hexo.io/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;博客框架为Hexo_v6.3.0&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://butterfly.js.org/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;主题版本Butterfly_v4.3.1&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://vercel.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站采用多线部署，主线路托管于Vercel&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://user.51.la/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站数据分析得益于51la技术支持&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://icp.gov.moe/?keyword=20226665&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站已加入萌ICP豪华套餐，萌ICP备20226665号&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://bitiful.dogecast.com/buckets&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站经Service Worker分流至缤纷云对象存储&quot;) img(src=&quot; https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://www.netdun.net/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站使用网盾星球提供CDN加速与防护&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://github.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站源码由Github提供存储仓库&quot;) img(src=&quot; https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg&quot; alt=&#x27;&#x27;) 将以下代码复制到自定义的custom.css中，其中颜色、圆角等可以根据你自己的喜好进行修改: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246/* tzy页脚样式 */#ft &#123; max-width: 1200px; margin: 0 auto 12px; display: flex; color: rgb(255 255 255 / 80%) !important; text-align: left; flex-wrap: wrap;&#125;.ft-item-1,.ft-item-2 &#123; display: flex; height: 100%; padding: 2px 14px;&#125;.ft-item-1 &#123; flex-direction: column; flex: 2;&#125;.ft-item-2 &#123; flex: 1; flex-direction: column;&#125;.t-top &#123; display: flex;&#125;.t-top .t-t-l &#123; display: flex; flex-direction: column; flex: 1.4; margin-right: 10px;&#125;.t-top .t-t-l .bg-ad &#123; width: 85%; border-radius: 10px; padding: 0 10px;&#125;.btn-xz-box &#123; margin-top: 10px;&#125;/* 按钮背景颜色等 */.btn-xz &#123; display: block; background-color: var(--btn-bg); color: var(--btn-color); text-align: center; line-height: 2.4; margin: 8px 0;&#125;.btn-xz:hover &#123; text-decoration: none !important;&#125;/* 按钮悬浮颜色 */.btn-xz-box:hover .btn-xz &#123; background-color: var(--text-bg-hover);&#125;.t-top .t-t-r &#123; display: flex; flex-direction: column; flex: 1;&#125;.ft-links &#123; padding: 0 14px; list-style: none; margin-top: 0 !important;&#125;.ft-links li a &#123; display: inline-block !important; width: 50%;&#125;/* 链接悬浮颜色 */.ft-links li a:hover &#123; text-decoration: none !important; color: var(--theme-color) !important;&#125;.ft-item-2 .ft-img-group &#123; width: 100%;&#125;.ft-t &#123; font-size: 1.1rem; margin-bottom: 20px; line-height: 1; font-weight: 600;&#125;.t-l-t &#123; padding-left: 14px;&#125;.ft-item-2 .ft-img-group .img-group-item &#123; display: inline-block; width: 18.4%; margin-right: 14px; margin-bottom: 6px;&#125;.ft-item-2 .ft-img-group .img-group-item a &#123; display: inline-block; width: 100%; height: 100%;&#125;.ft-item-2 .ft-img-group .img-group-item a img &#123; width: 100%; max-height: 80px; border-radius: 10px;&#125;/* 头像悬浮颜色框 */.ft-item-2 .ft-img-group .img-group-item a img:hover &#123; border: 2px solid var(--theme-color);&#125;@media screen and (max-width: 768px) &#123; .ft-item-1 &#123; flex-basis: 100% !important; &#125; .ft-item-2 &#123; flex-basis: 100% !important; &#125; .t-top .t-t-l .bg-ad &#123; width: 100%; &#125;&#125;@media screen and (max-width: 576px) &#123; .t-top &#123; flex-wrap: wrap; &#125; .t-top .t-t-l &#123; flex-basis: 100% !important; &#125; .t-top .t-t-r &#123; margin-top: 16px; flex-basis: 100% !important; &#125;&#125;#footer-wrap a &#123; border-radius: 30px;&#125;#footer-wrap &#123; padding: 20px 20px;&#125;/* 页脚心跳动画 */#heartbeat &#123; color: red; animation: iconAnimate 1s ease-in-out infinite;&#125;@-moz-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@-webkit-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@-o-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125; 然后计时器还要往#footer-wrap这块元素上面写入网站运行时间等信息，新建文件[BlogRoot]\\source\\js\\runtime.js，写入如下代码。这里要修改的几块东西是：网站诞生时间、currentTimeHtml这块东西；其中currentTimeHtml分为了两种模式，对应两个不同的图标，自行研究一下就懂！ 123456789101112131415161718192021222324252627282930313233JS复制成功var now = new Date();function createtime() &#123; // 当前时间 now.setTime(now.getTime() + 1000); var start = new Date(&quot;08/01/2022 00:00:00&quot;); // 旅行者1号开始计算的时间 var dis = Math.trunc(23400000000 + ((now - start) / 1000) * 17); // 距离=秒数*速度 记住转换毫秒 var unit = (dis / 149600000).toFixed(6); // 天文单位 var grt = new Date(&quot;08/09/2022 00:00:00&quot;);\t// 网站诞生时间 var days = (now - grt) / 1e3 / 60 / 60 / 24, dnum = Math.floor(days), hours = (now - grt) / 1e3 / 60 / 60 - 24 * dnum, hnum = Math.floor(hours); 1 == String(hnum).length &amp;&amp; (hnum = &quot;0&quot; + hnum); var minutes = (now - grt) / 1e3 / 60 - 1440 * dnum - 60 * hnum, mnum = Math.floor(minutes); 1 == String(mnum).length &amp;&amp; (mnum = &quot;0&quot; + mnum); var seconds = (now - grt) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum, snum = Math.round(seconds); 1 == String(snum).length &amp;&amp; (snum = &quot;0&quot; + snum); let currentTimeHtml = &quot;&quot;; (currentTimeHtml = hnum &lt; 18 &amp;&amp; hnum &gt;= 9 ? `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://sourcebucket.s3.ladydaily.com/badge/F小屋-科研摸鱼中.svg&#x27; title=&#x27;什么时候能够实现财富自由呀~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt;本站居然运行了 $&#123;dnum&#125; 天 $&#123;hnum&#125; 小时 $&#123;mnum&#125; 分 $&#123;snum&#125; 秒 &lt;i id=&quot;heartbeat&quot; class=&#x27;fas fa-heartbeat&#x27;&gt;&lt;/i&gt; &lt;br&gt; 旅行者 1 号当前距离地球 $&#123;dis&#125; 千米，约为 $&#123;unit&#125; 个天文单位 🚀&lt;/div&gt;` : `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg&#x27; title=&#x27;下班了就该开开心心地玩耍~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt;本站居然运行了 $&#123;dnum&#125; 天 $&#123;hnum&#125; 小时 $&#123;mnum&#125; 分 $&#123;snum&#125; 秒 &lt;i id=&quot;heartbeat&quot; class=&#x27;fas fa-heartbeat&#x27;&gt;&lt;/i&gt; &lt;br&gt; 旅行者 1 号当前距离地球 $&#123;dis&#125; 千米，约为 $&#123;unit&#125; 个天文单位 🚀&lt;/div&gt;`), document.getElementById(&quot;workboard&quot;) &amp;&amp; (document.getElementById(&quot;workboard&quot;).innerHTML = currentTimeHtml);&#125;// 设置重复执行函数，周期1000mssetInterval(() =&gt; &#123; createtime();&#125;, 1000); 在主题配置文件_config.butterfly.yml引入该runtime.js文件： 1234DIFFinject: bottom: + - &lt;script defer src=&quot;/js/runtime.js&quot;&gt;&lt;/script&gt; # 页脚计时器 到这里你已经成功了 99.99%，最后重新编译运行即可看见效果 12BASHhexo cl; hexo s 添加图片1.1.找到Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true 2.在Hexo目录下打开Git Brsh，执行一个下载上传图片插件的命令npm install https://github.com/CodeFalling/hexo-asset-image(bug,插件bug) 3.继续在Git Brsh下利用hexo n “xxxx”来生成md的文件（” “里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。 4.在.md的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。 设置代码默认长度在主题配置文件中修改highlight_height_limit 后面数字为像素px 一图流 在[BlogRoot]\\source文件夹下新建一个文件夹css，该文件夹用于存放自定义的css样式，再新建一个名为custom.css，在里面写入以下代码： 123456789101112131415161718192021222324/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125;/* 白天模式遮罩透明 */#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125;/* 夜间模式遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; 在主题配置文件[BlogRoot]\\_config.butterfly.yml文件中的inject配置项的head子项加入以下代码，代表引入刚刚创建的custom.css文件（这是相对路径的写法） 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 在主题配置文件[BlogRoot]\\_config.butterfly.yml文件中的index_img和footer_bg配置项取消头图与页脚图的加载项避免冗余加载 12345# The banner image of home pageindex_img: # Footer Backgroundfooter_bg: false 部分人反映一图流改完了背景图也没了，那大概率是你之前没设置背景图。在主题配置文件[BlogRoot]\\_config.butterfly.yml文件中的background配置项设置背景图 1background: url(https://source.fomal.cc/img/home_bg.webp) 文章页面侧面菜单只保留目录在主题配置文件中将style_simple改为true 主页导航栏居中123456789101112131415 /* 一级菜单居中 */#nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important; &#125; /* 子菜单横向展示 */ #nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important; &#125; /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */ .menus_items .menus_item:nth-child(2) .menus_item_child &#123; left: -125px; &#125; 设置文章标题居中找到themes\\butterfly\\source\\css\\_layout\\head.styl目录，修改post-info 123456#post-info position: absolute bottom: 120px padding: 0 8% width: 100% text-align: center 修改字体大小在主题配置文件中font设置 将文章栏目改为双栏 在博客根目录[BlogRoot]下打开终端，运行以下指令： 1npm i hexo-butterfly-article-double-row --save 在网站配置文件_config.yml新增以下项 (注意不是主题配置文件)： 12butterfly_article_double_row: enable: true 这时候插件有个bug，就是最后一页文章数目为奇数的时候，会出现这种情况 会显得很不舒服，感谢唐志远大佬修复了这个bug，只需要在custom.css文件添加以下代码即可： 12345/* 翻页按钮居中 */#pagination &#123; width: 100%; margin: auto;&#125; 执行 hexo 三连： 123hexo cleanhexo ghexo s 首页分类（未成功）效果预览 安装插件,在博客根目录[BlogRoot]下打开终端，运行以下指令： 1npm install hexo-butterfly-categories-card --save 添加配置信息，以下为写法示例在站点配置文件_config.yml或者主题配置文件_config.butterfly.yml中添加以下代码，注意要根据他的默认描述排序改为你自己对应的分类名字： 1234567891011121314151617181920212223242526# hexo-butterfly-categories-card# see https://akilar.top/posts/a9131002/categoryBar: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: / # 应用页面 layout: # 挂载容器类型 type: id name: recent-posts index: 0 column: odd # odd：3列 | even：4列 row: 1 #显示行数，默认两行，超过行数切换为滚动显示 message: - descr: Ubuntu指南 cover: https://assets.akilar.top/image/cover1.webp - descr: 玩转Win10 cover: https://assets.akilar.top/image/cover2.webp - descr: 长篇小说连载 cover: https://assets.akilar.top/image/cover3.webp - descr: 个人日记 cover: https://assets.akilar.top/image/cover4.webp - descr: 诗词歌赋 cover: https://assets.akilar.top/image/cover5.webp - descr: 杂谈教程 cover: https://assets.akilar.top/image/cover6.webp custom_css: https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css 参数释义 参数 备选值&#x2F;类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）,如根目录就填’&#x2F;‘,分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为’&#x2F;‘ layout.type id&#x2F;class 【可选】挂载容器类型，填写id或class，不填则默认为id layout.name text 【必选】挂载容器名称 layout.index 0和正整数 【可选】前提是layout.type为class，因为同一页面可能有多个class，此项用来确认究竟排在第几个顺位 column odd&#x2F;even 【可选】显示列数，考虑到比例问题，只提供3列和4列，odd为3列， even为4列 row number 【可选】显示行数，默认两行，超过行数切换为滚动显示 message.descr text 分类描述,需要和你自己的文章分类一一对应。 message.cover url 分类背景,需要和你自己的文章分类一一对应。 custom_css url 【可选】自定义样式，会替换默认的css链接，可以下载文档给出的cdn链接后自主修改 置顶文章并且滚动 安装插件,在博客根目录[BlogRoot]下打开终端，运行以下指令： 1npm install hexo-butterfly-swiper --save 添加配置信息，以下为写法示例在站点配置文件_config.yml或者主题配置文件_config.butterfly.yml中添加 12345678910111213141516# hexo-butterfly-swiper# see https://akilar.top/posts/8e1264d1/swiper: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 timemode: date #date/updated layout: # 挂载容器类型 type: id name: recent-posts index: 0 default_descr: 再怎么看我也不知道怎么描述它的啦！ swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖 swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖 custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁 custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法 参数释义 参数 备选值&#x2F;类型 释义 priority number 【可选】过滤器优先级，数值越小，执行越早，默认为10，选填 enable true&#x2F;false 【必选】控制开关 enable_page path&#x2F;all 【可选】填写想要应用的页面的相对路径（即路由地址）,如根目录就填’&#x2F;‘,分类页面就填’&#x2F;categories&#x2F;‘。若要应用于所有页面，就填’all’，默认为all timemode date&#x2F;updated 【可选】时间显示，date为显示创建日期，updated为显示更新日期,默认为date layout.type id&#x2F;class 【可选】挂载容器类型，填写id或class，不填则默认为id layout.name text 【必选】挂载容器名称 layout.index 0和正整数 【可选】前提是layout.type为class，因为同一页面可能有多个class，此项用来确认究竟排在第几个顺位 default_descr text 默认文章描述 swiper_css url 【可选】自定义的swiper依赖项css链接 swiper_js url 【可选】自定义的swiper依赖项加js链接 custom_css url 【可选】适配主题样式补丁 custom_js url 【可选】swiper初始化方法 使用方法:在文章的front_matter中添加swiper_index配置项即可。 123456789MARKDOWN---title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前--- PDF插件 安装hexo-pdf插件 1npm install hexo-pdf --save 外挂标签的引用格式如下： 标签语法 参数配置 示例源码 1234# 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件&#123;% pdf xxx.pdf %&#125;# 2.在线链接&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125; 重启项目即可看到变更 1hexo cl; hexo s 修改页脚修改页脚内容themes\\butterfly\\layout\\includes\\footer.pug 修改样式themes\\butterfly\\source\\css\\custom.css 修改运行时间themes\\butterfly\\source\\js\\runtime.js CDN直接更换cdn链接即可 更改配置项 链接我这里只列出我在用的cdn，我没有用到的cdn可以在评论中留言，有时间我会补充。 jquery 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js pjax 1https://lib.baomitu.com/pjax/0.2.8/pjax.min.js sharejs 12https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.jshttps://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css gittalk 12gitalk: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.jsgitalk_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css valine 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.16/Valine.min.js disqusjs 123disqusjs: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/disqusjs/1.3.0/disqus.jsdisqusjs_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/disqusjs/1.3.0/disqusjs.css twikoo（这个是定制版） 1https://cdn1.tianli0.top/npm/js-heo@1.0.3/twikoo/twikoo.all.min.js twikoo（官方版） 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js waline 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/waline/1.5.4/Waline.min.js algolia 123algolia_js: https://cdn1.tianli0.top/npm/js-heo@1.0.11/algolia/algolia.jsalgolia_search: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/instantsearch.js/2.10.5/instantsearch.min.jsalgolia_search_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/instantsearch.js/2.10.5/instantsearch.min.css lazyload 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js instantpage 1https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js typed 1https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js fancybox 12fancybox_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.cssfancybox: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js medium_zoom 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/medium-zoom/1.0.6/medium-zoom.min.js snackbar 12snackbar_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.csssnackbar: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js fontawesome 1https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css translate 1https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js aplayer 123aplayer_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.cssaplayer_js: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.jsmeting_js: https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js Prism 123prismjs_js: https://cdn1.tianli0.top/npm/prismjs@1.1.0/prism.jsprismjs_lineNumber_js: https://cdn1.tianli0.top/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.jsprismjs_autoloader: https://cdn1.tianli0.top/npm/prismjs/plugins/autoloader/prism-autoloader.min.js justifiedGallery 12justifiedGallery_js: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.jsjustifiedGallery_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/css/justifiedGallery.min.css CDN选择原则优先使用字节跳动的cdn，如果没有则使用elemecdn。 个人社交资料在themes\\butterfly\\_config.yml中修改内容，社交图标https://fontawesome.com/ 网站图表头像修改首页打字机文字subtitle 图床1.基于Github仓库的图床优点： 很稳定不会跑路，用的是自己的仓库和公共托管平台 图片可以增量快速更新和跨设备管理 可以进行版本管理和查看之前的版本 有公共CDN，速度还是不错的 资源格式可以任意都行，包括css、js等 缺点： 每个仓库限制1G，超过要新建另一个仓库 git管理可能偶尔会遇到网络和公钥失效问题 1.1 建立Github仓库 进入Github官网注册并登录自己的账号，到自己的个人主页，点击右上角的+，并选择New Repository创建自己的仓库。 仓库名字随意，描述也可以自由发挥，可见性最好选public，Readme文件可以创建，然后点击Create Repository创建仓库。 让你的计算机与Github建立通信，这部分可以参考Hexo 博客搭建基础教程 (一)的第7点，主要是创建公钥、上传公钥、检查通信这几步，确保计算机有权限访问远程仓库，所述教程是用的RSA公钥，目前更推荐ed25519公钥，该数字签名算法的签名和验证的性能都极⾼，具体教程百度这里不再赘述。 先在本地创建一个文件夹，文件夹位置和名字随意就可以，进入该文件夹后右键打开Git Bash，然后输入以下代码把之前创建的仓库拷贝下来，其中git clone后面的东西要替换成自己的仓库信息，可以通过自己仓库的ssh链接来获取。 12BASHgit clone git@github.com:fomalhaut1998/pic_bed.git 看到上图的信息就代表成功把整个仓库拷贝到当前文件夹了，此时我们可以看见自己的文件夹多了个.git文件夹和Readme.md文件，这就代表成功了。 此时我们最好在这个文件夹里面创建创建一个img文件夹专门存放图片，如果有存放其他类型资源的可以创建别的文件夹，比如现在想往仓库里加两张图，直接就把图片复制到img文件夹里面即可。 然后在带有Readme.md文件的那个文件夹内，右键打开Git Bash（注意看清楚是什么文件夹），然后依次输入以下命令把更改推送到远程仓库，最后一步不成功可能要多试几次。 123456BASH# 将更改提交git add .git commit -m &quot;更新图片&quot;# 推送至github仓库git push 最后看见如下信息就代表推送成功了 仓库此时应该也有了刚刚上传的资源了 下次增删图片或者其他东西，就这样照猫画虎就可以推上来更新仓库！ 1.2 Staticaly CDN加速直接访问Github仓库的资源是非常慢的！因此我们要用一些免费的CDN进行加速，Staticaly CDN是目前免费CDN中比较好用的啦，他的应用规则如下： 123456PLAINTEXT# 格式 其中 user是用户名 repo是仓库名 version代表版本(tag或者分支 默认为main) flie是文件路径 https://cdn.staticaly.com/gh/user/repo@version/file# 比如我的示例仓库就是加速地址就是这个大家可以参考参考https://cdn.staticaly.com/gh/fomalhaut1998/pic_bed@main/img/p2.webp 1.3 Vercel 部署此方法加载速度较快，但是需要域名自定义绑定，其优点也是可以绑定自定义域了，目前Vercel每个月限制流量100GB 进入Vercel控制面板新建项目，并通过Github继续，选择导入刚刚创建的仓库，然后直接部署即可 进入该项目控制台后，选择右上角的View Domains添加新的域名，添加一个自己域名的二级域名，然后在你对应的域名解析控制台添加对应解析，等待生效。 通过自定义域名+资源路径即可访问到对应的资源，例如我这里为https://picbed.fomal.cc/img/p1.webp 要更新图片怎么办？只要将资源复制到对应的文件夹，然后再执行一次下面的命令即可： 123456BASH# 将更改提交git add .git commit -m &quot;更新图片&quot;# 推送至github仓库git push 这个命令默认是更新到仓库的main分支上，Vercel一旦检测到main分支发送变化就会触发新一轮部署，我们稍候片刻即可通过新的路径访问到新的资源。 1.4 Cloudflare 部署此方法速度比Vercel稍慢，但是可以不需要域名，目前我就在用这个，而且CloudFlare对于普通用户来说几乎不限量了 进入Cloudflare官网注册并登录自己的账号，然后进入控制台后选择左边的Pages，再创建一个新项目并通过Git进行连接，所有参数默认直接部署。 通过给出的初始域名+资源路径即可访问到的对应资源，例如我这个就是pic-bed-c6s.pages.dev/img/p1.webp，当然你也可以绑定自定义域名使用。 2.免费图床推荐 这部分免费图床就太多了，我会把我目前发现的可以免费白嫖一定额度的图床做一个总结列在下面 这部分图床的搭建门槛较低，所以速度和稳定性良莠不齐，大家自行选择使用哪个 我这里只给大家演示一种的使用方法，其他图床使用方法也类似 大家可以看看哪个比较好用的或者自己知道的好用的这里没有，可以留言我会进行补充 🍕 🥗 🍤 SMMS 聚合图床 遇见图床 PostImage 路过图床 imgURL imgbox Lsky Pro Upload.cc imagelol imgtp 云图床 载涂图床 Sky Chart Bed 风筝图床 喷子图床 imgkb 使用方法：直接进入官网，上传图片然后粘贴地址即可，地址的样式有多样，自行选择。 选择要点： 速度：大家可以到Ping.cn进行测试 稳定性与安全性：看看图床创建时间，网上评价等 可适用性：支持的格式越多肯定是越好的，有部分支持webp和其他格式的，可以当资源床 3.PicGo结合Markdown实时上传图片 Picgo究竟是什么？这是一个开源软件，开源地址：Molunerfinn&#x2F;PicGo 引用项目的介绍：这是一个用于快速上传图片并获取图片 URL 链接的工具，关键是他可以与Typora配套一起使用，在粘贴图片的同时上传图片，十分方便！ 最新版我这里实测没办法安装一些插件，因此推荐大家安装v2.3.1-beta.5这个版本 下载软件后直接一路安装下去就行，建议装在非C盘的任意一个盘。 3.1 Github图床 进入软件之后，一路到设置里面取消勾选其他图床，只留下Github图床一项，因为我们的现在要弄Github图床。 然后到Github新建一个仓库，创建仓库的教程前面有讲，这里就不赘述了，仓库名字和描述随意，最重要的是权限一定要选public，这样你的图片才可以随时随地访问到。在图床设置的Github配置处，按照下图填入对应的信息： 自定义域名的格式为：https://cdn.staticaly.com/gh/用户名/仓库名@main，比如我的就是https://cdn.staticaly.com/gh/fomalhaut1998/markdown_pic@main，对应的用户名和仓库名记住要换成自己名字，不能有空格！！！ Token的获取方式为：右上角头像-&gt;Setting-&gt;左边栏Developer Settings-&gt;左栏Personal access tokens-&gt;左栏tokens(classic) 创建Token时，Note随意；Exporation选No expiration，Select scopes必须把repo这一项勾上，然后点击生成就行 这个时候必须马上复制出现的token，不然后面就看不到了，复制了填进去刚刚的Token选项，随后点击确定保存 随便拖拽一张图片进来上传区域这里，应该就可以上传成功，随后把生成的链接复制就可以，此时打开仓库可以发现图片上传到了指定的文件夹。注意：每个仓库大小限制是1G！！！ 3.2 Vika图床Vika图床的服务器在国内，速度是比较快的 首先在Picgo里面安装Vikadata的插件 我们要填的信息有下面这几项： 进入维格表官网，注册自己的账号并登录，新建一个空白的维格表 随后点击左下角头像的个人设置，绑定自己的邮箱后，获取API Token 进入刚刚创建的表格后，点击上边的API，进入API界面后，依次点击显示API Token-&gt;Get 获取，然后图中框起来的就是我们需要的维格表ID和API Token 填进去对应位置后，到上传区域，把图床换成维格表，试试拖拽图片能不能上传！ 3.3 Bilibili图床 由于这个图床用在博客里存在跨域问题，因此不再推荐使用了，开源地址：typora-plugin-bilibili 如需了解使用教程，见视频教程第12期：免费图床综合教程（二） 3.4 imgtp图床 开源地址：picgo-plugin-imgtp 在Picg插件商店搜索并安装该插件 进入imgtp注册并登录自己的账号，记住账号密码，待会儿要用到 进入控制台，然后进入设置，就可以看到右边有Token这一项，这些就是我们要的全部信息 随后在imgtp的配置信息里面填上账号、密码、Token这几项即可 填进去对应位置后，到上传区域，把图床换成维格表，试试拖拽图片能不能上传！","tags":["Hexo"],"categories":["Hexo"]},{"title":"关于作者","path":"/about/index.html","content":"要不断的努力，才能成为更好的自己 ​ ​"}]